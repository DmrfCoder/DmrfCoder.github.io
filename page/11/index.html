<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="DmrfCoder的个人主页">
<meta property="og:url" content="http://www.mashangxue123.com/page/11/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DmrfCoder的个人主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/page/11/">





  <title>DmrfCoder的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/创建型模式——抽象工厂模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/创建型模式——抽象工厂模式/" itemprop="url">创建型模式——抽象工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T10:40:27+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>抽象工厂模式（Abstract Factory<br>Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>主要解决接口选择的问题。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>在一个产品族里面，定义多个产品。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>在一个工厂里聚合多个同类产品。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用<br>OO<br>的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>QQ 换皮肤，一整套一起换 </li>
<li>生成不同操作系统的程序。 </li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>产品族难扩展，产品等级易扩展。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类<br>ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 :<br><img src="//img-
blog.csdn.net/20180318154032560?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息<br>Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息<br>Color（RED / GREEN / BLUE），以便获取它所需对象的类型。</p>
<h3 id="为形状创建一个接口"><a href="#为形状创建一个接口" class="headerlink" title="为形状创建一个接口"></a>为形状创建一个接口</h3><p>Shape.java</p>
<pre><code>public interface Shape {
   void draw();
}
</code></pre><h3 id="创建实现形状接口的实体类"><a href="#创建实现形状接口的实体类" class="headerlink" title="创建实现形状接口的实体类"></a>创建实现形状接口的实体类</h3><p>Rectangle.java</p>
<pre><code>public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Square.java</p>
<pre><code>public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Square-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Circle.java</p>
<pre><code>public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle-&gt;draw() method.&quot;);
   }
}
</code></pre><h3 id="为颜色创建一个接口。"><a href="#为颜色创建一个接口。" class="headerlink" title="为颜色创建一个接口。"></a>为颜色创建一个接口。</h3><p>Color.java</p>
<pre><code>public interface Color {
   void fill();
}
</code></pre><h3 id="创建实现颜色接口的实体类"><a href="#创建实现颜色接口的实体类" class="headerlink" title="创建实现颜色接口的实体类"></a>创建实现颜色接口的实体类</h3><p>Red.java</p>
<pre><code>public class Red implements Color {

   @Override
   public void fill() {
      System.out.println(&quot;Inside Red-&gt;fill() method.&quot;);
   }
}
</code></pre><p>Green.java</p>
<pre><code>public class Green implements Color {

   @Override
   public void fill() {
      System.out.println(&quot;Inside Green-&gt;fill() method.&quot;);
   }
}
</code></pre><p>Blue.java</p>
<pre><code>public class Blue implements Color {

   @Override
   public void fill() {
      System.out.println(&quot;Inside Blue-&gt;fill() method.&quot;);
   }
}
</code></pre><h3 id="为-Color-和-Shape-对象创建抽象类来获取工厂"><a href="#为-Color-和-Shape-对象创建抽象类来获取工厂" class="headerlink" title="为 Color 和 Shape 对象创建抽象类来获取工厂"></a>为 Color 和 Shape 对象创建抽象类来获取工厂</h3><p>AbstractFactory.java</p>
<pre><code>public abstract class AbstractFactory {
   abstract Color getColor(String color);
   abstract Shape getShape(String shape) ;
}
</code></pre><h4 id="abstract复习"><a href="#abstract复习" class="headerlink" title="abstract复习"></a>abstract复习</h4><p>abstract修饰类，会使这个类成为一个抽象类，这个类将不能生成对象实例，但可以做为对象变量声明的类型（见下面代码），也就是编译时类型。抽象类就相当于一类的半成品，需要子类继承并覆盖其中的抽象方法。</p>
<h2 id="创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象"><a href="#创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象" class="headerlink" title="创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象"></a>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象</h2><p>ShapeFactory.java</p>
<pre><code>public class ShapeFactory extends AbstractFactory {

   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){
         return new Square();
      }
      return null;
   }

   @Override
   Color getColor(String color) {
      return null;
   }
}
</code></pre><p>ColorFactory.java</p>
<pre><code>public class ColorFactory extends AbstractFactory {

   @Override
   public Shape getShape(String shapeType){
      return null;
   }

   @Override
   Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase(&quot;RED&quot;)){
         return new Red();
      } else if(color.equalsIgnoreCase(&quot;GREEN&quot;)){
         return new Green();
      } else if(color.equalsIgnoreCase(&quot;BLUE&quot;)){
         return new Blue();
      }
      return null;
   }
}
</code></pre><h3 id="创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂"><a href="#创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂" class="headerlink" title="创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂"></a>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂</h3><p>FactoryProducer.java</p>
<pre><code>public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;)){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase(&quot;COLOR&quot;)){
         return new ColorFactory();
      }
      return null;
   }
}
</code></pre><h3 id="使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象"><a href="#使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象" class="headerlink" title="使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象"></a>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象</h3><p>AbstractFactoryPatternDemo.java</p>
<pre><code>public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {

      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);

      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取形状为 Rectangle 的对象
      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取形状为 Square 的对象
      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);

      //调用 Square 的 draw 方法
      shape3.draw();

      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);

      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor(&quot;RED&quot;);

      //调用 Red 的 fill 方法
      color1.fill();

      //获取颜色为 Green 的对象
      Color color2 = colorFactory.getColor(&quot;Green&quot;);

      //调用 Green 的 fill 方法
      color2.fill();

      //获取颜色为 Blue 的对象
      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);

      //调用 Blue 的 fill 方法
      color3.fill();
   }
}
</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>Inside Circle-&gt;draw() method.
Inside Rectangle-&gt;draw() method.
Inside Square-&gt;draw() method.
Inside Red-&gt;fill() method.
Inside Green-&gt;fill() method.
Inside Blue-&gt;fill() method.
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对比工厂方法模式，因为一个工厂只能生产一个产品，比如 <a href="http://blog.csdn.net/qq_36982160/article/details/79505390" target="_blank" rel="noopener"> 博客
</a><br>中一个ShapeFactory只能根据不同情况实例化不同的Shape，那么当我们需要一整套的产品（比如形状和颜色形成了一套产品）时使用工厂方法显然就不能解决了，所以就需要抽象工厂模式，抽象工厂模式实际上是工厂的工厂，即其作用的目的是为了实例化不同的工厂，用户再通过不同的工厂实例化不同场景下成套的产品。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/创建型模式——工厂方法(虚构造器)模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/创建型模式——工厂方法(虚构造器)模式/" itemprop="url">创建型模式——工厂方法(虚构造器)模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T10:04:36+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工厂模式（Factory Pattern）是 面向对象语言最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>定义一个创建对象的接口， <strong>让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行</strong> 。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>主要解决接口选择的问题。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>我们明确地计划不同条件下创建不同实例时。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>创建过程在其子类执行。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>你需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了 </li>
<li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以 </li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。 </li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="日志记录器"><a href="#日志记录器" class="headerlink" title="日志记录器"></a>日志记录器</h3><p>记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。</p>
<h3 id="数据库访问"><a href="#数据库访问" class="headerlink" title="数据库访问"></a>数据库访问</h3><p>当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过<br>new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们的demo使用 ShapeFactory 来获取 Shape 对象。它将向 ShapeFactory 传递信息（CIRCLE / RECTANGLE /<br>SQUARE），以便获取它所需对象的类型:<br><img src="//img-
blog.csdn.net/20180318151655716?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="创建一个接口"><a href="#创建一个接口" class="headerlink" title="创建一个接口"></a>创建一个接口</h2><p>Shape.java</p>
<pre><code> public interface Shape {
   void draw();
}
</code></pre><h2 id="创建实现接口的实体类"><a href="#创建实现接口的实体类" class="headerlink" title="创建实现接口的实体类"></a>创建实现接口的实体类</h2><p>Rectangle.java</p>
<pre><code>public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Square.java</p>
<pre><code>public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Square-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Circle.java</p>
<pre><code>public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle-&gt;draw() method.&quot;);
   }
}
</code></pre><h2 id="创建一个工厂，生成基于给定信息的实体类的对象"><a href="#创建一个工厂，生成基于给定信息的实体类的对象" class="headerlink" title="创建一个工厂，生成基于给定信息的实体类的对象"></a>创建一个工厂，生成基于给定信息的实体类的对象</h2><p>ShapeFactory.java</p>
<pre><code>public class ShapeFactory {

   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){
         return new Square();
      }
      return null;
   }
}
</code></pre><h2 id="使用该工厂，通过传递类型信息来获取实体类的对象"><a href="#使用该工厂，通过传递类型信息来获取实体类的对象" class="headerlink" title="使用该工厂，通过传递类型信息来获取实体类的对象"></a>使用该工厂，通过传递类型信息来获取实体类的对象</h2><p>FactoryPatternDemo.java</p>
<pre><code>public class FactoryPatternDemo {

   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();

      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);

      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>Inside Circle-&gt;draw() method.
Inside Rectangle-&gt;draw() method.
Inside Square-&gt;draw() method.
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>工厂方法模式其实就是当一个类的实例化依赖于不同场景时需要使用的，比如上面demo，根据不同的形状，实例化的Shape对象内部的实现逻辑不一样，这时候就可以使用工厂方法模式，将类内部的实现细节隐藏起来，用户只需要告诉工厂类自己需要什么情况下的产品，工厂就可以自动调用自己内部对应场景的代码从而返回一个用户需要的“产品”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/概述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/概述/" itemprop="url">概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T09:45:44+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。<br>毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p>
<h1 id="都有哪些设计模式"><a href="#都有哪些设计模式" class="headerlink" title="都有哪些设计模式"></a>都有哪些设计模式</h1><h2 id="创建型模式-对象怎么来"><a href="#创建型模式-对象怎么来" class="headerlink" title="创建型模式:对象怎么来"></a>创建型模式:对象怎么来</h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new<br>运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<h3 id="具体模式"><a href="#具体模式" class="headerlink" title="具体模式"></a>具体模式</h3><ul>
<li>工厂模式（Factory Pattern） </li>
<li>抽象工厂模式（Abstract Factory Pattern） </li>
<li>单例模式（Singleton Pattern） </li>
<li>建造者模式（Builder Pattern） </li>
<li>原型模式（Prototype Pattern） </li>
</ul>
<h2 id="结构型模式-对象和谁有关"><a href="#结构型模式-对象和谁有关" class="headerlink" title="结构型模式:对象和谁有关"></a>结构型模式:对象和谁有关</h2><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<h3 id="具体模式-1"><a href="#具体模式-1" class="headerlink" title="具体模式"></a>具体模式</h3><ul>
<li>适配器模式（Adapter Pattern） </li>
<li>桥接模式（Bridge Pattern） </li>
<li>过滤器模式（Filter、Criteria Pattern） </li>
<li>组合模式（Composite Pattern） </li>
<li>装饰器模式（Decorator Pattern） </li>
<li>外观模式（Facade Pattern） </li>
<li>享元模式（Flyweight Pattern） </li>
<li>代理模式（Proxy Pattern） </li>
</ul>
<h2 id="行为型模式-对象与对象在干嘛"><a href="#行为型模式-对象与对象在干嘛" class="headerlink" title="行为型模式:对象与对象在干嘛"></a>行为型模式:对象与对象在干嘛</h2><p>这些设计模式特别关注对象之间的通信。</p>
<h3 id="具体模式-2"><a href="#具体模式-2" class="headerlink" title="具体模式"></a>具体模式</h3><ul>
<li>责任链模式（Chain of Responsibility Pattern） </li>
<li>命令模式（Command Pattern） </li>
<li>解释器模式（Interpreter Pattern） </li>
<li>迭代器模式（Iterator Pattern） </li>
<li>中介者模式（Mediator Pattern） </li>
<li>备忘录模式（Memento Pattern） </li>
<li>观察者模式（Observer Pattern） </li>
<li>状态模式（State Pattern） </li>
<li>空对象模式（Null Object Pattern） </li>
<li>策略模式（Strategy Pattern） </li>
<li>模板模式（Template Pattern） </li>
<li>访问者模式（Visitor Pattern） </li>
</ul>
<h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h2 id="开闭原则（Open-Close-Principle）：实现热插拔，提高扩展性"><a href="#开闭原则（Open-Close-Principle）：实现热插拔，提高扩展性" class="headerlink" title="开闭原则（Open Close Principle）：实现热插拔，提高扩展性"></a>开闭原则（Open Close Principle）：实现热插拔，提高扩展性</h2><p>对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p>
<h2 id="里氏代换原则（Liskov-Substitution-Principle）：实现抽象的规范，实现子父类互相替换"><a href="#里氏代换原则（Liskov-Substitution-Principle）：实现抽象的规范，实现子父类互相替换" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）：实现抽象的规范，实现子父类互相替换"></a>里氏代换原则（Liskov Substitution Principle）：实现抽象的规范，实现子父类互相替换</h2><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP<br>是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<h2 id="依赖倒转原则（Dependence-Inversion-Principle）：针对接口编程，实现开闭原则的基础"><a href="#依赖倒转原则（Dependence-Inversion-Principle）：针对接口编程，实现开闭原则的基础" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）：针对接口编程，实现开闭原则的基础"></a>依赖倒转原则（Dependence Inversion Principle）：针对接口编程，实现开闭原则的基础</h2><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<h2 id="接口隔离原则（Interface-Segregation-Principle）：降低耦合度，接口单独设计，互相隔离"><a href="#接口隔离原则（Interface-Segregation-Principle）：降低耦合度，接口单独设计，互相隔离" class="headerlink" title="接口隔离原则（Interface Segregation Principle）：降低耦合度，接口单独设计，互相隔离"></a>接口隔离原则（Interface Segregation Principle）：降低耦合度，接口单独设计，互相隔离</h2><p>使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<h2 id="迪米特法则，又称最少知道原则（Demeter-Principle）：功能模块尽量独立"><a href="#迪米特法则，又称最少知道原则（Demeter-Principle）：功能模块尽量独立" class="headerlink" title="迪米特法则，又称最少知道原则（Demeter Principle）：功能模块尽量独立"></a>迪米特法则，又称最少知道原则（Demeter Principle）：功能模块尽量独立</h2><p>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<h2 id="合成复用原则（Composite-Reuse-Principle）：尽量使用聚合，组合，而不是继承"><a href="#合成复用原则（Composite-Reuse-Principle）：尽量使用聚合，组合，而不是继承" class="headerlink" title="合成复用原则（Composite Reuse Principle）：尽量使用聚合，组合，而不是继承"></a>合成复用原则（Composite Reuse Principle）：尽量使用聚合，组合，而不是继承</h2><p>尽量使用合成/聚合的方式，而不是使用继承。</p>
<h1 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h1><p>软件体系机构是指一个系统的有目的的设计和规划，这个设计规划既不描述活动，也不描述系统怎样开发，它只描述系统的组成元素及相互的交互协作。<br>一个UML模型只描述了一个系统要做什么，他并没有告诉我们系统怎么做。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本系列文章将主要参考：《设计模式——可复用面向对象软件的基础》&amp; <a href="http://www.runoob.com/design-
pattern/design-pattern-tutorial.html" target="_blank" rel="noopener"> http://www.runoob.com/design-<br>pattern/design-pattern-tutorial.html </a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/06/python中文件读写的基本操作/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/06/python中文件读写的基本操作/" itemprop="url">python中文件读写的基本操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T17:50:36+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>获取某一文件夹下的所有文件： </li>
</ul>
<pre><code>files1 = os.listdir(path1)#获取path1下的所有文件（夹）
</code></pre><ul>
<li>复制文件： </li>
</ul>
<pre><code>import shutil
shutil.copyfile(path1, path2)#将path1下的文件复制到path2
</code></pre><ul>
<li>从txt文件中获取数据到矩阵中： </li>
</ul>
<pre><code>import numpy as np
datai = np.loadtxt(path1)
</code></pre><ul>
<li>新建文件夹： </li>
</ul>
<pre><code>os.mkdir(path3 ）#新建一个path3文件夹
</code></pre><ul>
<li>将numpy矩阵保存到txt文件中： </li>
</ul>
<pre><code>np.savetxt(path, result)#将result（矩阵）保存到path路径
</code></pre><ul>
<li>重命名文件 </li>
</ul>
<pre><code>os.rename(path2, path2)#将path1重命名为path2
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/06/利用numpy对矩阵进行归一化处理的方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/06/利用numpy对矩阵进行归一化处理的方法/" itemprop="url">利用numpy对矩阵进行归一化处理的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T17:11:36+08:00">
                2018-03-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文不讲归一化原理，只介绍实现（事实上看了代码就会懂原理），代码如下：</p>
<pre><code>def Normalize(data):
    m = np.mean(data)
    mx = max(data)
    mn = min(data)
    return [(float(i) - m) / (mx - mn) for i in data]
</code></pre><p>代码只有5行并不复杂，但是需要注意的一点是一定要将计算的均值以及矩阵的最大、最小值存为变量放到循环里，如果直接在循环里计算对应的值会造成归一化特别慢，笔者之前有过深切的酸爽体验….</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/04/python报错 unindent does not match any outer indentation level解决方案/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/04/python报错 unindent does not match any outer indentation level解决方案/" itemprop="url">python报错 unindent does not match any outer indentation level解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-04T22:42:08+08:00">
                2018-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这种情况一般是因为在写代码的时候混用了TAB和空格进行缩进，所以仔细检查代码缩进，所有缩进对其后错误就会排除。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/02/26/android中AudioRecord使用详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/26/android中AudioRecord使用详解/" itemprop="url">android中AudioRecord使用详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-26T23:45:29+08:00">
                2018-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文介绍了android中AudioRecord的一些基本使用，主要参考官方文档，本文不讲过多理论知识，主要介绍在实际开发中的使用方法。</p>
<h1 id="类概述"><a href="#类概述" class="headerlink" title="类概述"></a>类概述</h1><p>AudioRecord类在Java应用程序中管理音频资源，用来记录从平台音频输入设备产生的数据。<br>通过AudioRecord对象来完成”pulling”（读取）数据。 应用通过以下几个方法负责立即从AudioRecord对象读取：</p>
<pre><code>read(byte[], int, int)
read(short[], int, int)
read(ByteBuffer, int).
</code></pre><p>无论使用哪种音频格式，使用AudioRecord是最方便的。</p>
<p>在创建AudioRecord对象时，AudioRecord会初始化，并和音频缓冲区连接，用来缓冲新的音频数据。<br>根据构造时指定的缓冲区大小，来决定AudioRecord能够记录多长的数据。 从硬件设备读取的数据，应小于整个记录缓冲区。</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><strong>public AudioRecord (int audioSource, int sampleRateInHz, int channelConfig,<br>int audioFormat, int bufferSizeInBytes)</strong></p>
<h2 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h2><p><strong>audioSource：</strong><br>音频源：指的是从哪里采集音频。这里我们当然是从麦克风采集音频，所以此参数的值为MIC<br><strong>sampleRateInHz：</strong><br>采样率：音频的采样频率，每秒钟能够采样的次数，采样率越高，音质越高。给出的实例是44100、22050、11025但不限于这几个参数。例如要采集低质量的音频就可以使用4000、8000等低采样率。<br><strong>channelConfig：</strong><br>声道设置：android支持双声道立体声和单声道。MONO单声道，STEREO立体声<br><strong>audioFormat：</strong><br>编码制式和采样大小：采集来的数据当然使用PCM编码(脉冲代码调制编码，即PCM编码。PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。)<br>android支持的采样大小16bit<br>或者8bit。当然采样大小越大，那么信息量越多，音质也越高，现在主流的采样大小都是16bit，在低质量的语音传输的时候8bit足够了。<br><strong>bufferSizeInBytes：</strong><br>采集数据需要的缓冲区的大小，如果不知道最小需要的大小可以在getMinBufferSize()查看。</p>
<h1 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h1><h2 id="public-int-getAudioFormat"><a href="#public-int-getAudioFormat" class="headerlink" title="public int getAudioFormat ()"></a>public int getAudioFormat ()</h2><p>返回设置的音频数据格式。</p>
<h2 id="public-int-getAudioSource"><a href="#public-int-getAudioSource" class="headerlink" title="public int getAudioSource ()"></a>public int getAudioSource ()</h2><p>返回音频录制源。</p>
<h2 id="public-int-getChannelConfiguration"><a href="#public-int-getChannelConfiguration" class="headerlink" title="public int getChannelConfiguration ()"></a>public int getChannelConfiguration ()</h2><p>返回设置的频道设置。</p>
<h2 id="public-int-getChannelCount"><a href="#public-int-getChannelCount" class="headerlink" title="public int getChannelCount ()"></a>public int getChannelCount ()</h2><p>返回设置的频道数目。</p>
<h2 id="public-static-int-getMinBufferSize-int-sampleRateInHz-int-channelConfig"><a href="#public-static-int-getMinBufferSize-int-sampleRateInHz-int-channelConfig" class="headerlink" title="public static int getMinBufferSize (int sampleRateInHz, int channelConfig,"></a>public static int getMinBufferSize (int sampleRateInHz, int channelConfig,</h2><p>int audioFormat)</p>
<p>返回成功创建AudioRecord对象所需要的最小缓冲区大小。<br>注意：这个大小并不保证在负荷下的流畅录制，应根据预期的频率来选择更高的值，AudioRecord实例在推送新数据时使用此值。</p>
<h3 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h3><pre><code>sampleRateInHz      默认采样率，单位Hz。

channelConfig           描述音频通道设置。

audioFormat             音频数据保证支持此格式
</code></pre><h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><p>如果硬件不支持录制参数，或输入了一个无效的参数，则返回ERROR_BAD_VALUE，如果硬件查询到输出属性没有实现，或最小缓冲区用byte表示，则返回ERROR。</p>
<h2 id="public-int-getNotificationMarkerPosition"><a href="#public-int-getNotificationMarkerPosition" class="headerlink" title="public int getNotificationMarkerPosition ()"></a>public int getNotificationMarkerPosition ()</h2><p>返回通知，标记框架中的位置。</p>
<h2 id="public-int-getPositionNotificationPeriod"><a href="#public-int-getPositionNotificationPeriod" class="headerlink" title="public int getPositionNotificationPeriod ()"></a>public int getPositionNotificationPeriod ()</h2><p>返回通知，更新框架中的时间位置。</p>
<h2 id="public-int-getRecordingState"><a href="#public-int-getRecordingState" class="headerlink" title="public int getRecordingState ()"></a>public int getRecordingState ()</h2><p>返回AudioRecord实例的录制状态。</p>
<h2 id="public-int-getSampleRate"><a href="#public-int-getSampleRate" class="headerlink" title="public int getSampleRate ()"></a>public int getSampleRate ()</h2><p>返回设置的音频数据样本采样率，单位Hz。</p>
<h2 id="public-int-getState"><a href="#public-int-getState" class="headerlink" title="public int getState ()"></a>public int getState ()</h2><p>返回AudioRecord实例的状态。 这点非常有用，用在AudioRecord 实例创建成功后，检查初始化属性。 它能肯定请求到了合适的硬件资源。</p>
<h2 id="public-int-read-short-audioData-int-offsetInShorts-int-sizeInShorts"><a href="#public-int-read-short-audioData-int-offsetInShorts-int-sizeInShorts" class="headerlink" title="public int read (short[] audioData, int offsetInShorts, int sizeInShorts)"></a>public int read (short[] audioData, int offsetInShorts, int sizeInShorts)</h2><p>从音频硬件录制缓冲区读取数据。</p>
<h3 id="参数解释：-1"><a href="#参数解释：-1" class="headerlink" title="参数解释："></a>参数解释：</h3><pre><code>audioData        写入的音频录制数据。

offsetInShorts           目标数组 audioData 的起始偏移量。

sizeInShorts              请求读取的数据大小。
</code></pre><h3 id="返回值：-1"><a href="#返回值：-1" class="headerlink" title="返回值："></a>返回值：</h3><p>返回short型数据，表示读取到的数据，如果对象属性没有初始化，则返回ERROR_INVALID_OPERATION，如果参数不能解析成有效的数据或索引，则返回ERROR_BAD_VALUE。<br>返回数值不会超过sizeInShorts。</p>
<h2 id="public-int-read-byte-audioData-int-offsetInBytes-int-sizeInBytes"><a href="#public-int-read-byte-audioData-int-offsetInBytes-int-sizeInBytes" class="headerlink" title="public int read (byte[] audioData, int offsetInBytes, int sizeInBytes)"></a>public int read (byte[] audioData, int offsetInBytes, int sizeInBytes)</h2><p>从音频硬件录制缓冲区读取数据。</p>
<h3 id="参数解释：-2"><a href="#参数解释：-2" class="headerlink" title="参数解释："></a>参数解释：</h3><pre><code>audioData        写入的音频录制数据。

offsetInBytes            audioData的起始偏移值，单位byte。

sizeInBytes                读取的最大字节数。
</code></pre><h3 id="返回值：-2"><a href="#返回值：-2" class="headerlink" title="返回值："></a>返回值：</h3><p>读入缓冲区的总byte数，如果对象属性没有初始化，则返回ERROR_INVALID_OPERATION，如果参数不能解析成有效的数据或索引，则返回ERROR_BAD_VALUE。<br>读取的总byte数不会超过sizeInBytes。</p>
<h2 id="public-int-read-ByteBuffer-audioBuffer-int-sizeInBytes"><a href="#public-int-read-ByteBuffer-audioBuffer-int-sizeInBytes" class="headerlink" title="public int read (ByteBuffer audioBuffer, int sizeInBytes)"></a>public int read (ByteBuffer audioBuffer, int sizeInBytes)</h2><p>从音频硬件录制缓冲区读取数据，直接复制到指定缓冲区。 如果audioBuffer不是直接的缓冲区，此方法总是返回0。</p>
<h3 id="参数解释：-3"><a href="#参数解释：-3" class="headerlink" title="参数解释："></a>参数解释：</h3><pre><code>audioBuffer               存储写入音频录制数据的缓冲区。

sizeInBytes                请求的最大字节数。
</code></pre><h3 id="返回值：-3"><a href="#返回值：-3" class="headerlink" title="返回值："></a>返回值：</h3><p>读入缓冲区的总byte数，如果对象属性没有初始化，则返回ERROR_INVALID_OPERATION，如果参数不能解析成有效的数据或索引，则返回ERROR_BAD_VALUE。<br>读取的总byte数不会超过sizeInBytes。<br>public void release ()：释放本地AudioRecord资源。<br>对象不能经常使用此方法，而且在调用release()后，必须设置引用为null。</p>
<h2 id="public-int-setNotificationMarkerPosition-int-markerInFrames"><a href="#public-int-setNotificationMarkerPosition-int-markerInFrames" class="headerlink" title="public int setNotificationMarkerPosition (int markerInFrames)"></a>public int setNotificationMarkerPosition (int markerInFrames)</h2><p>如果设置了setRecordPositionUpdateListener(OnRecordPositionUpdateListener)或setRecordPositionUpdateListener(OnRecordPositionUpdateListener,<br>Handler)，则通知监听者设置位置标记。</p>
<h3 id="参数解释：-4"><a href="#参数解释：-4" class="headerlink" title="参数解释："></a>参数解释：</h3><pre><code>markerInFrames      在框架中快速标记位置。
</code></pre><h3 id="返回值：-4"><a href="#返回值：-4" class="headerlink" title="返回值："></a>返回值：</h3><p>返回错误或成功代码，请见SUCCESS、ERROR_BAD_VALUE、ERROR_INVALID_OPERATION。</p>
<h2 id="public-int-setPositionNotificationPeriod-int-periodInFrames"><a href="#public-int-setPositionNotificationPeriod-int-periodInFrames" class="headerlink" title="public int setPositionNotificationPeriod (int periodInFrames)"></a>public int setPositionNotificationPeriod (int periodInFrames)</h2><p>如果设置了setRecordPositionUpdateListener(OnRecordPositionUpdateListener)或setRecordPositionUpdateListener(OnRecordPositionUpdateListener,<br>Handler)，则通知监听者设置时间标记。</p>
<h3 id="参数解释：-5"><a href="#参数解释：-5" class="headerlink" title="参数解释："></a>参数解释：</h3><pre><code>markerInFrames      在框架中快速更新时间标记。
</code></pre><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回错误或成功代码</p>
<h2 id="public-void-setRecordPositionUpdateListener"><a href="#public-void-setRecordPositionUpdateListener" class="headerlink" title="public void setRecordPositionUpdateListener"></a>public void setRecordPositionUpdateListener</h2><p>(AudioRecord.OnRecordPositionUpdateListener listener, Handler handler)</p>
<p>当之前设置的标志已经成立，或者周期录制位置更新时，设置处理监听者。 使用此方法来将Handler 和别的线程联系起来，来接收AudioRecord<br>事件，比创建AudioTrack 实例更好一些。</p>
<h3 id="参数解释：-6"><a href="#参数解释：-6" class="headerlink" title="参数解释："></a>参数解释：</h3><pre><code>handler    用来接收事件通知消息。
</code></pre><h2 id="public-void-setRecordPositionUpdateListener-1"><a href="#public-void-setRecordPositionUpdateListener-1" class="headerlink" title="public void setRecordPositionUpdateListener"></a>public void setRecordPositionUpdateListener</h2><p>(AudioRecord.OnRecordPositionUpdateListener listener)</p>
<p>当之前设置的标志已经成立，或者周期录制位置更新时，设置处理监听者。</p>
<h2 id="public-void-startRecording"><a href="#public-void-startRecording" class="headerlink" title="public void startRecording ()"></a>public void startRecording ()</h2><p>AudioRecord实例开始进行录制。</p>
<h1 id="受保护方法"><a href="#受保护方法" class="headerlink" title="受保护方法"></a>受保护方法</h1><h2 id="protected-void-finalize"><a href="#protected-void-finalize" class="headerlink" title="protected void finalize ()"></a>protected void finalize ()</h2><p>通知VM回收此对象内存。 此方法只能用在运行的应用程序没有任何线程再使用此对象，来告诉垃圾回收器回收此对象。</p>
<p>此方法用于释放系统资源，由垃圾回收器清除此对象。 默认没有实现，由VM来决定，但子类根据需要可重写finalize()。<br>在执行期间，调用此方法可能会立即抛出未定义异常，但是可以忽略。</p>
<p>注意：VM保证对象可以一次或多次调用finalize()，但并不保证finalize()会马上执行。<br>例如，对象B的finalize()可能延迟执行，等待对象A的finalize()延迟回收A的内存。<br>为了安全起见，请看ReferenceQueue，它提供了更多地控制VM的垃圾回收。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/02/25/《颠覆者》/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/25/《颠覆者》/" itemprop="url">《颠覆者》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-25T14:02:09+08:00">
                2018-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本博客主要记载国内第一民间网络安全公司360创始人兼CEO周鸿祎的自传《颠覆者》中较为经典的语录。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>实现自我颠覆的人都有一点共性。通过我的观察，最终能够实现这种颠覆的人，都有着强烈的“内在驱动力”和“使命感”，如同万维钢在《智识分子》这本书里写到的那样：“内在动力才真正体现了一个人的自由意志，我之所以这么干不是谁刺激我，而纯粹是因为我就想这么干。对于这些人来说，工作已经不是简单的上下班的事了，而是一项事业。他们做这件事不需要外界的监督和激励，是自己要求自己非要把这件事情做成不可。所以真正了不起的事业应该是由使命感驱动”</p>
<p>所谓英雄，就是超越了阶层出身、超越了周边环境、超越了性格局限，拒绝按照任何设定好的程序行事，不能被大数据预测，能给世界带来惊喜，最不像机器的人。（万维钢<br>《智识分子》）</p>
<p>英雄，不是那些被大数据预测的俗人，他们，让这个世界变得有意思。</p>
<p>从零到一，每个创业者在从无到有创立一家公司后，都要经受非人的考验，每一天都有形式不同的突发情况，大家都要经历那种面对突发情况的紧、九死一生的惊险、迅速做出决定的逼仄、死而复生的恍惚。这所有的一切都如同<br><strong>本.霍洛维茨</strong> 在《创业维艰》中描述的那样——解决这些难题，没有任何公式套路可用。</p>
<p>但让人无奈的是，每一次美国做空机构都是在他们的白天发布报告，而我不得不在中国的半夜把员工叫起来开会应对。这样的剧情如此反复循环重复，实在让人睡眠不足。</p>
<p>在我从事软件行业的时候，很少有人直到软件是什么，电脑只是一个行业，电脑工程师只是一个职业。但是今天，无论是手机APP，还是智慧城市、电子政务、物联网（IOT），以及将来的无人驾驶汽车，很多东西都和软件息息相关。人们开始说，软件定义世界，一切皆可编程，万物均要互联。</p>
<p>我认为一个企业的存在不在于你的股价有多高，因为股价再高，随着历史的推进，有一天也终会跌到零；也不在于企业有多少利润，这些东西都会随着时间的流逝而消逝。有的公司消逝了大家可能感觉无所谓，或者很快就有替代产品出现，大家不觉得缺这样一家公司别人会为它感到难过。我希望我们能做一家让大家离不开的公司。</p>
<p>作为一个决策者，做决定很多时候都要面临艰难的处境，但是决策必须当机立断，正如 <strong>本.霍洛维茨</strong><br>在《创业维艰》里说的那样——那些看似微不足道的踌躇和犹豫，可能会造成致命的延误。我承担不起任何犹豫不决。</p>
<p>虽然有精忠报国的愿望，也对未来充满了希望。但是市场不相信口号，也不相信眼泪，投资人不会为你的理想买单，</p>
<p>如果对360的私有化做一个比喻，我觉得这个过程就像我们半夜在盘山公路狂奔，没有开灯。但是回头看，幸亏我们没有开灯。如果直到路途如此惊险，也许在路途中，我们早已吓得魂飞魄散。</p>
<p>真正的勇敢，并非骁勇善战，而是无论何时何地都不忘初心，坚守信仰，并秉持自己始终不会放弃的那种纯粹。</p>
<p>人类社会经历过的PC互联网时代、移动互联网时代，以及现在所处的物联网时代，技术发展和商业模式创新之间始终是相辅相成的关系，每当科技发展的红利被商业模式创新挖掘殆尽后，经济也随之步入寒冬，直到下一次技术革命的出现，商业模式创新才能重新迸发生机。</p>
<p>现阶段移动互联网的商业模式创新已经挖光了Web2.0时代的技术红利，所有人都在寻找新技术，以期获得新的商业模式创新。人工智能技术无疑就是下一轮技术革命的焦点，假如未来的某一天，我们在这方面有了突破，那么新的商业模式也将涌现出来，带来一个甚至多个万亿级市场。</p>
<p>在我们的世界中，科技已经如自然一样成为一股强大的力量，而我们将借助这种力量，乘风破浪。对于人工智能时代的来临，我愿意引用 <strong>凯文.凯利</strong><br>在《必然》中描述的场景，对此我深信不疑：</p>
<p><em>千年之后，当历史学家回溯过往的时候，会认为第三个千禧之年的开端是一个古老的绝妙时代。在这个时代中，地球上的居民首次把自己与一种巨大的失误相连。未来，它的规模将会继续增加，但是如今，你我正生活在它刚刚苏醒的时刻。</em></p>
<p><em>未来的人们会羡慕我们，希望自己也能亲眼见证它的诞生。这些年里，人类开始用微小的智能让没有生气的事物变得活跃，把他们编织进云端机器智能这张大网中，并将数十亿心智作为一个超级心智相连。</em></p>
<p><em>这个聚拢的过程将被当做这个星球上迄今为止发生的最重要的、最负责任也是最令人惊叹的事件。</em></p>
<p>单纯的理工男经常缺乏基本的人文认知，就算技术再好也有软肋。</p>
<p>文字素养是一个人的基本素养。文字不好，你没有办法写出一个漂亮的商业计划书，前言不搭后语而经常错失投资人；文字不好，你没有办法成为一个好的产品经理，因为你没有办法精准地描述出产品的功能，打动不了用户；文字不好，你不能和竞争对手在公开领域沟通，做不出好的PR（公关），甚至连场口水仗都赢不了。</p>
<p>《史蒂夫.乔布斯传》、《富兰克林传》、《爱因斯坦传》的作者 <strong>沃尔特.艾萨克森</strong><br>在写了这些伟人的传记后从他们的身上得出了：一个具有强烈个性的人身上集合了人文和科学的天赋后所产生的那种创造力，我相信这种创造力也是在21世纪建立创新型经济的关键因素。</p>
<p>尽管破旧的城市、沉闷的生活，以及正统的世界让我没有方向，但是计算机那扇窗已经略微地打开了，若隐若现的光照射进来，变成了我每天生活的希望。</p>
<p>作为一个年轻人，真正幸运的并不是在很年轻的时候就得到了很多财富，而是在成年之前就感受到了自己来到这个世界的使命，有了目标之后努力才不会盲目。</p>
<p><strong>丹尼尔.科伊尔</strong><br>在《一万小时天才理论》中说：“在未来某些时候，也许已经发生了——你会坠入爱河。不是和某个人，而是和某个你自己的想法——关于你想成为谁，关于你生来会成为谁。这种爱，这种激情，就是发展才能的原始燃料”。</p>
<p>“我的理想很明确，这辈子就要做一个电脑软件的开发者。做一款产品，改变世界”。 ——周鸿祎在高二班会上关于自己理想的描述</p>
<p>乔布斯说：“一个人开始热爱一件事的时候，就会达到一种非理性的状态”。</p>
<p>做一件事情总要不计回报，一旦投入了全部的感情，最后的回报总会出其不意地到来。</p>
<p>做产品不能总从程序员和产品经理的角度出发，还要化繁为简，达到使用的极简主义。</p>
<p>我的大学很充实，但似乎很难用开心和不开心来总结。开心来自简单的事情：吃了一顿好饭、听了一首好歌、疯狂地读了一晚上程序，或者暑假的时候邮购了音响零件，自己制成了一个噪声巨大的音响。而不开心的时候也是有的：走在西安交通大学的林荫大道上，没有姑娘的瞩目，没有浪漫的故事，有的只是一颗理工男的寂寞心，偶尔悲壮。</p>
<p>如果一个社会只以成败论英雄，或者只以金钱多少论英雄，是不可能激励年轻人创新的。</p>
<p>注册公司只是创业的形式，创业的关键在于推出什么样的产品。</p>
<p>周鸿祎描述当初创业做反病毒卡的自己：“一个希望以查杀计算机病毒起家的学生公司，需要每天在电脑上调试程序，寻找病毒特征，而此时，我们连一台属于自己的计算机都没有。”</p>
<p>王朔在《玩的就是心跳》中说：“我们受的教育一贯是把个人置于一种渺小的境界。这是我们的悲剧，也是我们的习惯，很明白却无能为力”。</p>
<p>现实世界让我认识到，客户使用产品的环境远远比试验中的环境复杂，你必须从客户的角度去考虑和解决问题。从那个时候开始，我作为技术专家的优越感和自负被砍掉，这就是做第一个产品让我悟出的道理。</p>
<p>做生意并不像想象中的那样充满浪漫，做生意是丑陋的、累心的、让人见识冷血和无情的。</p>
<p>当我们尝试一个新技能时，我们就像进入黑屋子的人，总是碰到家具，但是每次碰撞都会让我们明确往哪走。我们不应该忽视错误或者试图忘记它们，因为它们为我们指出了道路所在，同时为我们指出了一个事实，那些不敢冒险的人就无法施展它们的才华。——《一万小时天才理论》</p>
<p>固执是产品经理的大敌。</p>
<p>在任何一个领域想要出众，都是要经过至少一万小时的练习才可以。并且，这些练习并不是在你的舒适区进行，而是要在容易犯错的地方进行精深练习。</p>
<p>以我自身经验来说，大学生也好，研究生也好，我已经算是比一般的学生更接近社会三教九流的人了，但是当我真正走出去的时候，我还是感觉离真正的时长太远太远了。</p>
<p>创业是一种精深，但是不要为了创业而创业，不要把创业狭义地理解为开公司，当CEO。这种事情太容易了，但是它未必成功。</p>
<p>无论你做什么，所有的努力都不会白费。</p>
<p>今天的辛苦，就是明天的财富。</p>
<p>关于谈恋爱，我并不是很在行，我很少地会讨好地说一些甜言蜜语去“撩妹”，一般只是讲述自己的事儿。那个时候我还是个很落魄的小工程师，每个月的收入只有1000块，没单独的地方住，每天在北大食堂蹭饭吃，外表看上去毫不起眼。在胡欢（周鸿祎的妻子）面前，我喜欢讲述自己过去创业的经历，大谈特谈自己的梦想、未来自己想做的事，我讲到我会怎么样用一个软件或者程序去改变世界，一副“`天将降大任于斯人也”的样子。一般女孩看到我这样的人，会觉得我有点不切实际，或者是神经病，但是胡欢没有这样认为。她一直坚信我说的是真的，并且后来也一直用行动支持着我。</p>
<p>做产品的人往往都会把自己的主观感受无限放大，把自己的需求认为是所有人的需求。</p>
<p>高瞻远瞩不是天生的，每个人的见识都是一点一点积累出来的。</p>
<p>很多互联网的成功其实都不是技术的成功，而是商业模式和理念的成功。</p>
<p>周鸿祎关于“裸辞”的回忆：“我就是当年‘裸辞’的程序员一名。除了我以外，第一代互联网创业者都在当时纷纷‘裸辞’了，丁磊和马云辞得更彻底。《沸腾十五年》里记录：1995年，丁磊从宁波电信局辞职，按照规定，这个时候大学生辞职要补偿国家培养大学生的费用，要交1万元。但丁磊当时没有那么多钱，只能提着箱子离开了单位，结果按照除名处置。同一年，马云向杭州电子科技大学提出辞职，第二天就借了10万元注册公司。他们比‘裸辞’做得更进一步，一辞职就负债了，比‘裸辞’更绝”。</p>
<p>创业者的孤独，不仅仅是要忍受创业路上资金的捉襟见肘、寻找投资人的种种困难，还要承受大多数人可能根本听不懂你创意的现实，一瞬间，你变成了孤独的星球。</p>
<p>互联网公司开发布会其实是挺可笑的一件事，最牛的互联网产品应该是人们使用过之后觉得这个产品太好了，急不可待地介绍给周围的朋友。最后用户量通过口碑营销不知不觉地就涨起来了。产品做得不好，发布会开的再绚烂也没用，这都是在漫无目的地烧钱。</p>
<p>很多创业者长期沉浸在自己的世界里，相信自己的直觉和判断，有的时候甚至到了偏执的状态，听不进去有经验人的劝解，最终错过了发展黄金期。</p>
<p>创业，每天都是在走钢丝，每天都是在做选择题，每天都在对抗杂乱无章的信息。<br>很多创业者的路，都是在一片从未有过脚印的土地上一路走过来的。<br>谁痛苦谁知道。</p>
<p>竞争对手是你的磨刀石，竞争对手越强大，对你的磨炼和考验越大，很多坚强的性格，都是残酷的市场竞争的衍生品。狼性和血性都是伴随着对人性的观察和考验而来的。</p>
<p>市场竞争，绝不会留给竞争者闪烁一个悲伤眼神的时间。</p>
<p>你以为自己已经跌倒了谷底，其实还有更深的深渊在前方等待，这是创业者时常遇到的境遇。</p>
<p>互联网上的应用，多一步就是99%的损耗。</p>
<p>一个公司对用户不作恶是成功的基础。</p>
<p><strong>韦尔奇</strong><br>在《商业的本质》中写到：这是一种很稀缺的优秀品质。我们谈论的不是对风险的普通容忍。要成为一个企业家，你需要极大的勇气、疯狂的激情和超出理性的决心，忍受反复出现的近乎死亡的体验。</p>
<p>品牌延伸让新的产品在人们心目中没有自己独立的位置，还会让原来的品牌地位模糊不清，结往往是灾难性的。</p>
<p>对于跟随者来说，跟风发起跟风产品，绝对不是好的策略，因为好的品牌已经在消费者的心中占据了统治地位，这种地位一时间很难挑战。新的公司只有在大公司的业务机构里寻找薄弱环节，跟随者才有厚积薄发的可能。</p>
<p>作为一家技术公司，别的都是虚的，用户体验才是最重要的。</p>
<p>富贵非吾志。但知临水登山啸咏，自引壶觞自醉。<br>此生天命更何疑？且乘流，遇坎还止步。</p>
<p>成功都是熬出来的，成功都是被逼出来的，很多时候，是看你熬不熬得住。</p>
<p>互联网是不断变化的，经验往往是靠不住的，你必须随时处于归零状态，从用户角度出发，随时把握用户新的需求。</p>
<p>只要在江湖，就难以避免征战，难以避免经理一些黑暗的时光；<br>只要在江湖，就经常面临利益与长远的选择。</p>
<p>真正的光明却不是没有黑暗的时间，只是永不被黑暗所掩蔽罢了。真正的英雄绝不是没有卑下的情操，只是永不被卑下的情操屈服罢了。</p>
<p>只要是人人都需要的，就应该是免费的。</p>
<p>任何企业都可以找最强的竞争对手打，但是有一个对手是你打不过的，那就是趋势，趋势一旦爆发，就不会是一种线性的发展。它会积蓄力量于无形，然后突然爆发出雪崩效应。任何不愿意改变的力量都会在雪崩面前被毁灭，被市场边缘化。</p>
<p>将来会有越来越多的管理者认识到，保守而谨慎，必将引向毁灭之路，而不可能逃避经济风暴的摧残或将此作为长治久安的生存方式。</p>
<p>互联网公司之间竞争的严酷程度大大超过了普通的商业战争，大家都无所不用其极。</p>
<p>中国做互联网的人，一定会遇到三个无法回避的问题：生、死、腾讯。</p>
<p>任何做客户端的都怕腾讯，主要是怕两方面：第一是被它抄袭，第二是它厉害的推广平台。</p>
<p>真正的难题不是拥有伟大的梦想，而是你在半夜一身冷汗地惊醒时，发现梦想变成了一场噩梦。 ——《创业维艰》</p>
<p>商场就是战场，我们同样是战场上的军人，商业竞争对手就是我们的敌人，他们像饥饿的狼群一样守候在我们的身旁，随时准备吞噬着我们的客户。如果我们畏惧、退让，那么他们张开的血盆大口就会连同我们一起吞噬。</p>
<p>任何中国的互联网创业公司发展到一定的阶段，必然会遭遇腾讯“抄袭+捆绑”的“水泥天花板”。</p>
<p>正如人体骨骼在负重和压力下反而会越发强壮，谣言和暴动在遏制和镇压下反而愈演愈烈一样，我们生活中的许许多多事物也会从压力、混乱、波动和动荡中受益。</p>
<p>创业就像是搏击，不仅是因为要不停痛击你的对手。创业艰辛而孤独，需要持续不断地集中注意力。无论你做的多好，你都必须时刻准备再一次出拳打击。在搏击中，你被打了，感到痛苦不堪，然后你坐在场边，等肾上腺素消逝后，你才真切感受到那疼痛，然后，你要再去打下一回合。</p>
<p>似乎每个创业者在外界看来都是气势汹汹，但是每个人的心里有很多不踏实的地方，没有安全感。也许正是这种特质，造就了这类人容易成就一番事业。一个容易骄傲自满的人，不可能走得长远。</p>
<p>人们总是问我：当一名CEO的秘诀是什么？<br>遗憾的是，没有秘诀。如果说存在这样一种技巧，那就是看其专心致志的能力和在无路可走时选择最佳路线的能力。与普通人相比，那些令你想躲藏起来甚至直接死掉的时刻，就是你作为一名CEO要经历的不同于常人的地方。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/02/15/2017年度总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/15/2017年度总结/" itemprop="url">2017年度总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-15T23:55:31+08:00">
                2018-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>写在前面：讲道理我是不太擅长于写这类非技术性的博文，但是觉得一眨眼又走过了一年，是得停下脚步回头看看，写点东西记录一下这一年的得失、展望一下新的一年，为新的一年立一些flag，如果没有什么意外以后每一年的年末我都会写一篇这样的总结性文章作为自己成长路上的标记，希望若干年后的自己可以通过这些东西看到当年的自己。</p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>其实今年前期还是很在意学习方面的，也花费了很多时间在平时的课程上，可是好像out和in有点不对应，而且挤掉了很多本该用来做自己喜欢的事情上的时间，到后来就干脆顺其自然，没有太在意这方面，事实证明好像也没太大负面影响，而且可以有很多时间去研究自己感兴趣的东西，觉得这样挺好。但是回过头来客观来说还是学渣一枚（哭），看看身边大佬的绩点再看看自己的真的被虐到了，希望在新的一年里在学业上可以有进步，起码绩点不要太低，最好英语过六级哈哈</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>今年前期重点主要放在了开发类上面，利用时间做了几个hobby<br>project，基本上都是android项目，接了几个朋友介绍的外包都是做一些边缘开发没有做到很核心的大项目，这和自己的技术不过关有很大的关系，后来在老哥的指导下基本弃了开发类的学习转到DL方面，帮着别人做了两个DL的基础识别应用觉得很受鼓舞，还有就是参加了创新工场的场景分类比赛拿到了名次，但是想一下这些东西都只是套别人的模型做了一下复现，很多核心的理论知识都不懂，所以希望新的一年可以静下心来研究一下DL的相关原理，打好理论基础。</p>
<h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><p>今年暑假本来有机会去网易做实习，但是由于提前被国防企业面对面的活动埋进坑里再加上对自己的技术不是很自信所以就阴差阳错丢掉了机会，寒假又不想离家太远想回家陪爸妈所以更没时间，希望2018的自己可以去参加一两场实习跟着老哥混混职场，也为了给简历上加两行字哈哈。</p>
<h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><p>今年好像大大小小也参加了十几场比赛，拿了一点奖（大多都是参与奖哈哈），但是也搞了很多和专业不想关的比赛（比如环保知识竞赛……我也不知道当时怎么就脑抽参加这种比赛），在比赛中认识了很多大牛，增长了自己的见识，希望明年的自己可以少参加一些没必要的比赛，把主要精力放在对自己重要的比赛上，这样可能产值会高一点。</p>
<h2 id="科创"><a href="#科创" class="headerlink" title="科创"></a>科创</h2><p>科创刚开题的那段时间好像什么都想做，觉得好像一个月就能肝完一个项目，后来阴差阳错接到超哥的题目，才发现都是自己太单纯，各种问题源源不断，到现在也没一个理想的成果，说到底还是自己太浮躁太心急，希望新年可以静下心来耐心搞完这个题目，至于明年还要不要再接科创就要看明年科创开题时的心情了说不定到时候一抽风又给自己背个锅，不管怎么样一定保佑今年的题目结题<br>啊！！！</p>
<h2 id="感情"><a href="#感情" class="headerlink" title="感情"></a>感情</h2><p>今年前半年我还是有女朋友的，可是到这会早就成一个人撸键盘了，老铁们都说是我情商太低，我觉得也是哈哈，毕竟自己几乎把所有空闲时间都给了电脑键盘，谁也受不了啊，所以就顺其自然吧，相信缘分就好。</p>
<h2 id="鸡汤"><a href="#鸡汤" class="headerlink" title="鸡汤"></a>鸡汤</h2><p>之前一直觉得搞技术的就得老老实实学技术，直到后来老哥的话改变了我的想法，从吴军的专栏到逻辑思维的某些文章再到周鸿祎的自传，让我懂了互联网行业不光是有技术就行，还得有不可言说的境界与见识，希望18年的自己可以抽一些时间补一些行业的经典读物，提升一下自己的见识与境界。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这会觉得自己过去的一年好像一事无成，觉得自己过去的一年很浮躁，忙忙碌碌一年也没什么太大的收获，希望18年的自己可以静下心来做一些应该做的事情，希望明年这个时候可以有更多的收获，加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/02/12/使用gdb调试程序完全教程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/12/使用gdb调试程序完全教程/" itemprop="url">使用gdb调试程序完全教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-12T15:14:07+08:00">
                2018-02-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近用python做数据可视化导入moviepy的时候报错imageio.core.fetching.NeedDownloadError: Need<br>ffmpeg exe. You can download it by calling:<br>imageio.plugins.ffmpeg.download()<br><img src="https://img-
blog.csdn.net/20180212151002752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>按照提示是要下载ffmpeg，所以只需import imaheio并download即可，即在程序的开始加上：</p>
<pre><code>import imageio
imageio.plugins.ffmpeg.download()
</code></pre><p>注意：这两行代码一定要加在import moviepy之前。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">128</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">94</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
