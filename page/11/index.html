<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="DmrfCoder的个人主页">
<meta property="og:url" content="http://www.mashangxue123.com/page/11/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DmrfCoder的个人主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/page/11/">





  <title>DmrfCoder的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/01/25/Android动态权限申请/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/25/Android动态权限申请/" itemprop="url">Android动态权限申请</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-25T14:47:35+08:00">
                2018-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>本文介绍了如何用最短的代码解决Android 6.0以上的动态权限申请问题</p>
<h1 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h1><p>本文不讲原理不讲过程只讲如何用最简单的方法使用，如想了解具体原理可深入工具类的源码进行学习，或者去找其他资源。</p>
<h1 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h1><p>在你项目的app gradle的dependencies下添加下列语句：</p>
<pre><code>implementation  &apos;com.github.dfqin:grantor:2.1.0&apos;
</code></pre><p>添加后Sync，即可将相关工具代码导入</p>
<h1 id="代码实现动态权限申请"><a href="#代码实现动态权限申请" class="headerlink" title="代码实现动态权限申请"></a>代码实现动态权限申请</h1><p>首先要保证在manifests里面加上你需要的权限，然后在MainActivity中添加如下方法：</p>
<pre><code>private void RequestPermission() {
        String[] permissions = {Manifest.permission.RECORD_AUDIO, Manifest.permission.WRITE_EXTERNAL_STORAGE};
        if (PermissionsUtil.hasPermission(MainActivity.this, permissions)) {
            //已经获取相关权限
        } else {
            PermissionsUtil.requestPermission(MainActivity.this, new PermissionListener() {
                @Override
                public void permissionGranted(@NonNull String[] permission) {
//用户授予了权限
                }

                @Override
                public void permissionDenied(@NonNull String[] permission) {
//用户拒绝了权限
                    Toast.makeText(MainActivity.this, &quot;相关权限被拒绝，本应用将无法正常运行&quot;, Toast.LENGTH_SHORT).show();
                }
            }, permissions);
        }
    }
</code></pre><p>然后在OnCreate中调用该方法即可，如果要申请其他的权限只需要把本文代码中permissions的内容改成你自己的即可。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/dfqin/article/details/55190073" target="_blank" rel="noopener"> http://blog.csdn.net/dfqin/article/details/55190073
</a> 感谢博主提供的轮子。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/01/13/八大常见排序算法介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/13/八大常见排序算法介绍/" itemprop="url">八大常见排序算法介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-13T21:26:07+08:00">
                2018-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>首先将第二个数与第一个数进行对比，如果第二个数比第一个数小，则将第二个数插入到第一个数之前，这样保证前两个数是有序的；<br>接下来将第三个数与前两个数对比，发现有比第三个数大的数即将第三个数插入到对应数的前面，这样一次插入可保证前三个数是有序的；<br>以此类推，将后面的i个数分别其前面的i-1个数进行对比，并将其插入到第一个比其大的数前面，最后即可完成排序。</p>
<h2 id="时间空间复杂度及稳定性"><a href="#时间空间复杂度及稳定性" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(n^2) </li>
<li>S(n)=O(1) </li>
<li>稳定 </li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>void InsertSort(vector&lt;int&gt; v) {

    for (int i = 1; i &lt; v.size(); ++i) {
        for (int j = 0; j &lt; i; ++j) {
            if (v[j] &gt; v[i]) {
                int t = v[i];
                for (int k = i; k &gt; j; --k) {
                    v[k] = v[k - 1];
                }
                v[j] = t;
            }
        }
    }
}
</code></pre><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h2><p>希尔排序又称缩小增量排序，也属于一种插入排序算法，其基本思想是将要被排序的数列分成若干个子序列然后分别进行插入排序，待这些子序列排序完成后大序列就会基本有序，这时再对整个大序列进行一次直接插入排序；<br>其分散数列的原则一般是5-3-1，即先将大数列每隔5个取一个数，这样最终会形成5个子数列，将这5个子数列分别进行插入排序，然后将排序好的数列每隔3个取一个形成3个子数列，再对这三个子数列进行三次插入排序，最后，对整个基本有序的大数列进行一次插入排序达到排序整个数列的目的。</p>
<h2 id="时间空间复杂度即稳定性"><a href="#时间空间复杂度即稳定性" class="headerlink" title="时间空间复杂度即稳定性"></a>时间空间复杂度即稳定性</h2><ul>
<li>T(n)=O(n^1.5) </li>
<li>S(n)=O(1) </li>
<li>不稳定 </li>
</ul>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre><code>void ShellSort(vector&lt;int&gt; v) {
    int d[3] = {5, 3, 1};
    for (int i = 0; i &lt; 3; ++i) {
        ShellInsert(v, d[i]);
    }
    show(v);
}


void ShellInsert(vector&lt;int&gt; &amp;v, int d) {
    for (int l = 0; l &lt; d; ++l) {
        for (int i = l + 1; i &lt; v.size(); i += d) {
            for (int j = l; j &lt; i; j += d) {
                if (v[i] &lt; v[j]) {
                   int t=v[i];
                   for(int k=i;k&gt;j;i-=d){
                      v[k]=v[k-d];
                      }
                    v[j]=t;
                }
            }
        }
    }
}
</code></pre><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h2><p>冒泡排序的主要思想是将大的数向下“沉”，将小的数向上“气泡”，具体过程：<br>首先将第一个数与第二个数进行对比，若第二个数小于第一个数，则将第一个数与第二个数交换，然后比较第二个数和第三个数，如果第二个数大于第三个数，则将其对换，最后的结果是将数列中最大的一个数换到数列的最后一位。<br>然后再对前n-1个数进行相同的过程，结果是将倒数第二大的数放在倒数第二位。<br>以此类推，经历n-1次后所有数列将会有序。</p>
<h2 id="时间空间复杂度及稳定性-1"><a href="#时间空间复杂度及稳定性-1" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(n^2) </li>
<li>S(n)=O(1) </li>
<li>稳定 </li>
</ul>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre><code>void BubbleSort(vector&lt;int&gt; v) {

    for (int i = 0; i &lt; v.size(); ++i) {
        int flag = 1;
        for (int j = 0; j &lt; v.size() - i &amp;&amp; j &lt; v.size() - 1; ++j) {
            if (v[j] &gt; v[j + 1]) {
                int t;
                t = v[j];
                v[j] = v[j + 1];
                v[j + 1] = t;
                flag = 0;
            }
        }

        if (flag == 1) {//说明已经有序了
            break;
        }


    show(v);
}
</code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><p>快速排序是对冒泡排序的一种改进，其基本思路是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h2 id="时间空间复杂度及稳定性-2"><a href="#时间空间复杂度及稳定性-2" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(nlog2-&gt;n) </li>
<li>S(n)=O(log2-&gt;n) </li>
<li>不稳定 </li>
</ul>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre><code>void QuickSort(vector&lt;int&gt; v) {
    QSort(v, 0, v.size() - 1);
    show(v);
}

void QSort(vector&lt;int&gt; &amp;v, int low, int high) {

    if (low &gt;= high) {
        return;
    }
    int t = Partition(v, low, high);
    QSort(v, low, t - 1);
    QSort(v, t + 1, high);
}

int Partition(vector&lt;int&gt; &amp;v, int low, int high) {
    int pivotkey;
    pivotkey = v[low];

    while (low &lt; high) {
        while (low &lt; high &amp;&amp; v[high] &gt;= pivotkey) {
            --high;
        }
        int t;
        t = v[low];
        v[low] = v[high];
        v[high] = t;

        while (low &lt; high &amp;&amp; v[low] &lt;= pivotkey) {
            ++low;
        }
        t = v[low];
        v[low] = v[high];
        v[high] = t;
    }

    return low;
}
</code></pre><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><p>选择排序的思路是首先找到序列中的最小数，将其放在第一位，然后找到第二小的数将其放在第二位，以此类推，最终将所有第i小的数放在第i位从而达到排序目的。</p>
<h2 id="时间空间复杂度及稳定性-3"><a href="#时间空间复杂度及稳定性-3" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>S(n)=O(1) </li>
<li>T(n)=O(n^2) </li>
<li>不稳定 </li>
</ul>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre><code>void SelectSort(vector&lt;int&gt; v) {
    for (int i = 0; i &lt; v.size(); ++i) {
        int min;
        min = i;
        for (int j = i + 1; j &lt; v.size(); ++j) {
            if (v[j] &lt; v[min]) {
                min = j;
            }
        }
        int t;
        t = v[min];
        v[min] = v[i];
        v[i] = t;
    }
    show(v);
}
</code></pre><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><p>堆排序的主要思路是先将所要排序的数列看做是一颗完全二叉树并建立大顶堆，然后将堆顶元素放在堆的最后一位，然后再调整该二叉树为大顶堆，然后再将堆顶放在二叉树的最后一位，调整二叉树为大顶堆，重复这一过程直至完成排序。</p>
<h2 id="时间空间复杂度及稳定性-4"><a href="#时间空间复杂度及稳定性-4" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(nlog2–&gt;n) </li>
<li>S(n)=O(1) </li>
<li>不稳定 </li>
</ul>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre><code>void HeapSort(vector&lt;int&gt; v) {

    int size = v.size();
    v.push_back(0);
    for (int k = v.size(); k &gt; 0; --k) {
        v[k] = v[k - 1];
    }
    //建堆
    for (int i = size / 2; i &gt; 0; --i) {
        HeapAdjust(v, i, size);
    }

    for (int j = size; j &gt; 1; --j) {
        int t;
        t = v[1];
        v[1] = v[j];
        v[j] = t;
        HeapAdjust(v, 1, j - 1);
    }
    for (int i = 1; i &lt; v.size(); ++i) {
        cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

void HeapAdjust(vector&lt;int&gt; &amp;v, int s, int m) {
    /*
     * 已知v[s..m]除v[s]之外均满足堆的定义，本函数调整v[s]，使得v[s..m]成为一个小顶堆
     */

    int rc;
    rc = v[s];
    for (int i = 2 * s; i &lt;= m; i = 2 * i) {
        if (i &lt; m &amp;&amp; v[i] &lt; v[i + 1]) {
            i++;//i为较大数据的下标
        }
        if (rc &gt;= v[i]) {
            break;
        }

        v[s] = v[i];
        s = i;
    }
    v[s] = rc;
}
</code></pre><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><p>归并排序的主要思路是将索要排序数列看做若干个有序的小数列，因为将两个有序数列合并之后所得数列还是有序数列，所以经过不断合并，最后可将数列排为有序。</p>
<h2 id="时间空间复杂度及稳定性-5"><a href="#时间空间复杂度及稳定性-5" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(nlog2–&gt;n) </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre><code>void MSort(vector&lt;int&gt; v) {


    vector&lt;int&gt; h;
    h = v;

    int start, seg;


    for (seg = 1; seg &lt; v.size(); seg *= 2) {
        int k = 0;
        for (start = 0; start &lt; v.size(); start = start + seg * 2) {
            int end;
            end = start + seg;
            int low = start;
            while (low &lt; start + seg &amp;&amp; end &lt; start + seg + seg &amp;&amp; low &lt; v.size() &amp;&amp; end &lt; v.size()) {
                if (v[low] &lt;= v[end]) {
                    h[k++] = v[low];
                    low++;
                } else {
                    h[k++] = v[end];
                    end++;
                }
            }

            while (low &lt; start + seg &amp;&amp; low &lt; v.size()) {
                h[k++] = v[low++];
            }
            while (end &lt; start + seg + seg &amp;&amp; end &lt; v.size()) {
                h[k++] = v[end++];
            }

        }

        v = h;
    }
    show(v);

}
</code></pre><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h2><p>基数排序需要经历d次，d为所要排序数列中位数最多的数的位数，其过程是首先根据数列中数的个位的数值将所有数入0~9这10个队列，然后从0~9将元素依次出队，然后再根据十位元素的数值再次入队，然后出队，以此类推重复d次，最终即可完成排序。</p>
<h2 id="时间空间复杂度及稳定性-6"><a href="#时间空间复杂度及稳定性-6" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(d*n) d为排序数中最大数的位数 </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre><code>void radixSort(vector&lt;int&gt; v) {

    int d = GetMaxBit(v);

    int *count = new int[10];
    queue&lt;int&gt; q[10];

    int radix = 1;
    for (int i = 0; i &lt; d; ++i) {
        for (int j = 0; j &lt; v.size(); ++j) {
            int t;
            t = (v[j] / radix) % 10;
            q[t].push(v[j]);
        }

        int p = 0;
        for (int k = 0; k &lt; 10; ++k) {
            while (!q[k].empty()) {
                v[p++] = q[k].front();
                q[k].pop();
            }
        }
        radix *= 10;
    }
    show(v);

}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/12/19/将非图片数据转化为caffe可用的LMDB的方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/19/将非图片数据转化为caffe可用的LMDB的方法/" itemprop="url">将非图片数据转化为caffe可用的LMDB的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-19T17:37:35+08:00">
                2017-12-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>摘要：最近有需求要使用caffe训练一套文本文件的数据，数据格式是若干个txt文件，每个txt文件里面包含了880个浮点型数据，因为之前一直用caffe进行图片的相关训练，直接使用caffe自带的脚本将图片转化为LMDB即可作为数据源，但是没有遇到过将txt中的文本数字转化为LMDB的情况，查了很多资料终于解决，记录下来希望可以帮助到有需要的同学们。<br>本文不讲原理，直接给大家一份转换的相关代码，请大家静下心来阅读一遍代码相信就可以搞懂，然后举一反三解决自己的问题。想要了解详细原理的同学可参考： <a href="http://blog.csdn.net/haluoluo211/article/details/54427421" target="_blank" rel="noopener"><br>http://blog.csdn.net/haluoluo211/article/details/54427421
</a></p>
<pre><code># -*-coding:utf-8-*-
import numpy as np
import random

import lmdb
import caffe
import os


def load_data(fileI, fileQ):
    # dadai和dataq是（8,110）的二维数组，这是我的数据，可以理解为一张图片的两个通道
    datai = np.loadtxt(fileI)
    dataq = np.loadtxt(fileQ)


    datai=datai.reshape(8,110)
    dataq=dataq.reshape(8,110)

    data = np.zeros((2, 8, 110))  # 初始化data，需要注意的是如果数据是1×n维的也需要np.zeros((2,1,110))初始化而不是np.zeros((2,110))
    data[0] = datai
    data[1] = dataq
    datum = caffe.proto.caffe_pb2.Datum()
    datum.channels = 2  # 设置channels，因为我的数据是I和Q相当于一张图片的两个通道，即我的“图片”有两个通道，所以这里设置为2
    datum.height = 8  # 设置height，表示数据矩阵的高
    datum.width = 110  # 设置width，表示数据矩阵的宽
    a=data.tostring()
    datum.data = a # data

    #因为我的label隐含在txt文件的文件名里，所以这里根据txt文件的名字来给数据设置label，你也可以根据你的情况导入label
    if fileI[4]==&apos;B&apos;:
        datum.label = int(0)  # label
    else:
        datum.label = int(1)  # label

    str_id = fileI[:-4]  #顺序+图片名字作为key，你可以根据你的想法设置key
    final_data = {&quot;datum&quot;: datum, &quot;key&quot;: str_id}
    return final_data


def get_lmdb(lmdb_name):
    num=0
    env = lmdb.open(lmdb_name,map_size=int(1e9))  # 打开lmdb，这里可以不设置map_size，但是根据经验建议大家设置上，而且不要设置的太小
    #path1和path2分别代表我的I.txt和Q.txt文件的来源（我的一份数据是一个I.txt和一个Q.txt，可以理解为一张图片的两个通道）
    path1 = &quot;/home/dmrf/Data/I_TEST&quot;
    path2 = &quot;/home/dmrf/Data/Q_TEST&quot;
    files1=os.listdir(path1)
    files2=os.listdir(path2)


    f1=[]
    f2=[]
    for a in files1:
        for b in files2:
            if a[8:]==b[8:]:
                f1.append(a)
                f2.append(b)
                files2.remove(b)
            else:continue



    random.shuffle(zip(f1,f2))

    for (file1, file2) in zip(f1,f2):
        if file1[8:]==file2[8:]:
            dataget = load_data(path1+&quot;/&quot;+file1, path2+&quot;/&quot;+file2)
            if dataget!=0:
                datum = dataget[&quot;datum&quot;]
                key = dataget[&quot;key&quot;]
                with env.begin(write=True) as txn:
                    txn.put(key, datum.SerializeToString())
                    num=num+1
                    print(&quot;转换中：&quot;+str(num))



    print(&quot;success:&quot;+str(num))

#函数入口
get_lmdb(&quot;test_lmdb&quot;)
</code></pre><p>以上就是大概原理，其实很简单，希望可以帮助到大家。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/12/05/谷歌企业文化建设分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/05/谷歌企业文化建设分析/" itemprop="url">谷歌企业文化建设分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T17:09:35+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>“一百英尺之内必有食物”这大概是谷歌最具特色的一句标语。<br>在一个倡导着工作就是生活的自由环境下，谷歌公司的工作人员不断用他们的创造力研发出一个又一个优质的产品。而 Google<br>强劲的发展势头与其独特的企业文化有着密不可分的关系。怎样的企业，怎样的文化特色，怎样用文化影响每一个公司员工，怎样利用这样的企业文化，这是一个不容忽视的话题。</p>
<h2 id="企业文化概述"><a href="#企业文化概述" class="headerlink" title="企业文化概述"></a>企业文化概述</h2><p>美国学者伦斯·米勒在 《美国文化精神》 中说道：“企业唯有发展出一种文化，这种文化能够在激励中获得成功的一切行为，这样公司才能 在竞争中获得成功<br>。”这就是企业文化。关于企业文化的概念, 国内外学者有许多不同的认识和表述。有人曾对企业文化的定义作过统计, 共有 180 多种,<br>几乎每一个管理学家和企业文化学家都有自己的定义。中国社会科学院工业研究所研究员韩朗岚认为：“企业文化有广义和狭义两种理解。广义的企业文化是指企业所创造的具有自身特点的物质文化和精神文化;<br>狭义的企业文化是企业所形成的具有自身个性、经营宗旨、<br>价值观念和道德行为准则的综合”。从这里可以看出，企业文化是企业价值取向、经营理念、管理制度、行为准则、企业精神等方面的概括与升华。企业文化的结构有三个层次，实体的物质题。<br>文化构成企业文化的硬件外壳，制度文化是观念 形态的转化，是企业硬外壳的支撑，而精神文化是企业文化的精髓，主导着企业的共性和特性及企业的发展范式。<br>企业文化的重要性毋庸置疑，表现为以下几个方面：</p>
<h3 id="企业文化本身就是一种企业竞争力"><a href="#企业文化本身就是一种企业竞争力" class="headerlink" title="企业文化本身就是一种企业竞争力"></a>企业文化本身就是一种企业竞争力</h3><p>优质的企业文化更能够促使企业提供满足消费者需求的产品与服务。马斯洛的需求层次理论告诉我们，人的需要可分为五个层次：生理需要、安全需要、社交需要、尊重需要、自我实现需要。当低的需要得到基本满足时，下一个更高层次的需要就将成为主导需要，而随着科技的进步、社会的发展，人们的生活越来越富裕，人们的需要逐渐从低层次的需要转变为高层次的需要，低层次的需求不再有激励作用，这时，消费者更强调一种文化（消费文化），更加追求个性，时尚，前卫，张扬，而带有这些特质的产品往往产生于优质的文化底蕴。所以说，优质的独具特色的企业文化更加能抓住顾客的心，从而在激烈的竞争中崭露头角。</p>
<h3 id="企业文化能有效的调节人与人之间的关系，规范和约束人的行为"><a href="#企业文化能有效的调节人与人之间的关系，规范和约束人的行为" class="headerlink" title="企业文化能有效的调节人与人之间的关系，规范和约束人的行为"></a>企业文化能有效的调节人与人之间的关系，规范和约束人的行为</h3><p>通过文化建设，发挥文化的功能，来推动和促进企业发展。近些年来日益受到管理界的重视、最终升华出的一种新的管理理论和方法——人本管理，就是坚持以人为本，重视员工的精神需求，满足其社交需要和自我实现需要，提高员工的凝聚力和适应力，对企业的发展与建设起到了重要的指导作用。可见，构建高层次的、具有深刻影响力的企业文化，能够提高企业管理的水平，满足人的多层次、多重性的需要，也有利于社会文化的发展。</p>
<h3 id="企业文化具有难以被模仿和复制的独特性"><a href="#企业文化具有难以被模仿和复制的独特性" class="headerlink" title="企业文化具有难以被模仿和复制的独特性"></a>企业文化具有难以被模仿和复制的独特性</h3><p>我们知道企业要在竞争中长期占有优势, 必须具有核心竞争力。核心竞争力是指企业在研发、 制造、 设计、 营销、<br>服务等一个或几个环节上具有竞争对手难以模仿的明显的优势,<br>并能够满足客户价值需求的独特能力。然而在信息，科学技术高速发展的今天，以上几点很难保证竞争对手难以模仿，甚至可能会被迎头赶上，优势往往很难持续下去。但企业文化不一样，每一个企业都有着自己的定位、独特环境，发展方向，优势劣势、经营模式、文化传统，很难保证这些因素全部吻合。并且，从克拉克洪-<br>斯托克柏克提出的文化差异分析模型——K-S框架，我们可以知道，与环境的关系、时间取向、对人的本质的看法、活动取向、责任中心、空间取向的不同将会导致企业文化的差异。加之，企业文化既没有固定的模式，也没有定量的指标，导致企业文化很难模仿，可以说，企业文化是一个公司的独特标志，是支撑企业发展的重要力量。<br>第四，<br>企业文化有助于企业向学习型组织发展。现代企业正处在不断变化的社会环境中，市场竞争不断加强，规模扩大，市场不断扩展，一个企业只有通过不断的学习，并根据实际情况做出产品、技术、制度的变革，才能适应不断发展的时代潮流。美国原通用电器<br>CEO<br>韦尔奇说:“最终的竞争优势在于一个企业的学习能力以及将其迅速转化的能力。”没有学习，没有变革的企业将很快失去竞争优势。所以，一个学习氛围浓厚，员工积极进取，敢于不断改变自己的企业才能够不断发展。<br>优秀的企业文化鼓励个人学习、 自我超越, 注重团队精神的培养和建立共同的愿望, 所以有助于企业向学习型组织发展。</p>
<h2 id="谷歌的企业文化"><a href="#谷歌的企业文化" class="headerlink" title="谷歌的企业文化"></a>谷歌的企业文化</h2><p>谷歌（英语：Google<br>Inc.，NASDAQ：GOOG、FWB：GGQ1，官方中文译名为谷歌），是一家美国的跨国科技企业，致力于互联网搜索、云计算、广告技术等领域，开发并提供大量基于互联网的产品与服务，其主要利润来自于AdWords等广告服务。李开复说，和Google“恋爱”，他感受到这家公司的文化是：一群穿着短裤的年轻人，对新技术创新有极大的热情；对诚信的追求近乎执著；员工之间关系平等、自由和透明；先让客户满意，暂时不赚钱也没关系。2014年5月21日，市场研究公司明略行（Millward<br>Brown）公布，谷歌取代苹果成为全球最具价值的商业品牌，这与谷歌优质的，富有个性的企业文化密不可分。下面从企业文化的三个层次来介绍谷歌的企业文化。</p>
<h3 id="谷歌的物质文化"><a href="#谷歌的物质文化" class="headerlink" title="谷歌的物质文化"></a>谷歌的物质文化</h3><p>谷歌为员工提供了便利的服务和人性化的工作环境。</p>
<h4 id="“免费：”文化"><a href="#“免费：”文化" class="headerlink" title="“免费：”文化"></a>“免费：”文化</h4><p>在谷歌，“免费”被当作公司文化的一部分。员工用餐、健身、按摩、洗衣、洗澡、看病都100%免费；每层楼都有一个咖啡厅，可以随时冲咖啡、吃点心，大冰箱里有各种饮料，免费任喝。</p>
<h4 id="办公环境宽松便捷"><a href="#办公环境宽松便捷" class="headerlink" title="办公环境宽松便捷"></a>办公环境宽松便捷</h4><p>每位员工至少配备两台大屏幕显示器，平均每个办公室有4-6名员工，并且技术人员24小时待命，计算机或其他数码产品可以随时送修。办公大楼随处可见白色书写板，目的是方便员工随时记下各种新创意。一位Google产品经理对此表示：“你坐在办公室时，灵感并不一定会来；或许就在你走动时，灵感就会如期而至。”</p>
<h4 id="娱乐设施完备"><a href="#娱乐设施完备" class="headerlink" title="娱乐设施完备"></a>娱乐设施完备</h4><p>公司内，到处都有排球场，游泳池，台球室，甚至还配备有专门的按摩师。谷歌就像是一个游乐园，帮助员工迅速消除疲劳，回归工作状态。</p>
<h4 id="完善的福利"><a href="#完善的福利" class="headerlink" title="完善的福利"></a>完善的福利</h4><p>谷歌的花钱速度在硅谷堪称奇迹，对于员工，谷歌有着完善的福利，谷歌总部餐厅、美容院、牙医院、加油站、甚至按摩店应有尽有，俨然一个自给自足的独立王国。免费美食、24小时健身房、瑜伽课、演讲课、医疗服务、营养师、干洗机、按摩服务、私人教练、温泉水疗，上下班接送，外语培训„„应有尽有。</p>
<h3 id="谷歌的制度文化"><a href="#谷歌的制度文化" class="headerlink" title="谷歌的制度文化"></a>谷歌的制度文化</h3><h4 id="管理制度"><a href="#管理制度" class="headerlink" title="管理制度"></a>管理制度</h4><h5 id="人员招聘制度"><a href="#人员招聘制度" class="headerlink" title="人员招聘制度"></a>人员招聘制度</h5><p>“宁缺毋滥”是谷歌管理人才的一个重要理念。有资料显示，最终获得谷歌工作职位的应聘者平均需要通过6.2次面试，参与面试的面试官，除了人力资源部和岗位需求部门，也会邀请跨部门甚至跨区域的人参加面试，这是为了是进入谷歌的员工尽量契合谷歌的企业文化。谷歌非常鼓励内部员工推荐应聘者，因为他们对于公司文化更加了解，其推荐的人更加适应公司文化。</p>
<h5 id="绩效管理"><a href="#绩效管理" class="headerlink" title="绩效管理"></a>绩效管理</h5><p>谷歌有着一套十分精密严谨、完全数值化的内部目标绩效考核制度——OKR，所有员工的考核评分对内公开，这种目标考核也成为各部门任务协作的一个手段。<br>OKR全称“目标与关键成果”，是一套定义与跟踪目标及其完成情况的管理工具和具体方法，适用于公司、团队与个人，是一种简便易行的绩效考评方式。谷歌通过在公司层面设立目标，并在团队、管理人、普通员工层面均设立明确的，具体可行的目标，这与目标管理法基本契合，在每个季度末期，谷歌将会对OKR考核实施评分，评分过低，高分并不一定受到表扬，如果本期目标制定野心不够，下期OKR制定则需要调整。低分也不会受到指责，而是通过分析工作数据，找到下一季度OKR的改进办法。<br>企业的生死要么是方向的问题（战略和目标）要么是行动的问题，行动不能支撑目标的实现，这样的行动是在“杀害”这个公司，因为这样浪费人力、物力、财力，甚至有可能抵消、阻碍甚至破坏其他人的正确行动。OKR的特点是简单、直接、透明。OKR的优点主要有三点：<br>第一，谷歌依赖于创新、创意、创造，没有可跟随的目标和方向，需要企业自己探索，自下而上的OKR则更能激发员工的创造力，通过设定目标并采取措施并最终达成目标的这个过程让员工感受到了创造性努力的激情和乐趣，满足了员工的自我实现需要。<br>第二，OKR的实施对象是公司的每一个成员，每一个员工都能把握公司的动态和自己<br>所处的位置，并通过与其他员工的对比，了解自己的优势劣势，并做出改变，提升自身素质。<br>第三，让每一个员工都清楚的明白自己是公司的一个不可或缺的一部分，增加其对公司的归属感。</p>
<h5 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h5><p>谷歌的员工从来不用在乎早上闹铃会不会准时响起，员工可以悠闲自得地去上班。谷歌提倡弹性的工作制度，充分相信员工，把工作时间的掌控权交给员工，由员工根据自己的喜好自由安排时间，给员工提供了宽松、自由的环境。从组织文化理论的角度来分析，由于谷歌公司的核心在于不断推出新的产品来获利，因此给员工一个不压抑、不拘束的环境就显得非常重要。</p>
<h4 id="工作制度"><a href="#工作制度" class="headerlink" title="工作制度"></a>工作制度</h4><p>灵活高效的工作方式成为谷歌持续高速发展的秘诀之一。创新的意识还源自于灵活的小团 队工作方式<br>。“将有智慧有激情的员工针对关键问题，分成3～5人的小团队，扁平化的组织，以海量的计算资源和数据作为支持，同时允许工程师抽出20%的时间，根据兴趣自己确定研究方向。”这是谷歌组织结构的基本原则。小团队的工作方式看起来平常，其实却蕴涵着深刻的道理：在庞大的组织中，总有很多聪明人，他们可以轻松地找到“混”下去的方法，即便是复杂的绩效考核也对这类人束手无策。但是在有3～5人组成的小团队中，却容不得“聪明人”再浑水摸鱼，必须全力以赴才能被大家认可。激发了全体成员创造力的同时，进行小3.薪酬制度<br>薪酬制度是人力资源管理的主要职能之一，“激励是管理的核心”，而薪酬激励又是企业目前普遍采用的且行之有效的一种激励方式。<br>谷歌推出以绩效为导向的富有竞争力的全面薪酬：谷歌的全面薪酬包括工资、津贴、奖金、福利、保险、股票期权等。在对员工的短期、期、和长期激励上，各自发挥着不同的作用。对外，谷歌整体薪酬保持着市场上的强大竞争力；对内充分考虑不同岗位，职级以及员工工作表现的差异性，建立了全方位的以业绩为导向的薪资理念。范围的绩效考核，所得的结论就会更加客观。<br>谷歌为所有正式员工发放股票期权，并且每年都会根据员工上一年度的业绩表现再授予股票期权。业绩表现越好的员工，越得到更高的工资、奖金和股票期权，从而保障员工的收入与绩效充分接轨。</p>
<h3 id="谷歌的精神文化"><a href="#谷歌的精神文化" class="headerlink" title="谷歌的精神文化"></a>谷歌的精神文化</h3><p>按照索涅费尔德的分类，组织文化可被划分 为学院式文化、俱乐部式文化、棒球队式文化和堡垒式文化四个类别。学院式文化适合那些追求<br>稳定性的人群。同时用人单位并不介意雇员是刚刚毕业的学生。而俱乐部式文化与其相对，这样的组织很重视经验年龄和资历，军队和政府机关多是俱乐部式文化的典型。堡垒式文化更多的是强调维持生存，因此这种组织文化尤其适合于经济不景气的大环境。棒球队式的文化也正如其名，它提倡冒险创新，组织往往给员工充分的自由。那么按照索涅费尔德的分类，谷歌公司就应属于棒球队式的文化。我认为，谷歌的精神文化主要分为以下四个方面：</p>
<h4 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h4><p>作为一个要求不断推出新产品的公司，谷歌的创新精神可以说是企业精神的重中之重。</p>
<h5 id="谷歌将创新列入员工的工作时间预算"><a href="#谷歌将创新列入员工的工作时间预算" class="headerlink" title="谷歌将创新列入员工的工作时间预算"></a>谷歌将创新列入员工的工作时间预算</h5><p>要求技术人员花80%的时间在核心的搜索和广告业务上，其余20%则用在他们自己选择的技术项目上，每位工程师都有 20%<br>的自由支配时间，这些时间允许工程师不紧紧抓着核心项目不放。他们可以将这部分时间投入他们所感兴趣的课题上进行研究，正是这种鼓励创新的机制使得谷歌新产品的推出速度非常快。</p>
<h5 id="善于利用失败"><a href="#善于利用失败" class="headerlink" title="善于利用失败"></a>善于利用失败</h5><p>谷歌快速地推出大量创新产品，这些产品可能并不完美，但谷歌会让市场来选择。谷歌创始人佩奇还曾表扬一名犯下大错、给公司造成数百万美元损失的高管：“我很高兴你犯了这个错误。因为我希望公司能够行动迅速、做很多很多的事情，而不是谨小慎微、什么也不敢做。”</p>
<h5 id="用数据支持灵感"><a href="#用数据支持灵感" class="headerlink" title="用数据支持灵感"></a>用数据支持灵感</h5><p>人们普遍认为，创意的构思过程是混乱无序的，但谷歌却以一套非常严谨的以数据为驱动的创意评估流程，很好地平衡了这种无序性。谷歌对于分析和数据的重视远远超过其他绝大多数公司。它的搜索引擎一样快。</p>
<h4 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h4><p>办公区沙发随处可见，员工可以随意喝咖啡聊天，甚至分不清哪里是办公区，哪里是休闲区。“我们的每间办公室都有独特的名字，比如‘立秋’‘秋分’，这都是我们员工自己的创意。谷歌的工作模式就是平等和倾听每一位员工的声音，我喜欢这样无为而治的文化。”李开复说。这就是谷歌独具特色的文化。并且，20%的自由分配时间并不是强制的，谷歌给了员工充分的自由来分配这段时间李开复说“其实，自由时间比例多少并不重要。谷歌20％自由时间制度的背后，有一个更重要的原则，我们信任员工。我们放权给员工，并不会真的去衡量这个20％，我们觉得员工会自行调整。打个比方，如果员工觉得自己正在做的某个程序非常重要，那么，这个月他可以只做这个程序；如果员工觉得公司交给他的任务更重要，那么，他可能花三个月来做，而根本不会去碰这个20％。你可以质疑，也许这个制度的回报只有10％，也有可能是20％，甚至是30％，这个我没有办法做出确切的回答。但是，我们不能用数字来进行衡量，这个制度所代表的，是公司的一种自由的风气，这种风气也是吸引人的一种途径。”自由来源于公司对员工的充分信任，这种信任在其他公司是极为少见的。</p>
<h4 id="个人主义"><a href="#个人主义" class="headerlink" title="个人主义"></a>个人主义</h4><p>美国前总统肯尼迪曾经说道：“如果价值是文化的灵魂，那么英雄就是这些价值的化身和组<br>织机构力量的集中体现。”信奉个人主义以及塑造英雄，是谷歌企业文化的“中流砥柱”。这一方面给企业内部员工提供学习的榜样，树立绩效的标准，刺激员工积极进取，相互竞争；另一方面，也可以对外作为公司的象征，成为公司的形象代表。美国企业文化注重个人英雄的巨大影响力，为了争夺本土化人才，往往不惜重金。李开复在2005年7月19日突然宣布跳槽谷歌，出任其中国区总裁，负责中国研发中心的运营。微软当日就向华盛顿州地方法院提起诉讼，指控谷歌和李开复违反了“同业禁止”协议。9月14日，位于西雅图市的华盛顿州金县法院做出初步裁决，允许李开复任职谷歌中国研发中心，但对其工作内容进行了限定。李开复对于中国的年轻学子有着巨大的号召力，为了能抢到中意的人才，谷歌不惜和I<br>T巨头微软诉诸法律，其对个人英雄的重视可见一斑。</p>
<h4 id="使命感"><a href="#使命感" class="headerlink" title="使命感"></a>使命感</h4><p>谷歌的每个人都有强烈的使命感和目标感，他们相信自己的工作能以积极的方式影响着千百万人。 谷歌有两条口号：“完美的搜索引擎”和“不作恶”。第一条口号<br>“完美的搜索引擎”更多侧重于增强其产品的可信性和专业性，而第二条口号则更多是在强调一种拒绝为了盈利而不择手段的企业风气。谷歌有着他的使命，谷歌的使命就是整合全球的信息，做一个最公正、最完美的搜索引擎。谷歌的这宏大的使命深深地烙在每个员工的心里，<br>谷歌的使命就是他们的责任，并是他们与公司同气连枝，并促使他们自信满满，大刀阔斧的前进。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过以谷歌公司为例，我们知道了企业文化<br>是企业的核心竞争力，使企业经久不衰的动力来源。完善企业制度，建立以人为本的企业文化，并随着时代潮流不断完善和发展，互相借鉴与补充，<br>是每个企业不可忽视的重要内容</p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>《浅谈谷歌的企业文化》金志峰</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/12/01/人工智能是否会超越人类？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/01/人工智能是否会超越人类？/" itemprop="url">人工智能是否会超越人类？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-01T20:22:15+08:00">
                2017-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>导语：随着人工智能的飞速发展，很多人都在担忧人工智能是否会超越人类、甚至毁灭人类，比如像特斯拉的CEO埃隆.马斯克认为也许只有人看到人工智能在街上杀人的时候，才会意识到这个问题的严重性。很多人对这个问题都有自己的答案，但是他们的答案也许只是因为他们的直觉，而真正的原因恐怕连他们自己也不清楚，比如有的人可能会说因为自己觉得未来人工智能会有自主学习的能力，所以人工智能会超越人类，而另一类人也许会说因为人工智能也是由人制造的，所以不会超越人类。一般人这么思考问题也许不能算错，但是作为一名IT人，必须学会用工程的思维来思考问题，而不是靠自己的直觉，本篇文章就带大家了解一下吴军老师是如何用工程的思维论证这个问题的：</p>
<h2 id="图灵机是什么？"><a href="#图灵机是什么？" class="headerlink" title="图灵机是什么？"></a>图灵机是什么？</h2><p>图灵博士被认为是神一样的人。在20世纪，全世界智力水平可以和爱因斯坦平起平坐的人恐怕只有图灵和冯.诺依曼两个人了（而后者被认为的智力甚至超越了爱因斯坦）。在上个实际30年代中期，图灵在思考三个问题：</p>
<p><strong>1.世界上是否所有的数学问题都有明确的答案？</strong></p>
<p><strong>2.如果有明确答案，是否可以通过有限步骤的计算得到答案？</strong></p>
<p><strong>3.对于那些有可能在有限步骤计算出来的数学问题，能否有一种假想的机械，让它不断运动，最后当机械停下来的时候，那个数学问题就解决了？</strong></p>
<p>图灵思考问题的这个方法后人称之为图灵机，是一个数学模型。今天所有的计算机，包括全世界正在设计的计算机，从解决问题的能力来讲，都没有超出图灵机的范畴。</p>
<h2 id="人工智能的边界在哪里？"><a href="#人工智能的边界在哪里？" class="headerlink" title="人工智能的边界在哪里？"></a>人工智能的边界在哪里？</h2><p>解释完图灵机，我们可以回到最初的问题了，人工智能的边界在哪里？<br>其实给出图灵思考问题的答案就可以得到结论了：</p>
<p><strong>世界上有很多问题，其中只有一小部分是数学问题</strong></p>
<p><strong>在数学问题中，只有一小部分是有解的</strong></p>
<p><strong>在有解的问题中，只有一小部分是理想状态的图灵机可以解决的</strong></p>
<p><strong>在后一类问题中，又只有一部分是今天实际的计算机可以解决的</strong></p>
<p><strong>而人工智能可以解决的问题，又只是计算机可以解决问题的一部分</strong></p>
<p>吴军老师把这个问题画成了一张图：<br><img src="https://img-
blog.csdn.net/20171201201912129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>至此，我们应该可以得到问题的答案了：<br>人工智能所能解决的问题只是世界上的很小一部分。对于人工智能来讲，个人觉得现在世界没有解决的问题太多，无论是人还是机器（其实是背后编写程序的人），都应该想办法解决各种问题，而不是杞人忧天，担心人工智能这个工具太强大。</p>
<p>版权所有：【得到】APP订阅专栏：吴军的谷歌方法论</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/11/22/判断一棵二叉树是否是完全二叉树的方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/判断一棵二叉树是否是完全二叉树的方法/" itemprop="url">判断一棵二叉树是否是完全二叉树的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T23:38:00+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h1><p>利用二叉树层次遍历的原理开始对二叉树进行层次遍历，特殊点在于遍历的时候将NULL也入队作为标记，如果当遍历到NULL的时候队列中仍然后非NULL元素未被遍历，说明该二叉树中有非空点在空点的右边，即不是完全二叉树。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code>bool is_complete(BiTree biTree) {
    queue&lt;BiNode *&gt; q;
    BiNode *biNode;
    // 进行广度优先遍历（层次遍历），并把NULL节点也放入队列
    q.push(biTree);


    while ((biNode = q.front()) != NULL) {
        q.pop();
        q.push(biNode-&gt;lchild);
        q.push(biNode-&gt;rchild);
    }

    // 判断是否还有未被访问到的节点
    while (!q.empty()) {
        biNode = q.front();
        q.pop();

        // 有未访问到的的非NULL节点，则树存在空洞，为非完全二叉树
        if (NULL != biNode) {
            cout &lt;&lt; &quot;不是完全二叉树～&quot; &lt;&lt; endl;
            return false;
        }
    }
    cout &lt;&lt; &quot;是完全二叉树～&quot; &lt;&lt; endl;
    return true;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/11/22/数据结构之二叉树的遍历算法合集/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/数据结构之二叉树的遍历算法合集/" itemprop="url">数据结构之二叉树的遍历算法合集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T22:55:56+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>摘要：今天用C撸了一遍数据中二叉树常见操作的实现，将实现过程中感觉有意思的几个功能实现记录下来方便以后复习～</p>
<h1 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h1><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><pre><code>void PreOrderTraverse(BiTree biTree) {//先序遍历
    if (biTree == NULL) {
        cout &lt;&lt; &quot;该树为空，无法遍历！&quot; &lt;&lt; endl;
    }
    cout &lt;&lt; biTree-&gt;data &lt;&lt; &quot; &quot;;
    if (biTree-&gt;lchild != NULL) {
        PreOrderTraverse(biTree-&gt;lchild);
    }

    if (biTree-&gt;rchild != NULL) {
        PreOrderTraverse(biTree-&gt;rchild);
    }

}
</code></pre><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><pre><code>void PreOrderTraverse2(BiTree biTree) {//先序遍历
    stack&lt;BiNode *&gt; stack1;
    BiNode *biNode = biTree;

    stack1.push(biNode);


    while (biNode != NULL &amp;&amp; !stack1.empty()) {
        biNode = stack1.top();
        stack1.pop();
        cout &lt;&lt; biNode-&gt;data &lt;&lt; &quot; &quot;;

        if (biNode-&gt;rchild != NULL) {
            stack1.push(biNode-&gt;rchild);
        }

        if (biNode-&gt;lchild != NULL) {
            stack1.push(biNode-&gt;lchild);
        }
    }
}
</code></pre><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><h2 id="递归实现-1"><a href="#递归实现-1" class="headerlink" title="递归实现"></a>递归实现</h2><pre><code>void InOrderTraverse(BiTree biTree) {
    if (biTree == NULL) {
        cout &lt;&lt; &quot;该树为空，无法遍历！&quot; &lt;&lt; endl;
    }

    if (biTree-&gt;lchild != NULL) {
        InOrderTraverse(biTree-&gt;lchild);
    }
    cout &lt;&lt; biTree-&gt;data &lt;&lt; &quot; &quot;;
    if (biTree-&gt;rchild != NULL) {
        InOrderTraverse(biTree-&gt;rchild);
    }
}
</code></pre><h2 id="非递归实现-1"><a href="#非递归实现-1" class="headerlink" title="非递归实现"></a>非递归实现</h2><pre><code>void InOrderTraverse2(BiTree biTree) {
    if (biTree == NULL) {
        cout &lt;&lt; &quot;该树为空，无法遍历！&quot; &lt;&lt; endl;
    }

    stack&lt;BiNode *&gt; stack1;
    BiNode *biNode = biTree;

    while (biNode != NULL || !stack1.empty()) {
        if (biNode != NULL) {
            stack1.push(biNode);
            biNode = biNode-&gt;lchild;
        } else {
            biNode = stack1.top();
            stack1.pop();
            cout &lt;&lt; biNode-&gt;data &lt;&lt; &quot; &quot;;
            biNode = biNode-&gt;rchild;
        }
    }
}
</code></pre><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><h2 id="递归实现-2"><a href="#递归实现-2" class="headerlink" title="递归实现"></a>递归实现</h2><h3 id="二叉树Depth（）的实现"><a href="#二叉树Depth（）的实现" class="headerlink" title="二叉树Depth（）的实现"></a>二叉树Depth（）的实现</h3><pre><code>int Depth(BiTree biTree) {

    if (biTree == NULL) {
        return 0;
    }

    int u = Depth(biTree-&gt;lchild);
    int v = Depth(biTree-&gt;rchild);

    return u &gt; v ? u + 1 : v + 1;
}
</code></pre><h3 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h3><pre><code>void LevelOrderTraverse(BiTree biTree) {
    for (int i = 1; i &lt;= Depth(biTree); ++i) {
        LevelOrderTraversePrint(biTree, i);
    }
}

void LevelOrderTraversePrint(BiTree biTree, int depth) {
    if (biTree == NULL) {
        cout &lt;&lt; &quot;该树为空，无法遍历！&quot; &lt;&lt; endl;
    }
    if (depth == 1) {
        cout &lt;&lt; biTree-&gt;data &lt;&lt; &quot; &quot;;
        return;
    } else {
        if (biTree-&gt;lchild != NULL) {
            LevelOrderTraversePrint(biTree-&gt;lchild, depth - 1);
        }


        if (biTree-&gt;rchild != NULL) {
            LevelOrderTraversePrint(biTree-&gt;rchild, depth - 1);
        }
    }
}
</code></pre><h2 id="非递归实现-2"><a href="#非递归实现-2" class="headerlink" title="非递归实现"></a>非递归实现</h2><pre><code>void PreOrderTraverse2(BiTree biTree) {//先序遍历

    stack&lt;BiNode *&gt; stack1;
    BiNode *biNode = biTree;

    stack1.push(biNode);

    while (biNode != NULL &amp;&amp; !stack1.empty()) {
        biNode = stack1.top();
        stack1.pop();
        cout &lt;&lt; biNode-&gt;data &lt;&lt; &quot; &quot;;

        if (biNode-&gt;rchild != NULL) {
            stack1.push(biNode-&gt;rchild);
        }
        if (biNode-&gt;lchild != NULL) {
            stack1.push(biNode-&gt;lchild);
        }
    }
}
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遍历的时候使用非递归算法比采用递归算法的效率高效，但是同时非递归的算法实现比递归算法更难（除了层次遍历，个人觉得层次遍历的非递归实现反而比递归实现更简单）。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/11/22/南方某高校离散数学实验报告/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/22/南方某高校离散数学实验报告/" itemprop="url">南方某高校离散数学实验报告</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T22:42:48+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="实验一：专业论文阅读"><a href="#实验一：专业论文阅读" class="headerlink" title="实验一：专业论文阅读"></a>实验一：专业论文阅读</h2><h3 id="论文的基本信息"><a href="#论文的基本信息" class="headerlink" title="论文的基本信息"></a>论文的基本信息</h3><h4 id="论文题目与来源"><a href="#论文题目与来源" class="headerlink" title="论文题目与来源"></a>论文题目与来源</h4><p>论文的题目为“An Implementation of the Behavior Annex in the AADL-toolset<br>Osate2”，发表在2011年4月的Software Engineering Institute | Carnegie Mellon<br>University期刊（或会议录），引用格式为：Lasnier G, Pautet L, Hugues J, et al. An<br>Implementation of the Behavior Annex in the AADL-Toolset Osate2[C]// IEEE<br>International Conference on Engineering of Complex Computer Systems. IEEE,<br>2011:332-337.</p>
<h4 id="论文作者信息"><a href="#论文作者信息" class="headerlink" title="论文作者信息"></a>论文作者信息</h4><h5 id="论文的主要作者："><a href="#论文的主要作者：" class="headerlink" title="论文的主要作者："></a>论文的主要作者：</h5><p>Gilles Lasnier, Laurent PautetInst. TELECOM - TELECOM ParisTech – LTCI Paris,<br>F-75634 CEDEX 13, France Email: <a href="mailto:{firstname.lastname}@telecom-paristech.fr" target="_blank" rel="noopener">{firstname.lastname}@telecom-paristech.fr</a><br>Jérôme Hugues ISAE - Toulouse University Toulouse, 31056, France Email:<br><a href="mailto:jerome.hugues@isae.fr" target="_blank" rel="noopener">jerome.hugues@isae.fr</a><br>Lutz Wrage SEI - Carnegie Mellon University Pittsburgh, PA, 15213, USA Email:<br><a href="mailto:lwrage@sei.cmu.edu" target="_blank" rel="noopener">lwrage@sei.cmu.edu</a></p>
<h3 id="论文的主要内容"><a href="#论文的主要内容" class="headerlink" title="论文的主要内容"></a>论文的主要内容</h3><h4 id="论文摘要"><a href="#论文摘要" class="headerlink" title="论文摘要"></a>论文摘要</h4><h5 id="论文的研究背景："><a href="#论文的研究背景：" class="headerlink" title="论文的研究背景："></a>论文的研究背景：</h5><p>Abstract-AADL是一种用于设计和分析高分辨率分布式和实时系统的建模语言。 作为AADL的拓展分支，该建模语言扩展了AADL模型以加强其分析功能。<br>其指定了AADL应用程序模型的行为。 因此，本附件的植入允许执行行为分析。 另外，由于有几个AADL的拓展，实施通用机制来支持其中的每一个都是具有挑战性的。</p>
<h5 id="要解决的问题："><a href="#要解决的问题：" class="headerlink" title="要解决的问题："></a>要解决的问题：</h5><p>1）解析和分析几个AADL的子语言。<br>2）对不同的AST生产需要连接进行分析。<br>3）完成分析，要求确保与核心语言的一致性。</p>
<h5 id="主要采用的方法："><a href="#主要采用的方法：" class="headerlink" title="主要采用的方法："></a>主要采用的方法：</h5><p>开发了一个可扩展的开源平台AADL工具集OSATE2，它包括AADL前端，架构分析功能和扩展机制，将外部后端作为插件进行集成。</p>
<h5 id="得到的研究结果："><a href="#得到的研究结果：" class="headerlink" title="得到的研究结果："></a>得到的研究结果：</h5><p>通过重用多个OSATE2模块来驱动AADL-BA元素进而完成了对AADL模型的分析，开发出了新的编译器插件。</p>
<h3 id="论文主体内容"><a href="#论文主体内容" class="headerlink" title="论文主体内容"></a>论文主体内容</h3><h4 id="论文对问题的描述："><a href="#论文对问题的描述：" class="headerlink" title="论文对问题的描述："></a>论文对问题的描述：</h4><p>Abstract-AADL是一种用于设计和分析高分辨率分布式和实时系统的建模语言。<br>作为AADL附件出版的嵌入式子语言扩展了AADL模型以加强分析。但是，由于有几个AADL附件，实施通用机制来支持其中的每一个都是具有挑战性的。</p>
<h4 id="论文解决问题的步骤："><a href="#论文解决问题的步骤：" class="headerlink" title="论文解决问题的步骤："></a>论文解决问题的步骤：</h4><p>1：将AADLBA编译器作为集成；<br>2：实现OSATE2的ECLIPSE插件；<br>3：将AADL-BA元模型作为构建编译器的几个模块的骨干分支。</p>
<h4 id="论文结果的体现方式："><a href="#论文结果的体现方式：" class="headerlink" title="论文结果的体现方式："></a>论文结果的体现方式：</h4><p>通过展示了研究人员如何使用AADL-BA模型来开发编译器的几个模块来说明研究结果。<br>具体产品为OSATE2，这是一个提供了AADL前端和附件的插件，驱动行为附件分析（解析器+分析器）。用于定义AADL和AADL-<br>BA元模型的相同技术，可轻松跨两个元模型的导航，以及生成独特的持久XMI表示（AADL模型+行为元素），有助于将其用作外部后台的输入。<br>论文的创新点：<br>通过以一个可拓展的开源平台AADL工具集OSATE2为基础，将前后端结合起来对问题进行研究和实验，而不是局限于传统的分析方法。</p>
<h4 id="相关工作和展望"><a href="#相关工作和展望" class="headerlink" title="相关工作和展望"></a>相关工作和展望</h4><h5 id="论文的相关工作："><a href="#论文的相关工作：" class="headerlink" title="论文的相关工作："></a>论文的相关工作：</h5><p>为了研究的需要开发了一个可扩展的开源平台AADL工具集OSATE2，它包括AADL前端，架构分析功能和扩展机制，将外部后端作为插件进行集成。</p>
<h5 id="下一步工作："><a href="#下一步工作：" class="headerlink" title="下一步工作："></a>下一步工作：</h5><p>通过外部后端的集成来分析行为自动机属性，例如作为模型检查器来验证死锁和基于模型的工具，以通过改进WCET估计和阻止共享资源的时间来增强调度分析。</p>
<h2 id="实验二：构造命题逻辑合式公式的真值表"><a href="#实验二：构造命题逻辑合式公式的真值表" class="headerlink" title="实验二：构造命题逻辑合式公式的真值表"></a>实验二：构造命题逻辑合式公式的真值表</h2><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>根据用户输入的命题公式以及指定的分量的真值得出对应命题公式的真假值。</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑环境"><a href="#电脑环境" class="headerlink" title="电脑环境"></a>电脑环境</h4><p>系统：Ubuntu16.04LTS（Linux 4.10.0-37-generic x86_64）<br>处理器：Intel® Pentium(R) CPU N3700 @ 1.60GHz × 4<br>内存：7.7 GiB<br>操作系统类型：64位操作系统<br>图形：GeForce 920M/PCIe/SSE2</p>
<h4 id="编译运行环境"><a href="#编译运行环境" class="headerlink" title="编译运行环境"></a>编译运行环境</h4><p>CLion2017.2.3</p>
<h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><p>C/C++语言</p>
<h3 id="实验算法"><a href="#实验算法" class="headerlink" title="实验算法"></a>实验算法</h3><h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><p>本实验中主要使用C++中的map和string数据结构对数据进行处理，具体使用示例如下：</p>
<h5 id="对真值的存储"><a href="#对真值的存储" class="headerlink" title="对真值的存储"></a>对真值的存储</h5><p>考虑到合式公式的真值是和字符/字符串一一对应的，而真值为int（0或1），所以本实验使用map将合式公式和真值作为键值对存储到map中，事实证明这种数据处理方式取得了较为高效的数据存储效果。</p>
<h5 id="对合式公式的存储"><a href="#对合式公式的存储" class="headerlink" title="对合式公式的存储"></a>对合式公式的存储</h5><p>考虑到合式公式的不规则性以及在计算过程中需要频繁移动“指针”的位置，所以本实验使用string数据类型来存储要处理的合式公式，主要应用string的const_iterator对合式公式进行高效率的操作。<br>2）算法描述（包含输入输出说明）<br>本实验的主要算法思路是将需要判断真值的合式公式分解为小的合式公式“分而治之”，以括号为划分界限，计算出括号内”小的“合式公式的真值后再对总的合式公式进行真值判断。</p>
<h4 id="输入说明"><a href="#输入说明" class="headerlink" title="输入说明"></a>输入说明</h4><p>输入合式公式时考虑到电脑输入字符的限制性，规定用！表示 否定 ， 用&amp; 表示 合取 ， 用| 表示 析取</p>
<h4 id="输出说明"><a href="#输出说明" class="headerlink" title="输出说明"></a>输出说明</h4><p>本实验将会输出用户输入的总合式公式的真值，0代表”假“，1代表”真“。</p>
<h4 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h4><p><img src="https://img-
blog.csdn.net/20171121202535883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="运行界面"><a href="#运行界面" class="headerlink" title="运行界面"></a>运行界面</h4><p><img src="https://img-
blog.csdn.net/20171121202554532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://img-
blog.csdn.net/20171121202612093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="实验优点分析："><a href="#实验优点分析：" class="headerlink" title="实验优点分析："></a>实验优点分析：</h4><p>1：在求解较为复杂的合式公式的真值时采用”分而治之“的思想，将复杂的合式公式分解为多个简单的合式公式今进而求解，事实证明这种解决问题的思想起到了较为理想的效果。<br>2：在进行具体的计算时可以充分利用C++语言的特性，巧妙地使用了C++中的map和string数据结构，达到了事半功倍的效果。</p>
<h4 id="实验不足分析："><a href="#实验不足分析：" class="headerlink" title="实验不足分析："></a>实验不足分析：</h4><p>1：未能将完整合式公式的各个分部分的真值也列出来<br>2：未能实现图形界面从而增强用户人机交互的体验感</p>
<h4 id="实验不足的改进方案："><a href="#实验不足的改进方案：" class="headerlink" title="实验不足的改进方案："></a>实验不足的改进方案：</h4><p>1：在对总的合式公式尽情求解时另外再使用一张map存储括号内的合式公式及其真值，但是要注意的是在存储时要特别处理”！“<br>2：可以通过C++实现底层算法、java实现图形界面的方法实现本实验的图形界面，即在本实验C++代码的基础上做一个套壳封装</p>
<h3 id="实验源码"><a href="#实验源码" class="headerlink" title="实验源码"></a>实验源码</h3><p>部分核心代码如下</p>
<h4 id="扫描括号并进行计算的方法（函数）："><a href="#扫描括号并进行计算的方法（函数）：" class="headerlink" title="扫描括号并进行计算的方法（函数）："></a>扫描括号并进行计算的方法（函数）：</h4><pre><code>int run_expr(string &amp;Expr) { //扫描括号
    int sum_kh = 0;//括号数
    string::const_iterator iter;
    string::const_iterator addr_kh[50];//用于记录括号的位置
    char kind_kh[50];//用于记录括号的类型
    for (iter = Expr.begin();
         iter != Expr.end(); iter++) {
        if (*iter == &apos;(&apos; || *iter == &apos;)&apos;) {
            addr_kh[sum_kh] = iter;
            kind_kh[sum_kh] = *iter;
            sum_kh++;
        }
    }
    if (0 == sum_kh)//如果没有括号
    {
        value = run_unkh_expr(Expr);
        return value;
    } else {
        int i = 0;
        for (; i &lt;= sum_kh; i++) {
            if (kind_kh[i] == &apos;)&apos;)//找到最内级的括号并跳出循环
                break;
        } //取出最内层没有括号的字符串
        string in_str = string(addr_kh[i - 1] + 1, addr_kh[i]); //算出最内层表达式的值
       //((!p&amp;q)|(p|q))&amp;(p|v)
        value = run_unkh_expr(in_str);
        v_map[in_str] = value;


        static char var = &apos;1&apos;;
        value_map[var] = value;//将括号整体设为一个字符‘1’
        string::const_iterator ite = addr_kh[i - 1];//&quot;字符(的位置&quot; //判断（是不是表达式的开头
        string::const_iterator init_i;
        bool is_begin = false;
        if (ite == expr.begin()) { is_begin = true; }
        else { init_i = addr_kh[i - 1] - 1; }
        {
            expr.erase(ite, addr_kh[i] + 1);//删除掉最内层表达式包括括号在内
        }   //再在删除的地方插入新的字符‘1’作为标记


        if (is_begin == true) { expr = var + expr; }
        else { expr.insert(init_i + 1, var); }
        var = var + 1;
        value = run_expr(expr);
        return value;
    }
} //求主析取范式和主合取范式的函数
</code></pre><h4 id="处理具体合式关系的方法（函数）："><a href="#处理具体合式关系的方法（函数）：" class="headerlink" title="处理具体合式关系的方法（函数）："></a>处理具体合式关系的方法（函数）：</h4><pre><code>int deal_cal(int par1, char par2,
             int par3) {

    switch (par2) {
        case &apos;&amp;&apos;://合取
            return par1 &amp;&amp; par3;

        case &apos;|&apos;://析取
            return par1 || par3;

        default:
            cout &lt;&lt; &quot;有某些命题的真值错误&quot; &lt;&lt; endl;
            break;
    }
}
</code></pre><h4 id="具体项目见："><a href="#具体项目见：" class="headerlink" title="具体项目见："></a>具体项目见：</h4><p><a href="https://github.com/DMRFWIN/-DiscreteMathematicsExperiment_TruthTable.git" target="_blank" rel="noopener"> https://github.com/DMRFWIN/-DiscreteMathematicsExperiment_TruthTable.git
</a></p>
<h2 id="实验三：TSP问题求解（图形界面版）"><a href="#实验三：TSP问题求解（图形界面版）" class="headerlink" title="实验三：TSP问题求解（图形界面版）"></a>实验三：TSP问题求解（图形界面版）</h2><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><p>TSP问题求解</p>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑环境-1"><a href="#电脑环境-1" class="headerlink" title="电脑环境"></a>电脑环境</h4><p>系统：Ubuntu16.04LTS（Linux 4.10.0-37-generic x86_64）<br>处理器：Intel® Pentium(R) CPU N3700 @ 1.60GHz × 4<br>内存：7.7 GiB<br>操作系统类型：64位操作系统<br>图形：GeForce 920M/PCIe/SSE2</p>
<h4 id="编译运行环境-1"><a href="#编译运行环境-1" class="headerlink" title="编译运行环境"></a>编译运行环境</h4><p>Intellij IDEA Community</p>
<h4 id="编程语言-1"><a href="#编程语言-1" class="headerlink" title="编程语言"></a>编程语言</h4><p>JAVA语言</p>
<h3 id="实验算法-1"><a href="#实验算法-1" class="headerlink" title="实验算法"></a>实验算法</h3><h4 id="数据结构定义-1"><a href="#数据结构定义-1" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><p>本实验中用到了java中较为经典的MAP、LIST等数据结构。</p>
<h4 id="算法1描述（包含输入输出说明）"><a href="#算法1描述（包含输入输出说明）" class="headerlink" title="算法1描述（包含输入输出说明）"></a>算法1描述（包含输入输出说明）</h4><h5 id="算法思想描述"><a href="#算法思想描述" class="headerlink" title="算法思想描述"></a>算法思想描述</h5><p>a.从某一个城市开始，每次选择一个城市，直到所有的城市被走完。<br>b.每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h5><p>输入数据可以选择手动输入，也可选择从软件运行的本机中选择数据文件导入计算。</p>
<h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为两张表，一张为输入数据组成的数据表，另一张为最短路径经过的城市的代号构成的输出表，在表的末尾会输出对应算法计算的最短路径值。</p>
<h5 id="算法1流程图"><a href="#算法1流程图" class="headerlink" title="算法1流程图"></a>算法1流程图</h5><p><img src="https://img-
blog.csdn.net/20171121192940083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="算法2描述"><a href="#算法2描述" class="headerlink" title="算法2描述"></a>算法2描述</h4><p>算法2使用的是回溯法（试探法）：</p>
<h5 id="回溯法描述"><a href="#回溯法描述" class="headerlink" title="回溯法描述"></a>回溯法描述</h5><p>从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<h5 id="用回溯算法解决问题的一般步骤为："><a href="#用回溯算法解决问题的一般步骤为：" class="headerlink" title="用回溯算法解决问题的一般步骤为："></a>用回溯算法解决问题的一般步骤为：</h5><p>1、定义一个解空间，它包含问题的解。<br>2、利用适于搜索的方法组织解空间。<br>3、利用深度优先法搜索解空间。<br>4、利用限界函数避免移动到不可能产生解的子空间。</p>
<h5 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h5><p>输入数据可以选择手动输入，也可选择从软件运行的本机中选择数据文件导入计算。</p>
<h5 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为两张表，一张为输入数据组成的数据表，另一张为最短路径经过的城市的代号构成的输出表，在表的末尾会输出对应算法计算的最短路径值。####算法2流程图<br><img src="https://img-
blog.csdn.net/20171121193020815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="运行界面-1"><a href="#运行界面-1" class="headerlink" title="运行界面"></a>运行界面</h4><p>数据源选择界面：<br><img src="https://img-
blog.csdn.net/20171121194305749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>手动输入数据界面：<br><img src="https://img-
blog.csdn.net/20171121194358373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从本机选择数据文件界面：<br><img src="https://img-
blog.csdn.net/20171121200933961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="https://img-
blog.csdn.net/20171121201014012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="运行结果截图"><a href="#运行结果截图" class="headerlink" title="运行结果截图"></a>运行结果截图</h4><p>手动输入界面测试运行结果：<br><img src="https://img-
blog.csdn.net/20171121200834668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从本机选择文件测试结果：<br><img src="https://img-
blog.csdn.net/20171121201152310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h3><h4 id="核心算法代码"><a href="#核心算法代码" class="headerlink" title="核心算法代码"></a>核心算法代码</h4><h5 id="回溯法："><a href="#回溯法：" class="headerlink" title="回溯法："></a>回溯法：</h5><pre><code>package Algorithm;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class Back {
    private int distance[][];
    private int x[];
    private int b[];
    private int cl = 0;
    private int k = 10000;


    private int cityNum;

    public Back() {
    }

    public Map&lt;String, String&gt; GetMinRoadByBack(Map&lt;String, Integer&gt; roadBeans, String str_num) {
        InitData(roadBeans, str_num);

        int i;

        Traveling(2);

        b[cityNum] = b[0];

        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;result_road&quot;, Arrays.toString(b));
        result.put(&quot;result_value&quot;, String.valueOf(k));

        return result;
    }

    private void Traveling(int t) {
        int j;
        if (t &gt; cityNum) {
            if (distance[x[cityNum]][1] != -1 &amp;&amp; (cl + distance[x[cityNum]][1] &lt; k)) {
                for (j = 1; j &lt;= cityNum; j++)
                    b[j - 1] = x[j];
                k = cl + distance[x[cityNum]][1];
            }
        } else {
            for (j = t; j &lt;= cityNum; j++) {
                if (distance[x[t - 1]][x[j]] != -1 &amp;&amp; (cl + distance[x[t - 1]][x[j]] &lt; k)) {

                    int p = x[t];
                    x[t] = x[j];
                    x[j] = p;

                    cl += distance[x[t - 1]][x[t]];
                    Traveling(t + 1);
                    cl -= distance[x[t - 1]][x[t]];

                    p = x[t];
                    x[t] = x[j];
                    x[j] = p;
                }
            }
        }
    }


    private void InitData(Map&lt;String, Integer&gt; roadBeans, String str_num) {

        cityNum = str_num.length();
        distance = new int[cityNum + 1][cityNum + 1];
        x = new int[cityNum + 1];
        b = new int[cityNum + 1];

        for (int i = 1; i &lt;= cityNum; i++) {
            x[i] = i;
            b[i] = 0;
        }


        for (Map.Entry&lt;String, Integer&gt; entry : roadBeans.entrySet()) {

            String s = entry.getKey();
            String[] split = s.split(&quot;,&quot;);
            int a = Integer.parseInt(split[0]);
            int b = Integer.parseInt(split[1]);

            int length = entry.getValue();


            distance[a][b] = length;
        }
    }
}
</code></pre><h5 id="贪心法："><a href="#贪心法：" class="headerlink" title="贪心法："></a>贪心法：</h5><pre><code>package Algorithm;

import Bean.RoadBean;


import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class Greedy {


    private Map&lt;RoadBean, Double&gt; roadBeanst;

    private int cityNum; // 城市数量
    private int[][] distance; // 距离矩阵
    private Double[][] distance2;

    private int[] colable;//代表列，也表示是否走过，走过置0
    private int[] row;//代表行，选过置0


    public Map&lt;String, String&gt; GetMinRoadByTx(Map&lt;String, Integer&gt; roadBeans, String str_num) {

        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();

        InitData(roadBeans, str_num);

        int[] temp = new int[cityNum];
        int[] path = new int[cityNum + 1];
        int path_num = 0;
        path[path_num++] = 1;


        int s = 0;//计算距离
        int i = 0;//当前节点
        int j = 0;//下一个节点
        //默认从0开始
        while (row[i] == 1) {
            //复制一行
            for (int k = 0; k &lt; cityNum; k++) {
                temp[k] = distance[i][k];
                //System.out.print(temp[k]+&quot; &quot;);
            }
            //System.out.println();
            //选择下一个节点，要求不是已经走过，并且与i不同
            j = selectmin(temp);
            //找出下一节点
            row[i] = 0;//行置0，表示已经选过
            colable[j] = 0;//列0，表示已经走过

            path[path_num++] = j + 1;
            //System.out.println(i + &quot;--&gt;&quot; + j);
            //System.out.println(distance[i][j]);
            if (distance[i][j] == 0) {
                s += distance[j][i];
            } else {
                s += distance[i][j];
            }

            i = j;//当前节点指向下一节点
        }

        result.put(&quot;result_road&quot;, Arrays.toString(path));
        result.put(&quot;result_value&quot;, String.valueOf(s));

        return result;
    }


    public int selectmin(int[] p) {
        int j = 0, m = p[0], k = 0;
        //寻找第一个可用节点，注意最后一次寻找，没有可用节点
        while (colable[j] == 0) {
            j++;
            //System.out.print(j+&quot; &quot;);
            if (j &gt;= cityNum) {
                //没有可用节点，说明已结束，最后一次为 *--&gt;0
                m = p[0];
                break;
                //或者直接return 0;
            } else {
                m = p[j];
            }
        }
        //从可用节点J开始往后扫描，找出距离最小节点
        for (; j &lt; cityNum; j++) {
            if (colable[j] == 1) {
                if (m &gt;= p[j]) {
                    m = p[j];
                    k = j;
                }
            }
        }
        return k;
    }


    private void InitData(Map&lt;String, Integer&gt; roadBeans, String str_num) {

        cityNum = str_num.length();

        distance = new int[cityNum][cityNum];

        colable = new int[cityNum];
        colable[0] = 0;
        for (int i = 1; i &lt; cityNum; i++) {
            colable[i] = 1;
        }

        row = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) {
            row[i] = 1;
        }

        for (Map.Entry&lt;String, Integer&gt; entry : roadBeans.entrySet()) {

            String s = entry.getKey();
            String[] split = s.split(&quot;,&quot;);
            int a = Integer.parseInt(split[0]);
            int b = Integer.parseInt(split[1]);

            int length = entry.getValue();

            a--;
            b--;

            distance[a][b] = length;
        }
    }

    public Map&lt;String, String&gt; GetMinRoadByTx(Map&lt;String, Double&gt; stringDoubleMap, int citynum) {
        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();
        this.cityNum = citynum;
        InitData(stringDoubleMap);


        Double[] temp = new Double[cityNum];

        for (int i = 0; i &lt; cityNum; i++) {
            temp[i] = 0.0;
        }
        int[] path = new int[cityNum + 1];
        int path_num = 0;
        path[path_num++] = 1;


        Double s = 0.0;//计算距离
        int i = 0;//当前节点
        int j = 0;//下一个节点
        //默认从0开始
        while (row[i] == 1) {
            //复制一行
            for (int k = 0; k &lt; cityNum; k++) {
                temp[k] = distance2[i][k];
                //System.out.print(temp[k]+&quot; &quot;);
            }
            //System.out.println();
            //选择下一个节点，要求不是已经走过，并且与i不同
            j = selectmin(temp);
            //找出下一节点
            row[i] = 0;//行置0，表示已经选过
            colable[j] = 0;//列0，表示已经走过

            path[path_num++] = j + 1;
            //System.out.println(i + &quot;--&gt;&quot; + j);
            //System.out.println(distance[i][j]);
            if (distance2[i][j] == 0) {
                s += distance2[j][i];
            } else {
                s += distance2[i][j];
            }

            i = j;//当前节点指向下一节点
        }

        result.put(&quot;result_road&quot;, Arrays.toString(path));
        result.put(&quot;result_value&quot;, String.valueOf(s));

        return result;

    }

    private int selectmin(Double[] p) {
        int j = 0, k = 0;
        Double m = p[0];
        //寻找第一个可用节点，注意最后一次寻找，没有可用节点
        while (colable[j] == 0) {
            j++;
            //System.out.print(j+&quot; &quot;);
            if (j &gt;= cityNum) {
                //没有可用节点，说明已结束，最后一次为 *--&gt;0
                m = p[0];
                break;
                //或者直接return 0;
            } else {
                m = p[j];
            }
        }
        //从可用节点J开始往后扫描，找出距离最小节点
        for (; j &lt; cityNum; j++) {
            if (colable[j] == 1) {
                if (m &gt;= p[j]) {
                    m = p[j];
                    k = j;
                }
            }
        }
        return k;
    }

    private void InitData(Map&lt;String, Double&gt; stringDoubleMap) {


        distance2 = new Double[cityNum][cityNum];

        colable = new int[cityNum];
        colable[0] = 0;
        for (int i = 1; i &lt; cityNum; i++) {
            colable[i] = 1;
        }

        row = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) {
            row[i] = 1;
        }

        for (Map.Entry&lt;String, Double&gt; entry : stringDoubleMap.entrySet()) {

            String s = entry.getKey();
            String[] split = s.split(&quot;,&quot;);
            int a = Integer.parseInt(split[0]);
            int b = Integer.parseInt(split[1]);

            Double length = entry.getValue();
            a--;
            b--;


            distance2[a][b] = length;
        }

    }
}
</code></pre><h4 id="具体代码见："><a href="#具体代码见：" class="headerlink" title="具体代码见："></a>具体代码见：</h4><p><a href="https://github.com/DMRFWIN/DiscreteMathematicsExperiment_TSP_Javaversion" target="_blank" rel="noopener"> java图形界面版TSP问题求解源码
</a></p>
<h2 id="实验三：TSP问题求解（没有图形界面的黑框框版）"><a href="#实验三：TSP问题求解（没有图形界面的黑框框版）" class="headerlink" title="实验三：TSP问题求解（没有图形界面的黑框框版）"></a>实验三：TSP问题求解（没有图形界面的黑框框版）</h2><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><p>TSP问题求解</p>
<h3 id="实验环境-2"><a href="#实验环境-2" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑环境-2"><a href="#电脑环境-2" class="headerlink" title="电脑环境"></a>电脑环境</h4><p>系统：Ubuntu16.04LTS（Linux 4.10.0-37-generic x86_64）<br>处理器：Intel® Pentium(R) CPU N3700 @ 1.60GHz × 4<br>内存：7.7 GiB<br>操作系统类型：64位操作系统<br>图形：GeForce 920M/PCIe/SSE2</p>
<h4 id="编译运行环境-2"><a href="#编译运行环境-2" class="headerlink" title="编译运行环境"></a>编译运行环境</h4><p>CLion2017.2.3</p>
<h4 id="编程语言-2"><a href="#编程语言-2" class="headerlink" title="编程语言"></a>编程语言</h4><p>C/C++语言</p>
<h3 id="实验算法-2"><a href="#实验算法-2" class="headerlink" title="实验算法"></a>实验算法</h3><h4 id="数据结构定义-2"><a href="#数据结构定义-2" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><p>本实验考虑到所要处理的城市数量不会太多，所以使用比较简单易懂的矩阵（二维数组）来存储图，即S[a][b]=c表示城市a和城市b之间的距离为c。</p>
<h4 id="算法1描述（包含输入输出说明）-1"><a href="#算法1描述（包含输入输出说明）-1" class="headerlink" title="算法1描述（包含输入输出说明）"></a>算法1描述（包含输入输出说明）</h4><p>算法1采用的是贪心算法</p>
<h5 id="算法思想描述-1"><a href="#算法思想描述-1" class="headerlink" title="算法思想描述"></a>算法思想描述</h5><p>a.从某一个城市开始，每次选择一个城市，直到所有的城市被走完。<br>b.每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p>
<h5 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h5><p>输入时根据提示前两行输入城市数量n和道路数量m，接下来m行，每行3个数，表示m条道路的起点终点以及权重。</p>
<h5 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为2行，第一行为该算法求解的经过路径，格式为“a–&gt;b–&gt;c–&gt;d–&gt;a”，第二行为使用此种走法的最短路径值。</p>
<h5 id="算法1流程图-1"><a href="#算法1流程图-1" class="headerlink" title="算法1流程图"></a>算法1流程图</h5><p><img src="https://img-
blog.csdn.net/20171121192940083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="算法2描述-1"><a href="#算法2描述-1" class="headerlink" title="算法2描述"></a>算法2描述</h4><p>算法2使用的是回溯法（试探法）：</p>
<h5 id="回溯法描述-1"><a href="#回溯法描述-1" class="headerlink" title="回溯法描述"></a>回溯法描述</h5><p>从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<h5 id="用回溯算法解决问题的一般步骤为：-1"><a href="#用回溯算法解决问题的一般步骤为：-1" class="headerlink" title="用回溯算法解决问题的一般步骤为："></a>用回溯算法解决问题的一般步骤为：</h5><p>1、定义一个解空间，它包含问题的解。<br>2、利用适于搜索的方法组织解空间。<br>3、利用深度优先法搜索解空间。<br>4、利用限界函数避免移动到不可能产生解的子空间。</p>
<h5 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h5><p>输入时根据提示前两行输入城市数量n和道路数量m，接下来m行，每行3个数，表示m条道路的起点终点以及权重。</p>
<h5 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为2行，第一行为该算法求解的经过路径，格式为“a–&gt;b–&gt;c–&gt;d–&gt;a”，第二行为使用此种走法的最短路径值。</p>
<h4 id="算法2流程图"><a href="#算法2流程图" class="headerlink" title="算法2流程图"></a>算法2流程图</h4><p><img src="https://img-
blog.csdn.net/20171121193020815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="运行界面-2"><a href="#运行界面-2" class="headerlink" title="运行界面"></a>运行界面</h4><p><img src="https://img-
blog.csdn.net/20171121193059596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="运行结果截图-1"><a href="#运行结果截图-1" class="headerlink" title="运行结果截图"></a>运行结果截图</h4><p><img src="https://img-
blog.csdn.net/20171121193121057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="项目代码-1"><a href="#项目代码-1" class="headerlink" title="项目代码"></a>项目代码</h3><h4 id="核心算法代码-1"><a href="#核心算法代码-1" class="headerlink" title="核心算法代码"></a>核心算法代码</h4><h5 id="回溯法：-1"><a href="#回溯法：-1" class="headerlink" title="回溯法："></a>回溯法：</h5><pre><code>void GetMinRoadByHs() {
    int i;
    for (i = 1; i &lt;= n; i++) {
        x[i] = i;
        b[i] = 0;
    }
    Traveling(2);
    cout &lt;&lt; &quot;城市路线：&quot; &lt;&lt; endl;
    for (i = 1; i &lt;= n; i++)
        cout &lt;&lt; b[i] &lt;&lt; &quot;--&gt;&quot;;
    cout &lt;&lt; b[1];
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;最短路线长度：&quot; &lt;&lt; endl;
    cout &lt;&lt; k &lt;&lt; endl;
}

void Traveling(int t) {
    int j;
    if (t &gt; n) {
        if (g[x[n]][1] != -1 &amp;&amp; (cl + g[x[n]][1] &lt; k)) {
            for (j = 1; j &lt;= n; j++)
                b[j] = x[j];
            k = cl + g[x[n]][1];
        }
    } else {
        for (j = t; j &lt;= n; j++) {
            if (g[x[t - 1]][x[j]] != -1 &amp;&amp; (cl + g[x[t - 1]][x[j]] &lt; k)) {
                swap(x[t], x[j]);
                cl += g[x[t - 1]][x[t]];
                Traveling(t + 1);
                cl -= g[x[t - 1]][x[t]];
                swap(x[t], x[j]);
            }
        }
    }
}
</code></pre><h5 id="贪心法：-1"><a href="#贪心法：-1" class="headerlink" title="贪心法："></a>贪心法：</h5><pre><code>void GetMinRoadByTx() {

    /**
     * S[n]用于存储已经访问过的城市
     * D[a][b]用于存储a和b之间的距离
     * flag 访问过为1，没访问过为0
     * i至今已经访问过的城市
     */
    int j, k, l;
    int i;
    i = 1;
    int beng = i;
    int sum = 0;
    int Dtemp;
    int flag;
    do {
        k = 1;
        Dtemp = 10000;
        do {
            l = 0;
            flag = 0;
            do {
                if (S[l] == k) {//判断该城市是否已被访问过，若被访问过，
                    flag = 1;//则flag为1
                    break;//跳出循环，不参与距离的比较
                } else
                    l++;
            } while (l &lt; i);
            if (flag == 0 &amp;&amp; D[k][S[i - 1]] &lt; Dtemp) {/*D[k][S[i - 1]]表示当前未被访问的城市k与上一个已访问过的城市i-1之间的距离*/
                j = k;//j用于存储已访问过的城市k
                Dtemp = D[k][S[i - 1]];//Dtemp用于暂时存储当前最小路径的值
            }
            k++;
        } while (k &lt; n);
        S[i] = j;//将已访问过的城市j存入到S[i]中
        i++;
        sum += Dtemp;//求出各城市之间的最短距离，注意：在结束循环时，该旅行商尚未回到原出发的城市
    } while (i &lt; n);
    sum += D[0][j];//D[0][j]为旅行商所在的最后一个城市与原出发的城市之间的距离
    for (j = 0; j &lt; n; j++) { //输出经过的城市的路径
        cout &lt;&lt; S[j] + 1 &lt;&lt; &quot;--&gt;&quot;;
    }
    cout &lt;&lt; beng;
    cout &lt;&lt; &quot;\n&quot; &lt;&lt; sum;
}
</code></pre><h4 id="具体代码见：-1"><a href="#具体代码见：-1" class="headerlink" title="具体代码见："></a>具体代码见：</h4><p><a href="https://github.com/DMRFWIN/DiscreteMathematicsExperiment_TSP" target="_blank" rel="noopener"> https://github.com/DMRFWIN/DiscreteMathematicsExperiment_TSP
</a></p>
<h3 id="实验分析-1"><a href="#实验分析-1" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="2个算法的对比"><a href="#2个算法的对比" class="headerlink" title="2个算法的对比"></a>2个算法的对比</h4><p>从实验结果很明显可以看出由于贪心法的“只关心局部最小”<br>原则，导致最终求得的结果并不一定是最小的，相比之下回溯法求得的结果明显是最小的，但是回溯法的算法思想和代码复杂度明显高于贪心法，所以得出结论，当并不需要准确的最小值时我们可以用贪心法当对结果的准确性要求较高时我们应该使用回溯法。</p>
<h2 id="实验总结和体会"><a href="#实验总结和体会" class="headerlink" title="实验总结和体会"></a>实验总结和体会</h2><h3 id="通过本次实验我有以下收获和感受："><a href="#通过本次实验我有以下收获和感受：" class="headerlink" title="通过本次实验我有以下收获和感受："></a>通过本次实验我有以下收获和感受：</h3><p>如何把课堂上学到的离散数学的理论知识应用到实际的编程中，懂得了离散数学是如何提高变成效率的。<br>懂得了如何高效地阅读英文论文、从中提取精华部分，对以后阅读英文文档/论文有很大的帮助。<br>对TSP问题有更加清晰的认识，知道如何编程实现不同的算法解决TSP问题。<br>对合式公式的概念认识更加清楚，巩固了合式公式的计算方法。</p>
<h3 id="对实验的建议："><a href="#对实验的建议：" class="headerlink" title="对实验的建议："></a>对实验的建议：</h3><p>实验可以采用多人（3人以下）组队的方式合作完成，方便提高同学们的团队协作能力。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/11/20/两种不同方式解决八皇后问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/20/两种不同方式解决八皇后问题/" itemprop="url">两种不同方式解决八皇后问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-20T19:28:57+08:00">
                2017-11-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>这个问题可以有两种解决方法，一种是使用递归，比较简单易懂，另一种是使用栈，利用栈的特性避免了递归的使用，从而提高了效率（递归的虽然简单易写，但是其效率往往较低）。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先将节点的坐标定义为结构体：</p>
<pre><code>typedef struct {
 int x;
 int y;
} Coord;
</code></pre><p>定义好judge函数（用于判断对应点坐标是否可以放置皇后）：</p>
<pre><code>bool judge(SqStack S, int x, int y) {
    SqStack m = S;
    while (!StackEmpty(m)) {
        Coord e;
        e = Pop(m);
        if ((e.x == x) || (abs(e.x - x) == abs(e.y - y))) {
            return false;//如果不行返回false
        }
    }

    return true;//如果可以返回true
}
</code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre><code>void Recursive(SqStack &amp;S, int y) {

    if (StackEmpty(S)) {
        for (int i = 1; i &lt;= N; ++i) {
            Coord e;
            e.x = i;
            e.y = 1;
            Push(S, e);
            Recursive(S, 2);
            Pop(S);
        }
    } else if (Full(S)) {
        StackTraverse(S);
        n++;
        return;
    } else {
        for (int i = 1; i &lt;= N; ++i) {
            if (judge(S, i, y)) {
                Coord e;
                e.x = i;
                e.y = y;
                Push(S, e);
                Recursive(S, y + 1);
                Pop(S);
            }
        }
    }
}
</code></pre><p>这里要注意递归调用Recurive之后要pop出递归之前push进去的，有进就要有出～</p>
<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><pre><code>void Search(SqStack s) {

    int i = 1;
    bool flag;

    Coord e;
    e.x = 0;
    e.y = 1;

    while (i &lt;= 8) {

        if (flag) {
            e.x = 0;
        }
        if (Full(s)) {
            e = Pop(s);

        }
        flag = false;

        for (int j = e.x + 1; j &lt;= 8; j++) {
            if (judge(s, j, i)) {
                Coord e2;
                e2.x = j;
                e2.y = i;
                Push(s, e2);
                //  cout &lt;&lt; &quot;a&quot; &lt;&lt; i &lt;&lt; &quot;(&quot; &lt;&lt; e.y &lt;&lt; &quot;,&quot; &lt;&lt; e.x &lt;&lt; &quot;) &quot;;
                flag = true;
                break;
            }
        }


        if (flag) {
            if (i == 8) {
                StackTraverse(s);
                num++;

            } else {
                i++;
            }
        } else {
            i--;
            e = Pop(s);
            if (i == 0) {
                break;
            }
        }

    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/11/08/从LeNet中分析Caffe模型要素/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/08/从LeNet中分析Caffe模型要素/" itemprop="url">从LeNet中分析Caffe模型要素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-08T23:56:40+08:00">
                2017-11-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习之caffe/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习之caffe</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Caffe的模型需要两个重要的参数文件： <strong>网络模型</strong> 和 <strong>参数配置</strong> (分别是<br>.prototxt文件和.solver.prototxt文件），本文通过经典的LeNet网络分析具体的参数意义。</p>
<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p>Caffe的网络模型文件定义了网络的每一层行为，下图是用Caffe中的python/draw_net.py画出的LeNet的模型（如果图片太小看不清可以右击在选择在新窗口打开或者保存到本地用图片查看器放大查看）：</p>
<p><img src="https://img-
blog.csdn.net/20171108231630575?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h2 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h2><p>LeNet网络模型的输入层为数据层，即 <strong>网络模型的数据输入定义</strong> ，一般包括训练数据层和测试数据层两种类型。</p>
<h3 id="LeNet训练数据层"><a href="#LeNet训练数据层" class="headerlink" title="LeNet训练数据层"></a>LeNet训练数据层</h3><pre><code> layer {
  name: &quot;mnist&quot;
  type: &quot;Data&quot;
  top: &quot;data&quot;
  top: &quot;label&quot;
  include {
    phase: TRAIN
  }0p
  transform_param {
    scale: 0.00390625//数据缩放因子
  }
  data_param {
    source: &quot;examples/mnist/mnist_train_lmdb&quot;//数据路径
    batch_size: 64//批处理数据大小即一次性读取图片的数目
    backend: LMDB
  }
}
</code></pre><p>LeNet测试数据层与训练数据层各字段含义相同。</p>
<h3 id="LeNet训练卷积（Convoluation）层"><a href="#LeNet训练卷积（Convoluation）层" class="headerlink" title="LeNet训练卷积（Convoluation）层"></a>LeNet训练卷积（Convoluation）层</h3><pre><code>layer {
  name: &quot;conv1&quot;
  type: &quot;Convolution&quot;
  bottom: &quot;data&quot;
  top: &quot;conv1&quot;
  param {
    lr_mult: 1//表示weight（权重）更新时的学习率，1倍表示与全局参数一致
  }
  param {
    lr_mult: 2/*表示bias（偏差）更新时的学习率，一般为权重学习率（weight）学习率的2倍，这样一般会取得很好的收敛速率*/
  }
  convolution_param {//卷积计算参数
    num_output: 20//滤波个数即输出特征图（feature map）的数目
    kernel_size: 5//滤波大小即卷积核尺寸（在这里为5×5）
    stride: 1//步长即卷积输出跳跃间隔，1表示连续输出，无跳跃
    weight_filler {
      type: &quot;xavier&quot;/*滤波类型，在这里的意思就是权值使用xavier填充器*/
    }
    bias_filler {
      type: &quot;constant&quot;//bias使用常数填充器，默认为0
    }
  }
}
</code></pre><h3 id="LeNet训练池化（Pooling）层"><a href="#LeNet训练池化（Pooling）层" class="headerlink" title="LeNet训练池化（Pooling）层"></a>LeNet训练池化（Pooling）层</h3><pre><code>layer {//又叫下采样层
  name: &quot;pool1&quot;
  type: &quot;Pooling&quot;
  bottom: &quot;conv1&quot;//输入blob
  top: &quot;pool1&quot;//输出blob
  pooling_param {//下采样参数
    pool: MAX//采样方式，这里用的是最大采样
    kernel_size: 2//下采样窗口尺寸
    stride: 2//下采样跳跃间隔，这里为2×2
  }
}
</code></pre><h3 id="LeNet训练全连接层"><a href="#LeNet训练全连接层" class="headerlink" title="LeNet训练全连接层"></a>LeNet训练全连接层</h3><pre><code>layer {
  name: &quot;ip1&quot;
  type: &quot;InnerProduct&quot;
  bottom: &quot;pool2&quot;//输入blob
  top: &quot;ip1&quot;//输出blob
  param {
    lr_mult: 1
  }
  param {
    lr_mult: 2
  }
  inner_product_param {//全连接层参数
    num_output: 500//该层输出参数为500
    weight_filler {
      type: &quot;xavier&quot;
    }
    bias_filler {
      type: &quot;constant&quot;
    }
  }
}
</code></pre><h3 id="LeNet训练激活函数层"><a href="#LeNet训练激活函数层" class="headerlink" title="LeNet训练激活函数层"></a>LeNet训练激活函数层</h3><h4 id="ReLU层"><a href="#ReLU层" class="headerlink" title="ReLU层"></a>ReLU层</h4><pre><code>layer {//非线性层
  name: &quot;relu1&quot;
  type: &quot;ReLU&quot;
  bottom: &quot;ip1&quot;
  top: &quot;ip1&quot;
}
</code></pre><h4 id="Softmax层"><a href="#Softmax层" class="headerlink" title="Softmax层"></a>Softmax层</h4><pre><code>layer {//损失层
  name: &quot;loss&quot;
  type: &quot;SoftmaxWithLoss&quot;//损失函数
  bottom: &quot;ip2&quot;
  bottom: &quot;label&quot;
  top: &quot;loss&quot;
}
</code></pre><h1 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h1><p>Caffe中的参数配置文件.solver.prototxt定义了网络模型训练过程中需要设置的参数，比如学习率、权重衰减系数、迭代次数、使用CPU还是GPU等。</p>
<h2 id="LeNet的参数文件解析"><a href="#LeNet的参数文件解析" class="headerlink" title="LeNet的参数文件解析"></a>LeNet的参数文件解析</h2><pre><code># The train/test net protocol buffer definition
net: &quot;examples/mnist/lenet_train_test.prototxt&quot;
# test_iter specifies how many forward passes the test should carry out.
# In the case of MNIST, we have test batch size 100 and 100 test iterations,
# covering the full 10,000 testing images.

test_iter: 100//预测阶段迭代次数（要求与TEST层的batch_size相乘之后等于总的预测集的图片数）

# Carry out testing every 500 training iterations.

test_interval: 500//训练时每迭代500次进行一次预测

# The base learning rate, momentum and the weight decay of the network.

base_lr: 0.01//基础学习速率
momentum: 0.9//冲量
weight_decay: 0.0005//权衰量

# The learning rate policy
lr_policy: &quot;inv&quot;//学习速率的衰减策略
gamma: 0.0001
power: 0.75
# Display every 100 iterations

display: 100//没经过100次迭代在屏幕上打印一次运行log

# The maximum number of iterations

max_iter: 10000//最大迭代次数

# snapshot intermediate results
snapshot: 5000
snapshot_prefix: &quot;examples/mnist/lenet&quot;
# solver mode: CPU or GPU
solver_mode: GPU//选择使用CPU还是GPU进行训练
</code></pre><p>训练出的输出文件格式为.caffemodel即所求的model，可以拷贝至目标机器进行分类、定位和识别。</p>
<p>参考资料：<br>【1】：深度学习——Caffe之经典模型详解与实战 乐毅 王斌 编著<br>【2】：深度学习——21天实战caffe 赵永科 编著</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
