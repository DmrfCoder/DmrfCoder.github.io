<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="DmrfCoder的个人主页">
<meta property="og:url" content="http://www.mashangxue123.com/page/3/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DmrfCoder的个人主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/page/3/">





  <title>DmrfCoder的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/09/03/Android okhttp cookie持久化方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/Android okhttp cookie持久化方法/" itemprop="url">Android okhttp cookie持久化方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T17:03:30+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cookie的作用"><a href="#cookie的作用" class="headerlink" title="cookie的作用"></a>cookie的作用</h2><p>当app需要保持用户登陆状态等，这个时候我们通常就要进行对cookie的管理来实现。如果你使用的是okhttp网络请求，那么就可以直接对cookie进行持久化管理。</p>
<h2 id="使用okhttp3进行cookie的持久化处理"><a href="#使用okhttp3进行cookie的持久化处理" class="headerlink" title="使用okhttp3进行cookie的持久化处理"></a>使用okhttp3进行cookie的持久化处理</h2><p>主要原理是使用okhttp3中新增的Cookiejar这个接口，通过这个接口我们可以直接进行cookie的持久化管理，代码如下：</p>
<ul>
<li><p>首先实现cookieJar，里面有一个管理cookie的公共接口CookieStore，代码如下： </p>
<pre><code>import java.net.CookieStore;
</code></pre><p>import java.util.List;</p>
<p>import okhttp3.Cookie;<br>import okhttp3.CookieJar;<br>import okhttp3.HttpUrl;</p>
<p>/**</p>
<ul>
<li>@author dmrfcoder</li>
<li>@date 2018/8/28<br>*/</li>
</ul>
<p>public class CookieJarImpl implements CookieJar {</p>
</li>
</ul>
<pre><code>  public interface CookieStore {

      /**
       * 保存url对应所有cookie
       */
      void saveCookie(HttpUrl url, List&lt;Cookie&gt; cookie);

      /**
       * 保存url对应所有cookie
       */
      void saveCookie(HttpUrl url, Cookie cookie);

      /**
       * 加载url所有的cookie
       */
      List&lt;Cookie&gt; loadCookie(HttpUrl url);

      /**
       * 获取当前所有保存的cookie
       */
      List&lt;Cookie&gt; getAllCookie();

      /**
       * 获取当前url对应的所有的cookie
       */
      List&lt;Cookie&gt; getCookie(HttpUrl url);

      /**
       * 根据url和cookie移除对应的cookie
       */
      boolean removeCookie(HttpUrl url, Cookie cookie);

      /**
       * 根据url移除所有的cookie
       */
      boolean removeCookie(HttpUrl url);

      /**
       * 移除所有的cookie
       */
      boolean removeAllCookie();
  }


  private CookieStore cookieStore;

  public CookieJarImpl(CookieStore cookieStore) {
      if (cookieStore == null) {
          throw new IllegalArgumentException(&quot;cookieStore can not be null!&quot;);
      }
      this.cookieStore = cookieStore;
  }

  @Override
  public synchronized void saveFromResponse(HttpUrl url, List&lt;Cookie&gt; cookies) {
      cookieStore.saveCookie(url, cookies);
  }

  @Override
  public synchronized List&lt;Cookie&gt; loadForRequest(HttpUrl url) {
      return cookieStore.loadCookie(url);
  }

  public CookieStore getCookieStore() {
      return cookieStore;
  }
}
</code></pre><ul>
<li><p>实现cookie的序列化： </p>
<pre><code>import android.content.ContentValues;
</code></pre><p>import android.database.Cursor;<br>import android.util.Log;</p>
<p>import java.io.ByteArrayInputStream;<br>import java.io.ByteArrayOutputStream;<br>import java.io.IOException;<br>import java.io.ObjectInputStream;<br>import java.io.ObjectOutputStream;<br>import java.io.Serializable;<br>import java.util.Locale;</p>
<p>import okhttp3.Cookie;</p>
<p>/**</p>
<ul>
<li>@author dmrfcoder</li>
<li>@date 2018/8/28<br>*/</li>
</ul>
<p>public class SerializableCookie implements Serializable {<br>  private static final long serialVersionUID = 6374381323722046732L;</p>
<p>  public static final String HOST = “host”;<br>  public static final String NAME = “name”;<br>  public static final String DOMAIN = “domain”;<br>  public static final String COOKIE = “cookie”;</p>
<p>  public String host;<br>  public String name;<br>  public String domain;<br>  private transient Cookie cookie;<br>  private transient Cookie clientCookie;</p>
<p>  public SerializableCookie(String host, Cookie cookie) {</p>
<pre><code>this.cookie = cookie;
this.host = host;
this.name = cookie.name();
this.domain = cookie.domain();
</code></pre><p>  }</p>
<p>  public Cookie getCookie() {</p>
<pre><code>Cookie bestCookie = cookie;
if (clientCookie != null) {
    bestCookie = clientCookie;
}
return bestCookie;
</code></pre><p>  }</p>
<p>  private void writeObject(ObjectOutputStream out) throws IOException {</p>
<pre><code>out.defaultWriteObject();
out.writeObject(cookie.name());
out.writeObject(cookie.value());
out.writeLong(cookie.expiresAt());
out.writeObject(cookie.domain());
out.writeObject(cookie.path());
out.writeBoolean(cookie.secure());
out.writeBoolean(cookie.httpOnly());
out.writeBoolean(cookie.hostOnly());
out.writeBoolean(cookie.persistent());
</code></pre><p>  }</p>
<p>  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {</p>
<pre><code>in.defaultReadObject();
String name = (String) in.readObject();
String value = (String) in.readObject();
long expiresAt = in.readLong();
String domain = (String) in.readObject();
String path = (String) in.readObject();
boolean secure = in.readBoolean();
boolean httpOnly = in.readBoolean();
boolean hostOnly = in.readBoolean();
boolean persistent = in.readBoolean();
Cookie.Builder builder = new Cookie.Builder();
builder = builder.name(name);
builder = builder.value(value);
builder = builder.expiresAt(expiresAt);
builder = hostOnly ? builder.hostOnlyDomain(domain) : builder.domain(domain);
builder = builder.path(path);
builder = secure ? builder.secure() : builder;
builder = httpOnly ? builder.httpOnly() : builder;
clientCookie = builder.build();
</code></pre><p>  }</p>
<p>  public static SerializableCookie parseCursorToBean(Cursor cursor) {</p>
<pre><code>String host = cursor.getString(cursor.getColumnIndex(HOST));
byte[] cookieBytes = cursor.getBlob(cursor.getColumnIndex(COOKIE));
Cookie cookie = bytesToCookie(cookieBytes);
return new SerializableCookie(host, cookie);
</code></pre><p>  }</p>
<p>  public static ContentValues getContentValues(SerializableCookie serializableCookie) {</p>
<pre><code>ContentValues values = new ContentValues();
values.put(SerializableCookie.HOST, serializableCookie.host);
values.put(SerializableCookie.NAME, serializableCookie.name);
values.put(SerializableCookie.DOMAIN, serializableCookie.domain);
values.put(SerializableCookie.COOKIE, cookieToBytes(serializableCookie.host, serializableCookie.getCookie()));
return values;
</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li>cookies 序列化成 string<br>*</li>
<li>@param cookie 要序列化</li>
<li><p>@return 序列化之后的string<br>*/<br>public static String encodeCookie(String host, Cookie cookie) {<br> if (cookie == null) {</p>
<pre><code>return null;
</code></pre><p> }<br> byte[] cookieBytes = cookieToBytes(host, cookie);<br> return byteArrayToHexString(cookieBytes);<br>}</p>
<p>public static byte[] cookieToBytes(String host, Cookie cookie) {<br> SerializableCookie serializableCookie = new SerializableCookie(host, cookie);<br> ByteArrayOutputStream os = new ByteArrayOutputStream();<br> try {</p>
<pre><code>ObjectOutputStream outputStream = new ObjectOutputStream(os);
outputStream.writeObject(serializableCookie);
</code></pre><p> } catch (IOException e) {</p>
<pre><code>Log.e(&quot;cookieToBytes: &quot;, e.toString());
return null;
</code></pre><p> }<br> return os.toByteArray();<br>}</p>
<p>/**</p>
</li>
<li>将字符串反序列化成cookies<br>*</li>
<li>@param cookieString cookies string</li>
<li><p>@return cookie object<br>*/<br>public static Cookie decodeCookie(String cookieString) {<br> byte[] bytes = hexStringToByteArray(cookieString);<br> return bytesToCookie(bytes);<br>}</p>
<p>public static Cookie bytesToCookie(byte[] bytes) {<br> ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);<br> Cookie cookie = null;<br> try {</p>
<pre><code>ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
cookie = ((SerializableCookie) objectInputStream.readObject()).getCookie();
</code></pre><p> } catch (Exception e) {</p>
<pre><code>Log.e(&quot;bytesToCookie: &quot;, e.toString());
</code></pre><p> }<br> return cookie;<br>}</p>
<p>/**</p>
</li>
<li>二进制数组转十六进制字符串<br>*</li>
<li>@param bytes byte array to be converted</li>
<li><p>@return string containing hex values<br><em>/<br>private static String byteArrayToHexString(byte[] bytes) {<br> StringBuilder sb = new StringBuilder(bytes.length </em> 2);<br> for (byte element : bytes) {</p>
<pre><code>int v = element &amp; 0xff;
if (v &lt; 16) {
    sb.append(&apos;0&apos;);
}
sb.append(Integer.toHexString(v));
</code></pre><p> }<br> return sb.toString().toUpperCase(Locale.US);<br>}</p>
<p>/**</p>
</li>
<li>十六进制字符串转二进制数组<br>*</li>
<li>@param hexString string of hex-encoded values</li>
<li><p>@return decoded byte array<br>*/<br>private static byte[] hexStringToByteArray(String hexString) {<br> int len = hexString.length();<br> byte[] data = new byte[len / 2];<br> for (int i = 0; i &lt; len; i += 2) {</p>
<pre><code>data[i / 2] = (byte) ((Character.digit(hexString.charAt(i), 16) &lt;&lt; 4) + Character.digit(hexString.charAt(i + 1), 16));
</code></pre><p> }<br> return data;<br>}</p>
<p>/**</p>
</li>
<li><p>host, name, domain 标识一个cookie是否唯一<br>*/<br>@Override<br>public boolean equals(Object o) {<br> if (this == o) {</p>
<pre><code>return true;
</code></pre><p> }<br> if (o == null || getClass() != o.getClass()) {</p>
<pre><code>return false;
</code></pre><p> }</p>
<p> SerializableCookie that = (SerializableCookie) o;</p>
<p> if (host != null ? !host.equals(that.host) : that.host != null) {</p>
<pre><code>return false;
</code></pre><p> }<br> return (name != null ? name.equals(that.name) : that.name == null) &amp;&amp; (domain != null ? domain.equals(that.domain) : that.domain == null);<br>}</p>
<p>@Override<br>public int hashCode() {<br> int result = host != null ? host.hashCode() : 0;<br> result = 31 <em> result + (name != null ? name.hashCode() : 0);<br> result = 31 </em> result + (domain != null ? domain.hashCode() : 0);<br> return result;<br>}<br>}</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>使用 SharedPreferences 持久化存储 cookie： </p>
<pre><code>package cn.xiaojii.cashgift.bean.net;
</code></pre><p>import android.content.Context;<br>import android.content.SharedPreferences;<br>import android.text.TextUtils;</p>
<p>import java.util.ArrayList;<br>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.List;<br>import java.util.Map;<br>import java.util.Set;<br>import java.util.concurrent.ConcurrentHashMap;</p>
<p>import okhttp3.Cookie;<br>import okhttp3.HttpUrl;</p>
<p>/**</p>
<ul>
<li>@author dmrfcoder</li>
<li>@date 2018/8/28<br>*/</li>
</ul>
<p>public class SPCookieStore implements CookieJarImpl.CookieStore {</p>
<p>  private static final String COOKIE_PREFS = “sp_cookie”;           //cookie使用prefs保存<br>  private static final String COOKIE_NAME_PREFIX = “cookie_”;         //cookie持久化的统一前缀</p>
</li>
</ul>
<pre><code>  private final Map&lt;String, ConcurrentHashMap&lt;String, Cookie&gt;&gt; cookies;
  private final SharedPreferences cookiePrefs;

  public SPCookieStore(Context context) {
      cookiePrefs = context.getSharedPreferences(COOKIE_PREFS, Context.MODE_PRIVATE);
      cookies = new HashMap&lt;&gt;();

      //将持久化的cookies缓存到内存中,数据结构为 Map&lt;Url.host, Map&lt;CookieToken, Cookie&gt;&gt;
      Map&lt;String, ?&gt; prefsMap = cookiePrefs.getAll();
      for (Map.Entry&lt;String, ?&gt; entry : prefsMap.entrySet()) {
          if ((entry.getValue()) != null &amp;&amp; !entry.getKey().startsWith(COOKIE_NAME_PREFIX)) {
              //获取url对应的所有cookie的key,用&quot;,&quot;分割
              String[] cookieNames = TextUtils.split((String) entry.getValue(), &quot;,&quot;);
              for (String name : cookieNames) {
                  //根据对应cookie的Key,从xml中获取cookie的真实值
                  String encodedCookie = cookiePrefs.getString(COOKIE_NAME_PREFIX + name, null);
                  if (encodedCookie != null) {
                      Cookie decodedCookie = SerializableCookie.decodeCookie(encodedCookie);
                      if (decodedCookie != null) {
                          if (!cookies.containsKey(entry.getKey())) {
                              cookies.put(entry.getKey(), new ConcurrentHashMap&lt;String, Cookie&gt;());
                          }
                          cookies.get(entry.getKey()).put(name, decodedCookie);
                      }
                  }
              }
          }
      }
  }

  private String getCookieToken(Cookie cookie) {
      return cookie.name() + &quot;@&quot; + cookie.domain();
  }

  /**
   * 当前cookie是否过期
   */
  private static boolean isCookieExpired(Cookie cookie) {
      return cookie.expiresAt() &lt; System.currentTimeMillis();
  }

  /**
   * 将url的所有Cookie保存在本地
   */
  @Override
  public synchronized void saveCookie(HttpUrl url, List&lt;Cookie&gt; urlCookies) {
      for (Cookie cookie : urlCookies) {
          saveCookie(url, cookie);
      }
  }

  @Override
  public synchronized void saveCookie(HttpUrl url, Cookie cookie) {
      if (!cookies.containsKey(url.host())) {
          cookies.put(url.host(), new ConcurrentHashMap&lt;String, Cookie&gt;());
      }
      //当前cookie是否过期
      if (isCookieExpired(cookie)) {
          removeCookie(url, cookie);
      } else {
          saveCookie(url, cookie, getCookieToken(cookie));
      }
  }

  /**
   * 保存cookie，并将cookies持久化到本地
   */
  private void saveCookie(HttpUrl url, Cookie cookie, String cookieToken) {
      //内存缓存
      cookies.get(url.host()).put(cookieToken, cookie);
      //文件缓存
      SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
      prefsWriter.putString(url.host(), TextUtils.join(&quot;,&quot;, cookies.get(url.host()).keySet()));
      prefsWriter.putString(COOKIE_NAME_PREFIX + cookieToken, SerializableCookie.encodeCookie(url.host(), cookie));
      prefsWriter.apply();
  }

  /**
   * 根据当前url获取所有需要的cookie,只返回没有过期的cookie
   */
  @Override
  public synchronized List&lt;Cookie&gt; loadCookie(HttpUrl url) {
      List&lt;Cookie&gt; ret = new ArrayList&lt;&gt;();
      if (!cookies.containsKey(url.host())) {
          return ret;
      }

      Collection&lt;Cookie&gt; urlCookies = cookies.get(url.host()).values();
      for (Cookie cookie : urlCookies) {
          if (isCookieExpired(cookie)) {
              removeCookie(url, cookie);
          } else {
              ret.add(cookie);
          }
      }
      return ret;
  }

  /**
   * 根据url移除当前的cookie
   */
  @Override
  public synchronized boolean removeCookie(HttpUrl url, Cookie cookie) {
      if (!cookies.containsKey(url.host())) {
          return false;
      }
      String cookieToken = getCookieToken(cookie);
      if (!cookies.get(url.host()).containsKey(cookieToken)) {
          return false;
      }

      //内存移除
      cookies.get(url.host()).remove(cookieToken);
      //文件移除
      SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
      if (cookiePrefs.contains(COOKIE_NAME_PREFIX + cookieToken)) {
          prefsWriter.remove(COOKIE_NAME_PREFIX + cookieToken);
      }
      prefsWriter.putString(url.host(), TextUtils.join(&quot;,&quot;, cookies.get(url.host()).keySet()));
      prefsWriter.apply();
      return true;
  }

  @Override
  public synchronized boolean removeCookie(HttpUrl url) {
      if (!cookies.containsKey(url.host())) {
          return false;
      }

      //内存移除
      ConcurrentHashMap&lt;String, Cookie&gt; urlCookie = cookies.remove(url.host());
      //文件移除
      Set&lt;String&gt; cookieTokens = urlCookie.keySet();
      SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
      for (String cookieToken : cookieTokens) {
          if (cookiePrefs.contains(COOKIE_NAME_PREFIX + cookieToken)) {
              prefsWriter.remove(COOKIE_NAME_PREFIX + cookieToken);
          }
      }
      prefsWriter.remove(url.host());
      prefsWriter.apply();

      return true;
  }

  @Override
  public synchronized boolean removeAllCookie() {
      //内存移除
      cookies.clear();
      //文件移除
      SharedPreferences.Editor prefsWriter = cookiePrefs.edit();
      prefsWriter.clear();
      prefsWriter.apply();
      return true;
  }

  /**
   * 获取所有的cookie
   */
  @Override
  public synchronized List&lt;Cookie&gt; getAllCookie() {
      List&lt;Cookie&gt; ret = new ArrayList&lt;&gt;();
      for (String key : cookies.keySet()) {
          ret.addAll(cookies.get(key).values());
      }
      return ret;
  }

  @Override
  public synchronized List&lt;Cookie&gt; getCookie(HttpUrl url) {
      List&lt;Cookie&gt; ret = new ArrayList&lt;&gt;();
      Map&lt;String, Cookie&gt; mapCookie = cookies.get(url.host());
      if (mapCookie != null) {
          ret.addAll(mapCookie.values());
      }
      return ret;
  }
}
</code></pre><ul>
<li><p>进行取出cookie和删除cookie等公共类的封装： </p>
<pre><code>/**
</code></pre><ul>
<li>@author dmrfcoder</li>
<li>@date 2018/8/28<br>*/</li>
</ul>
<p>import android.util.Log;</p>
<p>import java.util.List;</p>
<p>import cn.xiaojii.cashgift.bean.net.CookieJarImpl;<br>import cn.xiaojii.cashgift.bean.net.OkManager;<br>import okhttp3.Cookie;<br>import okhttp3.HttpUrl;</p>
<p>/**</p>
<ul>
<li>cookie管理工具类</li>
<li><p>@author dmrfcoder<br>*/<br>public class CookieUtil {<br>/**</p>
<ul>
<li>获取指定URL对应的cookie<br>*</li>
<li>@param baseUrl</li>
<li>@param url</li>
<li>@return<br>*/<br>public static List<cookie> cookies(String baseUrl, String url) {<br> //一般手动取出cookie的目的只是交给 webview 等等，非必要情况不要自己操作<br> CookieJarImpl.CookieStore cookieStore = OkManager.getInstance().getCookieJar().getCookieStore();<br> HttpUrl httpUrl = HttpUrl.parse(baseUrl + url);<br> List<cookie> cookies = cookieStore.getCookie(httpUrl);<br> Log.e(“cookies: “, httpUrl.host() + “对应的cookie如下：” + cookies.toString());<br> return cookies;<br>}</cookie></cookie></li>
</ul>
<p>/**</p>
<ul>
<li>获取所有的cookie<br>*</li>
<li>@return<br>*/<br>public static List<cookie> cookieList() {<br> CookieJarImpl.CookieStore cookieStore = OkManager.getInstance().getCookieJar().getCookieStore();<br> List<cookie> allCookie = cookieStore.getAllCookie();<br> Log.e(“所有cookie如下: “, allCookie.toString());<br> return allCookie;<br>}</cookie></cookie></li>
</ul>
<p>public static String getCookie() {</p>
<pre><code>CookieJarImpl.CookieStore cookieStore = OkManager.getInstance().getCookieJar().getCookieStore();
List&lt;Cookie&gt; allCookie = cookieStore.getAllCookie();
for (int i = 0; i &lt; allCookie.size(); i++) {
    return allCookie.get(i).toString();
}
return null;
</code></pre><p>}</p>
<p>/**</p>
<ul>
<li>删除cookie（这里是全部删除，也可指定的地址删除）<br>*/<br>public static void removeCookie() {<br> CookieJarImpl.CookieStore cookieStore = OkManager.getInstance().getCookieJar().getCookieStore();<br> cookieStore.removeAllCookie();</li>
</ul>
<p>}<br>}</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>最终的Okmanager类： </p>
<pre><code>import java.util.concurrent.TimeUnit;
</code></pre></li>
</ul>
<pre><code>import okhttp3.OkHttpClient;

/**
* @author dmrfcoder
* @date 2018/8/28
*/

public class OkManager {
  public OkHttpClient getClient() {
      return client;
  }

  private OkHttpClient client;
  private volatile static OkManager okManager;
  private final String TAG = OkManager.class.getSimpleName();

  OkHttpClient.Builder httpBuilder;

  public OkManager() {


      //需要设置请求超时调用下面两行
      httpBuilder = new OkHttpClient.Builder();
      client = httpBuilder.readTimeout(10, TimeUnit.SECONDS)
              .connectTimeout(10, TimeUnit.SECONDS).writeTimeout(15, TimeUnit.SECONDS) //设置超时
              .cookieJar(new CookieJarImpl(new SPCookieStore(CashApplication.getContextObject())))
              .build();
      //将上面的CashApplication换成你自己的Application或者传入同样性质的参数
  }

  /**
   * 获取全局的cookie实例
   */
  public CookieJarImpl getCookieJar() {
      return (CookieJarImpl) client.cookieJar();
  }

  /**
   * 采用单例获取对象
   *
   * @return
   */
  public static OkManager getInstance() {
      if (okManager == null) {
          synchronized (OkManager.class) {
              if (okManager == null) {
                  okManager = new OkManager();
              }
          }
      }
      return okManager;
  }
}
</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>private OkHttpClient okHttpClient = OkManager.getInstance().getClient();
</code></pre><p>然后就实现了cookie的持久化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/09/03/Android如何设置顶部状态栏颜色（主题）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/Android如何设置顶部状态栏颜色（主题）/" itemprop="url">Android如何设置顶部状态栏颜色（主题）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T16:46:05+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android中我们经常需要设置屏幕顶部状态栏的主题和应用页面保持同一风格，本文介绍几种常用的设置方案：</p>
<h2 id="状态栏将显示为纯净的颜色，没有渐变效果"><a href="#状态栏将显示为纯净的颜色，没有渐变效果" class="headerlink" title="状态栏将显示为纯净的颜色，没有渐变效果"></a>状态栏将显示为纯净的颜色，没有渐变效果</h2><pre><code>/** 
 * 状态栏相关工具类 
 * 
 */  
public class StatusBarUtils {  

    //设置Activity对应的顶部状态栏的颜色
    public static void setWindowStatusBarColor(Activity activity, int colorResId) {  
        try {  
            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {  
                Window window = activity.getWindow();  
                window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);  
                window.setStatusBarColor(activity.getResources().getColor(colorResId));  
            }  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  

     //设置Dialog对应的顶部状态栏的颜色
    public static void setWindowStatusBarColor(Dialog dialog, int colorResId) {  
        try {  
            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {  
                Window window = dialog.getWindow();  
                window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);  
                window.setStatusBarColor(dialog.getContext().getResources().getColor(colorResId));  
            }  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
}  
</code></pre><h2 id="通过style来设置应用顶部状态栏的颜色"><a href="#通过style来设置应用顶部状态栏的颜色" class="headerlink" title="通过style来设置应用顶部状态栏的颜色"></a>通过style来设置应用顶部状态栏的颜色</h2><p>首先给出一张图：</p>
<p><img src="https://img-
blog.csdn.net/20180903171621608?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>通过上图，我们可以通过设置不同的属性来达到控制不同位置颜色的目的，下面给出使用示例，修改res/values-19里面的内容：</p>
<pre><code>&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt;
&lt;item name=&quot;colorPrimary&quot;&gt;@android:color/holo_blue_bright&lt;/item&gt;
&lt;item name=&quot;colorPrimaryDark&quot;&gt;@android:color/holo_blue_bright&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>主要是设置 colorPrimary，colorPrimaryDark这两个属性的值来设置状态栏的颜色，需要注意的是：</p>
<p>1:AndroidManifest.xml文件中的targetSdkVersion必须设置在 <strong>21</strong> 以上。</p>
<p>2.parent主题必须是 <strong>Theme.AppCompat</strong> 开头，兼容包下的主题，所以必须一用 <strong>v7</strong> 包。</p>
<h2 id="在顶部标题栏设置属性值达到风格一致的目的"><a href="#在顶部标题栏设置属性值达到风格一致的目的" class="headerlink" title="在顶部标题栏设置属性值达到风格一致的目的"></a>在顶部标题栏设置属性值达到风格一致的目的</h2><p>首先修改res/values-v19文件夹下的styles.xml文件内容如下（如果没有可以新建一个）：</p>
<pre><code>&lt;style name= &quot;AppTheme&quot; parent=&quot;@style/BaseAppTheme&quot;&gt;
&lt;item name=&quot;android:windowTranslucentStatus&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>然后设置顶部标题控件的两个属性：</p>
<pre><code>android:background=&quot;@android:color/holo_blue_bright&quot;
android:fitsSystemWindows=&quot;true&quot;
</code></pre><p>这时状态栏会保持与设置fitsSystemWindow属性的控件的背景颜色一致。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Free-Thinker/p/5210663.html" target="_blank" rel="noopener"> Android状态栏颜色修改 </a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/09/03/Android将Uri转化为文件路径的方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/Android将Uri转化为文件路径的方法/" itemprop="url">Android将Uri转化为文件路径的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T11:30:05+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>直接贴代码：</p>
<pre><code>@RequiresApi(api = Build.VERSION_CODES.KITKAT)
   public static String getpath(Context context, Uri uri){
       if (ContentResolver.SCHEME_CONTENT.equals(uri.getScheme())) {
           if (DocumentsContract.isDocumentUri(context, uri)) {
               if (isExternalStorageDocument(uri)) {
                   // ExternalStorageProvider
                   final String docId = DocumentsContract.getDocumentId(uri);
                   final String[] split = docId.split(&quot;:&quot;);
                   final String type = split[0];
                   if (&quot;primary&quot;.equalsIgnoreCase(type)) {
                       String path = Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1];
                       return path;
                   }
               } else if (isDownloadsDocument(uri)) {
                   // DownloadsProvider
                   final String id = DocumentsContract.getDocumentId(uri);
                   final Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;),
                           Long.valueOf(id));
                   String path = getDataColumn(context, contentUri, null, null);
                   return path;
               } else if (isMediaDocument(uri)) {
                   // MediaProvider
                   final String docId = DocumentsContract.getDocumentId(uri);
                   final String[] split = docId.split(&quot;:&quot;);
                   final String type = split[0];
                   Uri contentUri = null;
                   if (&quot;image&quot;.equals(type)) {
                       contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                   } else if (&quot;video&quot;.equals(type)) {
                       contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
                   } else if (&quot;audio&quot;.equals(type)) {
                       contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
                   }
                   final String selection = &quot;_id=?&quot;;
                   final String[] selectionArgs = new String[]{split[1]};
                   String path = getDataColumn(context, contentUri, selection, selectionArgs);
                   return path;
               }
           }
       }
       return null;
   }


   private static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) {
       Cursor cursor = null;
       final String column = &quot;_data&quot;;
       final String[] projection = {column};
       try {
           cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null);
           if (cursor != null &amp;&amp; cursor.moveToFirst()) {
               final int column_index = cursor.getColumnIndexOrThrow(column);
               return cursor.getString(column_index);
           }
       } finally {
           if (cursor != null)
               cursor.close();
       }
       return null;
   }

   private static boolean isExternalStorageDocument(Uri uri) {
       return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority());
   }

   private static boolean isDownloadsDocument(Uri uri) {
       return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority());
   }

   private static boolean isMediaDocument(Uri uri) {
       return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority());
   }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/09/03/Android数据加密之AES加密/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/Android数据加密之AES加密/" itemprop="url">Android数据加密之AES加密</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T11:27:53+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称 Rijndael<br>加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的 DES，已经被多方分析且广为全世界所使用。简单说就是 DES 的增强版，比 DES<br>的加密强度更高。</p>
<p>AES 与 DES<br>一样，一共有四种加密模式：电子密码本模式（ECB）、加密分组链接模式（CBC）、加密反馈模式（CFB）和输出反馈模式（OFB）。关于加密模式的介绍，推荐这篇文章：<br><a href="https://blog.poxiao.me/p/advanced-
encryption-standard-and-block-cipher-mode/" target="_blank" rel="noopener"> 高级加密标准AES的工作模式（ECB、CBC、CFB、OFB） </a></p>
<p>直接给代码：</p>
<h2 id="加密-byte级别"><a href="#加密-byte级别" class="headerlink" title="加密(byte级别)"></a>加密(byte级别)</h2><pre><code>   /* 加密使用的 key */
   private static final String AES_KEY = &quot;KUbHwTqBy6TBQ2gN&quot;;
   /* 加密使用的 IV */
   private static final String AES_IV = &quot;pIbF6GR3XEN1PG05&quot;;

/**
    * AES 加密
    *
    * @param content 待加密内容
    * @param key     密钥
    * @return 加密的数据
    */
   public static byte[] encryptAES(byte[] content, byte[] key) {
       try {
           SecretKeySpec secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;);
           // AES 是加密方式, CBC 是工作模式, PKCS5Padding 是填充模式
           Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
           // IV 是初始向量，可以增强密码的强度
           cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, new IvParameterSpec(AES_IV.getBytes()));
           return cipher.doFinal(content);
       } catch (Exception e) {
           logger.error(e);
       }
       return null;
   }
</code></pre><h2 id="解密-（byte级别）"><a href="#解密-（byte级别）" class="headerlink" title="解密 （byte级别）"></a>解密 （byte级别）</h2><pre><code>/**
     * AES 解密
     *
     * @param content 待解密内容
     * @param key     密钥
     * @return 解密的数据
     */
    public static byte[] decryptAES(byte[] content, byte[] key) {
        try {
            SecretKeySpec secretKeySpec = new SecretKeySpec(key, &quot;AES&quot;);
            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(AES_IV.getBytes()));
            return cipher.doFinal(content);
        } catch (Exception e) {
            logger.error(e);
        }
        return null;
    }
</code></pre><h2 id="加密（String级别）"><a href="#加密（String级别）" class="headerlink" title="加密（String级别）"></a>加密（String级别）</h2><pre><code>private final static String TOKEN_KEY = &quot;91a29fa7w46d8x41&quot;;

public static String encrypt(String plain) {
    try {
        Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
        AlgorithmParameterSpec ivSpec = new IvParameterSpec(new byte[16]);
        SecretKeySpec newKey = new SecretKeySpec(TOKEN_KEY.getBytes(), &quot;AES&quot;);
        cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
        return new String(cipher.doFinal(plain.getBytes()));
    } catch (Exception e) {
        Ln.e(e);
        return null;
    }
}
</code></pre><h2 id="解密（String级别）"><a href="#解密（String级别）" class="headerlink" title="解密（String级别）"></a>解密（String级别）</h2><pre><code>public static String decrypt(String encoded) {
       try {
           Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
           AlgorithmParameterSpec ivSpec = new IvParameterSpec(new byte[16]);
           SecretKeySpec newKey = new SecretKeySpec(TOKEN_KEY.getBytes(), &quot;AES&quot;);
           cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
           return new String(cipher.doFinal(encoded.getBytes()));
       } catch (Exception e) {
           Ln.e(e);
           return null;
       }
   }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/08/21/36 句话看完锤子科技 2018 夏季新品发布会/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/36 句话看完锤子科技 2018 夏季新品发布会/" itemprop="url">36 句话看完锤子科技 2018 夏季新品发布会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T15:59:56+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>锤子科技于 2018 年 8 月 20<br>日在北京凯迪拉克中心（原五棵松体育馆）举行了新品发布会，发布了搭载颠覆性的“无限屏”功能与“TNT”大屏幕操作系统的坚果 Pro 2S<br>及众多新品配件。现在，我们用 36 句话看完这场发布会。</p>
<ul>
<li>我们是来自四川省成都市成华区的知名企业锤子科技，非常欢迎大家来到凯迪拉克中心，观看锤子科技 2018 年第 3 场发布会。再次感谢全国几十家视频平台直播今天这次活动。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287376680feb92b8c8" alt="这里写图片描述"></p>
<ul>
<li>今年 5 月，我们在鸟巢发布的新品旗舰机坚果 R1，可谓命运多舛：不仅赶上了中国智能手机市场萎缩的历史时期，还在第一批产品里出现了一些问题。即便如此，坚果 R1 仍然得到了专业行家们的一致认同：“锤子科技一直以来在手机的工业设计上都可称得上是教科书级别的存在，在坚果 R1 上更显得淋漓尽致。” </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/1534828737654ac1fa0babb" alt="这里写图片描述"></p>
<ul>
<li><p>同样于鸟巢发布的 TNT 大屏系统就没这么幸运了，我们甚至很难从网上找到关于 TNT 的正面评论。不过，这三个月来，当我们想到那些先知先觉的前人时，这一切其实也没想象的那么糟。“原谅他们，因为他们不知道自己在做什么。”——《圣经》路家福音 23 章 34 节<br><img src="http://p3.pstatp.com/large/pgc-image/153482873783798a2863ce1" alt="这里写图片描述"></p>
</li>
<li><p>2018 年的产品线我们是这样规划的：4 月份发布的坚果 3 和 5 月份发布的坚果 R1 在今年的产品定位中属于正常定位；TNT 风险非常大，投入非常高，回报非常慢，所以对企业来讲，它是个冒险、激进的方案；今天发布的是一款稳健的产品；到了年终我们还有一场发布会，会发布一些“没人相信的东西”。<br><img src="http://p3.pstatp.com/large/pgc-image/15348287384593bd2fb6be6" alt="这里写图片描述"></p>
</li>
<li><p>今天的主角是稳健型产品：坚果 Pro 2S。坚果 Pro 系列是锤子科技历史上整体最成熟均衡、好评度最高的一款产品线，坚果 Pro 2 更是在去年被几十家知名数字媒体评为“年度最佳中档手机”。沿着这条成功的产品线，今天我们要推出 0.5 代升级版——坚果 Pro 2S。<br><img src="http://p99.pstatp.com/large/pgc-image/15348287385009105e40f58" alt="这里写图片描述"></p>
</li>
<li><p>工业设计方面，坚果 Pro 2S 的外形和坚果 Pro 2 差不多，所有的经典设计都得以保留。但这次我们采用了全新的 CMF 色彩工艺，除了传统的黑白经典配色，新增了闷骚的炫光蓝、明骚的炫光红版本。 </p>
</li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/1534828737587035b69cb67" alt=""></p>
<ul>
<li>硬件配置及功能是此次升级很重要的方面。首先采用的是比较新的骁龙 710，相对于坚果 Pro 2，坚果 Pro 2S 的单核性能提升了 15.7%，多核性能提升了 5%，图形性能戏剧性地提高了 56.84%，AI 性能提升了 100%。 </li>
</ul>
<p><img src="http://p9.pstatp.com/large/pgc-image/1534828739772bc01bbc89e" alt=""></p>
<p><img src="http://p99.pstatp.com/large/pgc-image/15348287378713a843623ea" alt=""></p>
<ul>
<li>这次成像效果相对于坚果 Pro 2 是个非常大的进步和提升。坚果 Pro 2S 采用了 1200 万+500 万旗舰级 AI 双摄，1.4μm 超大像素传感器，索尼 IMX363 传感器，Dual PD 双核对焦，ArcSoft 提供专业图像算法。由旷视 Face++提供的 AI 技术，自动识别画面 18 个大类型和 200 多种场景。1600 万前置摄像头，背景虚化、实时美颜。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/153482873800543f2f90925" alt=""></p>
<ul>
<li>我们把相机送去权威机构 DxOMark 测了一下影像效果，结果怎么样呢？只拿了 95 分（微笑）。注意，我们作为中档机型，这个成绩仅次于 iPhone 8 Plus，竟然好于 iPhone 8，在这个价位的手机里是非常了不起的。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/153482873917142cf48f78d" alt=""></p>
<ul>
<li>坚果 Pro 2S 采用高通提供的 TV-OUT 2K 超高清输出，随时随地连大屏，手游畅玩不卡顿。传统的手机投屏有 31 毫秒的延迟，而坚果 Pro 2S 的屏只有 14 毫秒的延迟。14 毫秒什么概念？少于一帧，人类不可感知。除非你是苍蝇，有复眼。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287380915626fa3760" alt=""></p>
<ul>
<li>我们非常努力地只增加了 100mAh 电池，因为同时把它做薄到只有 7.15mm；如果不做薄，我们可以加更多的电池，但 3600mAh 电池，对 80%、90% 的用户都足够了。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287383346dc63c2433" alt=""></p>
<ul>
<li>全新低功耗 OLED 屏幕，超高对比度达到 100000:1，100% 覆盖 P3 广色域，相信大家会对这块屏感到满意。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/153482873840325892e2d40" alt=""></p>
<ul>
<li>全局采用了线性马达，它仿真了一些真实物理世界的触感，虽然是假的，但摸起来像是真的。拥有 36 种振动效果，52 种振动场景。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287385275210fe1a93" alt=""></p>
<ul>
<li>这次发布的 Smarteisan OS v6.6.5，新增了 41 项功能，优化了 25 次产品细节。今天要给大家主要介绍的是三个板块：第一个就是 TNT。我们并不是简单地要卖一个一万块钱的大屏幕，重要的是我们要做一个用手机替代 PC、Mac 全功能的桌面级的系统。实际上如果你不考虑触控版本，只是考虑键鼠版本的话，任何一个普通的显示器都可以，买一个市面上 34 寸的显示器，装上以后用键鼠模式就可以用，比目前任何一家做的手机转大屏都可以做得更好。 </li>
</ul>
<p><img src="http://p99.pstatp.com/large/pgc-image/15348287386526b1ee33d3f" alt=""></p>
<p><img src="http://p9.pstatp.com/large/pgc-image/15348287386767c0bec0022" alt=""></p>
<ul>
<li>TNT 的众测版 8 月 20 日提供下载。如果你手里已经有了坚果 R1，今天就可以到网站上下载 TNT 的众测版，可以用键鼠模式；坚果 Pro 2S 在 9月12日开始提供下载，下载地址在我们官网论坛 bbs.t.tt 上有非常详细的说明和连接。 </li>
</ul>
<p><img src="http://p9.pstatp.com/large/pgc-image/15348287387202db21f2e40" alt=""></p>
<ul>
<li>子弹短信是锤子科技和快如科技联合推出的超高效率的次世代即时通讯工具。起初它是为大屏幕设计的，今天我们把大部分精髓移植到了手机屏幕上，把短信沟通效率提高到了难以置信的程度。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/15348287401237c4b5399e5" alt=""></p>
<ul>
<li>在子弹短信中，你的每一条语音消息都会同文字一同发送，如果对方对文字如果有所困惑，听语音就可以解决，此外你也可以任意拖动语音的进度条。语音+文字的形式能够保证信息快速发出，且不用因为纠错而对人产生困扰。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/1534828738904f874bb2385" alt=""></p>
<ul>
<li>你可以在列表页完成绝大部分的回复操作，点击消息后面的按键可以直接以语音或文本的形式进行回复，群聊的未读信息也可以在不进入群的情况下直接展开并单独回复任意一条。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287390491dc2c2a8fa" alt=""></p>
<ul>
<li>对于坚果手机，在任何情况下按住闪念胶囊键说话，可以直接将信息发送给好友；对于非坚果手机的安卓用户，屏幕上会显示一个悬浮球，按住它说话，也能达到相同的效果；而对于 iPhone 用户，使用 3D Touch 按压子弹短信图标也会弹出说话的按钮，你一闪而过的想法可以当场得到解决。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287389685081e0191e" alt=""></p>
<ul>
<li>还有一些十分贴心的细节设计比如：查看并锁定好友的历史头像、帮助你回忆起好友是谁避免尴尬的“这是谁来着？”、将日常对话设置为稍后处理以免忘记、以及帮助大家进行社交的“发现锤友”功能。 </li>
</ul>
<p><img src="http://p99.pstatp.com/large/pgc-image/1534828740160f3e70394ee" alt=""></p>
<ul>
<li>我们也打破了必须要双方共同安装才能使用社交软件的尴尬，只要你有对方的手机号，你可以随时向对方发送文本、语音、文件等，对方会以短信的形式收到，同时可以打开网页版子弹短信进行详细查看。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/1534828740709114be3470b" alt=""></p>
<ul>
<li>子弹短信会从 8 月 20 日起正式开放下载，大家可以到 zidanduanxin.com，或者到锤子科技官方论坛 bbs.t.tt 进行下载。同时我们会在 8 月 20 日- 10 月 8 日期间和 UI 中国合作举办子弹短信的 Bmoji 表情符设计大赛，如果大家有兴趣可以来参加我们的活动。 </li>
</ul>
<p><img src="http://p99.pstatp.com/large/pgc-image/1534828739243c42beb499b" alt=""></p>
<ul>
<li>今天真正的重头戏是“无限屏”。整个行业的精英们都是每天致力于“超高屏占比屏”、“全面屏”、“刘海屏”、“美人尖屏”、“真全面屏”，这真是解决问题的方向吗？小巧的 3.5 吋手机比例很好，但体验会很差，手机很大，又会显得很傻，我相信如果没有意外的话，未来相当一段时间，5.5-6 吋之间的尺寸是最主流的。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287404453f4126f924" alt=""></p>
<ul>
<li>所以我们做出了一些突破，带来了一个新的软件解决方案：“无限屏”，也叫 Infinite Screen。将手指从屏幕底部边缘向上推，你就能进入一个神奇的无限屏世界，只要用手进行挪动，你就可以迅速在多任务管理器中进行选择，或者选择某个光标，进入程序。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/1534828739643a1cbc61eea" alt=""></p>
<ul>
<li>大家自拍的时候会把手机仰起来，是因为这样显瘦，当你在无限屏模式下向上举起手机，你就能直接进入自拍模式。 </li>
<li>同时无限屏的最下面是一个地球，当你对准它然后松手，你就会进入地图，以往我们使用电子地图，需要用手反复滑动屏幕，很容易就不耐烦了，但在无限世界里，我们已经画好了一个足够详尽的地图，只要你将手机沿路线滑动过去就够了，这才是我们大脑的工作方式，是一个梦幻般的体验。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/1534828741048ff009a1962" alt=""></p>
<ul>
<li>我们也把能同时显示 14 个窗口的子弹短信重新带入了无限屏，你可以在无限屏内随易跳转窗口，在某一窗口复制，然后拖动到任意窗口进行粘贴，此外你也可以同时打开多个购物 app 进行比价，以及像桌面电脑一样自如地拖拽各类文件。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287401298dedeab9ff" alt=""></p>
<ul>
<li>“无限屏”在相册中也有不一样的体验，你只需要拖动手机，就能随意查看长图中的任何一个细节。我们终于有了对祖先的伟大作品进行致敬的方式，终于有了在手机上观赏《清明上河图》的唯一正确方式，这是一个工匠对另一个工匠的致敬。 </li>
</ul>
<p><img src="http://p99.pstatp.com/large/pgc-image/1534828740333da291cdf77" alt=""></p>
<ul>
<li><p>对于无限屏的功能还有很多展示，为了纪念这一刻，我们拍摄了下面这个短片： </p>
</li>
<li><p>虽然坚果 Pro 2S 相比“两千元价位没有对手的”坚果 Pro 2 进行了全方位的升级，但我们讲过做手机是为了交朋友，为了交定你们这些朋友，我们决定把 4GB RAM+64GB ROM 的版本定价为 1798 元，6GB RAM+64GB ROM 的版本定价为 1998 元，6GB RAM+128GB ROM 的版本也只要 2298 元。 </p>
</li>
</ul>
<p><img src="http://p99.pstatp.com/large/pgc-image/1534828741263182b87aa79" alt=""></p>
<ul>
<li>我们也发布了一些配件：添加了手电筒功能的“电池形电池”，售价 69 元；Pro 2S 软胶透明保护套，售价 29 元； Pro 2S TPU 软硅胶保护套，售价 49 元；五款全新的“足迹”系列背壳，售价 79 元；颜色随机的坚果彩虹数据线，售价 19 元。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/15348287415719a55d758b9" alt=""></p>
<ul>
<li>同时为了释放工业设计部门过剩的设计能力和欲望，我们还推出了坚果砖式蓝牙小音箱，售价 149 元。如果你财力过剩，你可以购买两个我们的小音箱，并把它们组成立体声。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/1534828740682ab375591fd" alt=""></p>
<ul>
<li>我们也很高兴地与湛庐文化进行了合作，在两年左右时间里引入了三本非常难得的三本书：《深泽直人》、《索尼设计，塑造现代》与《博朗设计——卓越创新 50 年》，有志投身工业设计，希望能引领中国的新国货运动或者新制造运动的朋友可以到京东图书或者锤子科技官方商城购买。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/1534828741551f7a807c8cf" alt=""></p>
<ul>
<li>还有一件很伤感的事情。由于我们在短短四个半月时间里在同一城市连续开了三场发布会，频率过于密集，导致此次发布会的门票收入情况与我们预想的有一些出入，只有 493,300 元钱，但为了继续支持开源社区的工作，锤子科技 CEO 罗永浩会自掏腰包，凑齐一百万继续支持 OpenSSL 和 OpenBSD 开源社区的工作。另外我们可能在半年之内就会从底层启动下一代不基于安卓的 OS 计划，为下一代的计算平台，不仅仅是手机，做出全新的努力。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/1534828741059278e4e0272" alt=""></p>
<ul>
<li>今年是手机行业非常艰难的一年，没有想到手机衰落期来得这么早。今年上半年整个行业迎来了百分之十八点九几的下滑，我们作为小厂商更加地困难。但在这个过程里我们还是排除万难做了一些不一样的创新。尽管 TNT 被嘲笑，被调侃，鸟巢的发布会也远谈不上是成功，但是我们在这里承诺一定会在 TNT 后续的成熟版本里给大家做出惊艳的东西来。 </li>
</ul>
<p><img src="http://p3.pstatp.com/large/pgc-image/1534828742021bb5f98ac7e" alt=""></p>
<ul>
<li>最后，为了不让大家对一个小改款升级的机型感到失望，这一次我们在非常非常短的时间里，花费了很大的时间与精力，最终拿出了“无限屏”，我们会承受着你们这种温暖的支持一直走下去，谢谢。 </li>
</ul>
<p><img src="http://p1.pstatp.com/large/pgc-image/1534828742374b756def703" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/07/28/Android 设置EditText 默认弹出数字软键盘并限制其输入内容/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/Android 设置EditText 默认弹出数字软键盘并限制其输入内容/" itemprop="url">Android 设置EditText 默认弹出数字软键盘并限制其输入内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T14:50:29+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>设置 EditText 首次输入弹出数字键盘，然后可以随便切换输入模式，另外以输入身份证号 为例，因为身份证号只可能是数字 + 字母<br>X，所以这里不仅做了首次弹出数字键盘，还实现了对于其他键盘模式输入做了限制，只能输入字母 X 。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.example.mu_16jj.edittextinputtypedemo.MainActivity&quot;&gt;

    &lt;EditText
        android:id=&quot;@+id/et_main&quot;
        android:layout_width=&quot;300dp&quot;
        android:layout_height=&quot;45dp&quot;
        android:layout_centerHorizontal=&quot;true&quot;
        android:layout_marginTop=&quot;25dp&quot;
        android:background=&quot;@drawable/sh_et_blue_bg&quot;
        android:gravity=&quot;center_vertical&quot;
        android:hint=&quot;默认弹出数字键盘&quot;
        android:paddingLeft=&quot;5dp&quot;
        android:textColor=&quot;@android:color/black&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>注意：这里并没有指定输入类型，因为如果指定了输入类型，那么就限定死了。</p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><pre><code>private void initView() {
        setContentView(R.layout.activity_main);
        editText = (EditText) findViewById(R.id.et_main);

        editText.setKeyListener(listener);
    }

    KeyListener listener = new NumberKeyListener() {

        /**
         * @return ：返回哪些希望可以被输入的字符,默认不允许输入
         */
        @Override
        protected char[] getAcceptedChars() {
            char[] chars = new char[]{&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;X&apos;};
            return chars;
//            return new char[0];
        }

        /**
         * 0：无键盘,键盘弹不出来
         * 1：英文键盘
         * 2：模拟键盘
         * 3：数字键盘
         *
         * @return
         */
        @Override
        public int getInputType() {
            return 3;
        }
    };
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/07/28/Android之——模拟实现检测心率变化的应用实例/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/Android之——模拟实现检测心率变化的应用实例/" itemprop="url">Android之——模拟实现检测心率变化的应用实例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T13:44:54+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android之——模拟实现检测心率变化的应用实例"><a href="#Android之——模拟实现检测心率变化的应用实例" class="headerlink" title="Android之——模拟实现检测心率变化的应用实例"></a>Android之——模拟实现检测心率变化的应用实例</h1><p>当今，市面上有了一些可以通过Android应用来检测病人心率，血压，体温，等等，一系列方便人们日常生活的Android手机应用。那么，这些实用的手机应用程序是怎么做出来的呢？那么，今天，我就给大家奉上一个很有意思的应用，那就是Android上模拟实现检测心率的变化。我利用Android模拟实现了通过手机摄像头来感知用户指尖毛细血管的变化来检测心率的功能。哇哦，听起来是不是很高大上呢？瞬间对这个功能充满了膜拜与好奇，有木有？！有木有呢？！哈哈，那就让我们一起来实现这些功能吧。</p>
<h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p>首先我们还是要讲讲这个应用的原理吧，在下认为，要做一个Android应用程序，咱们还要先弄懂它的实现原理吧。不然，看了半天各位都不知道这个应用是基于什么原理做的呢。是吧，那就让我们一起来分析下它的实现原理。</p>
<p>通过摄像头来获得心率，搜了一下这个技术真不是噱头，据说在iPhone早有实现，主要原理是：当打开软件时，手机的闪光灯也会被自动打开，用户将手指放在摄像头上时，指尖皮下血管由于有血液被压入，被光源照射的手指亮度（红色的深度）会有轻微的变化。这个过程可以凭借感光元件捕捉到。这样毛细血管的搏动就能通过画面明度的周期性变化反映出来。</p>
<p>好了，原理说完了，大家有木有看懂呢？</p>
<h3 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h3><h4 id="1、创建图像处理类ImageProcessing"><a href="#1、创建图像处理类ImageProcessing" class="headerlink" title="1、创建图像处理类ImageProcessing"></a>1、创建图像处理类ImageProcessing</h4><p>这个类主要提供处理图像本身的方法。</p>
<p>具体实现如下：</p>
<pre><code>    1. package com.lyz.monitor.utils;

2.  

3. /**

4.  * 图像处理类

5.  * @author liuyazhuang

6.  *

7.  */

8. public abstract class ImageProcessing {

9.  

10.    /**

11.    * 内部调用的处理图片的方法

12.     * @param yuv420sp

13.     * @param width

14.    * @param height

15.   * @return

16.     */

17.   private static int decodeYUV420SPtoRedSum(byte[] yuv420sp, int width,int height) {

18.       if (yuv420sp == null)

19.            return 0;

20.         final int frameSize = width * height;

21.        int sum = 0;

22.      for (int j = 0, yp = 0; j &lt; height; j++) {

23.          int uvp = frameSize + (j &gt;&gt; 1) * width, u = 0, v = 0;

24.             for (int i = 0; i &lt; width; i++, yp++) {

25.              int y = (0xff &amp; ((int) yuv420sp[yp])) - 16;

26.                if (y &lt; 0)

27.                     y = 0;

28.              if ((i &amp; 1) == 0) {

29.                  v = (0xff &amp; yuv420sp[uvp++]) - 128;

30.                    u = (0xff &amp; yuv420sp[uvp++]) - 128;

31.                }

32.                int y1192 = 1192 * y;

33.                 int r = (y1192 + 1634 * v);

34.               int g = (y1192 - 833 * v - 400 * u);

35.                 int b = (y1192 + 2066 * u);

36.  

37.              if (r &lt; 0)

38.                     r = 0;

39.              else if (r &gt; 262143)

40.                     r = 262143;

41.                 if (g &lt; 0)

42.                     g = 0;

43.              else if (g &gt; 262143)

44.                     g = 262143;

45.                 if (b &lt; 0)

46.                     b = 0;

47.              else if (b &gt; 262143)

48.                     b = 262143;

49.  

50.                int pixel = 0xff000000 | ((r &lt;&lt; 6) &amp; 0xff0000)

51.                        | ((g &gt;&gt; 2) &amp; 0xff00) | ((b &gt;&gt; 10) &amp; 0xff);

52.              int red = (pixel &gt;&gt; 16) &amp; 0xff;

53.                sum += red;

54.          }

55.        }

56.        return sum;

57.    }

58.  

59.   /**

60.    * 对外开放的图像处理方法

61.      * @param yuv420sp

62.     * @param width

63.    * @param height

64.   * @return

65.     */

66.   public static int decodeYUV420SPtoRedAvg(byte[] yuv420sp, int width,

67.           int height) {

68.      if (yuv420sp == null)

69.            return 0;

70.         final int frameSize = width * height;

71.        int sum = decodeYUV420SPtoRedSum(yuv420sp, width, height);

72.         return (sum / frameSize);

73.  }

74. }
</code></pre><h4 id="2、MainActivity实现"><a href="#2、MainActivity实现" class="headerlink" title="2、MainActivity实现"></a>2、MainActivity实现</h4><p>为了简单，我没有单独新建别的类来分解这些功能，我直接在MainActivity中实现了这些功能，那么我们就一起来看看是如何一步步实现的吧。</p>
<h5 id="1-程序中用到的属性"><a href="#1-程序中用到的属性" class="headerlink" title="(1)程序中用到的属性"></a>(1)程序中用到的属性</h5><p>首先，我们来看看程序中定义了哪些属性字段，来实现这些功能吧。</p>
<p>具体属性字段如下所示：</p>
<pre><code>    1. //曲线

2. private Timer timer = new Timer();

3. //Timer任务，与Timer配套使用

4. private TimerTask task;

5. private static int gx;

6. private static int j;

7.  

8. private static double flag=1;

9. private Handler handler;

10. private String title = &quot;pulse&quot;;

11. private XYSeries series;

12. private XYMultipleSeriesDataset mDataset;

13. private GraphicalView chart;

14. private XYMultipleSeriesRenderer renderer;

15. private Context context;

16. private int addX = -1;

17. double addY;

18. int[] xv = new int[300];

19. int[] yv = new int[300];

20. int[] hua=new int[]{9,10,11,12,13,14,13,12,11,10,9,8,7,6,7,8,9,10,11,10,10};

21.  

22. // private static final String TAG = &quot;HeartRateMonitor&quot;;

23. private static final AtomicBoolean processing = new AtomicBoolean(false);

24. //Android手机预览控件

25. private static SurfaceView preview = null;

26. //预览设置信息

27. private static SurfaceHolder previewHolder = null;

28. //Android手机相机句柄

29. private static Camera camera = null;

30. //private static View image = null;

31. private static TextView text = null;

32. private static TextView text1 = null;

33. private static TextView text2 = null;

34. private static WakeLock wakeLock = null;

35. private static int averageIndex = 0;

36. private static final int averageArraySize = 4;

37. private static final int[] averageArray = new int[averageArraySize];

38. //设置默认类型

39. private static TYPE currentType = TYPE.GREEN;

40. //获取当前类型

41. public static TYPE getCurrent() {

42.     return currentType;

43. }

44. //心跳下标值

45. private static int beatsIndex = 0;

46. //心跳数组的大小

47. private static final int beatsArraySize = 3;

48. //心跳数组

49. private static final int[] beatsArray = new int[beatsArraySize];

50. //心跳脉冲

51. private static double beats = 0;

52. //开始时间

53. private static long startTime = 0;
</code></pre><p>咋一看，是不是很多？有木有一种头晕乎乎的赶脚呢？没关系，通过后面具体的功能实现，相信大家能弄明白每个属性字段的作用与含义的。不要掉队，继续认真向下看哦。</p>
<h5 id="2-定义枚举类型来标识当前颜色"><a href="#2-定义枚举类型来标识当前颜色" class="headerlink" title="(2)定义枚举类型来标识当前颜色"></a>(2)定义枚举类型来标识当前颜色</h5><p>颜色类型，我在这里用一个枚举类型来定义，这个枚举类型很简单，只有两种颜色，一种是绿色，一种是红色。默认颜色为绿色。</p>
<p>具体实现的代码如下:</p>
<pre><code>    1. /**

2.      * 类型枚举

3.      * @author liuyazhuang

4.      *

5.   */

6.    public static enum TYPE {

7.       GREEN, RED

8.    };

9.    //设置默认类型

10.   private static TYPE currentType = TYPE.GREEN;

11.    //获取当前类型

12.   public static TYPE getCurrent() {

13.        return currentType;

14.    }
</code></pre><h5 id="3-初始化配置方法initConfig"><a href="#3-初始化配置方法initConfig" class="headerlink" title="(3)初始化配置方法initConfig"></a>(3)初始化配置方法initConfig</h5><p>这个方法总体上的功能是初始化程序的各个配置，包括调用其他方法，例如页面图表的初始化，UI控件的初始化，应用程序启动后显示的样式，调用相机，通过Handler接收其他方法传递过来的消息信息来更新UI，，等等。主要是实现应用的配置功能，同时这个方法相当于一个应用程序的管家，它来直接或间接的调用其他方法，来使整个应用程序顺利运行起来。</p>
<p>具体代码实现如下:</p>
<pre><code>    1. /**

2.      * 初始化配置

3.     */

4.    private void initConfig() {

5.       //曲线

6.        context = getApplicationContext();

7.  

8.        //这里获得main界面上的布局，下面会把图表画在这个布局里面

9.         LinearLayout layout = (LinearLayout)findViewById(R.id.linearLayout1);

10.  

11.       //这个类用来放置曲线上的所有点，是一个点的集合，根据这些点画出曲线

12.         series = new XYSeries(title);

13.  

14.         //创建一个数据集的实例，这个数据集将被用来创建图表

15.         mDataset = new XYMultipleSeriesDataset();

16.  

17.         //将点集添加到这个数据集中

18.         mDataset.addSeries(series);

19.  

20.         //以下都是曲线的样式和属性等等的设置，renderer相当于一个用来给图表做渲染的句柄

21.       int color = Color.GREEN;

22.       PointStyle style = PointStyle.CIRCLE;

23.        renderer = buildRenderer(color, style, true);

24.  

25.         //设置好图表的样式

26.         setChartSettings(renderer, &quot;X&quot;, &quot;Y&quot;, 0, 300, 4, 16, Color.WHITE, Color.WHITE);

27.  

28.        //生成图表

29.         chart = ChartFactory.getLineChartView(context, mDataset, renderer);

30.  

31.         //将图表添加到布局中去

32.       layout.addView(chart, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));

33.  

34.      //这里的Handler实例将配合下面的Timer实例，完成定时更新图表的功能

35.        handler = new Handler() {

36.          @Override

37.             public void handleMessage(Message msg) {

38.                 //               刷新图表

39.              updateChart();

40.               super.handleMessage(msg);

41.          }

42.        };

43.  

44.      task = new TimerTask() {

45.           @Override

46.             public void run() {

47.              Message message = new Message();

48.               message.what = 1;

49.               handler.sendMessage(message);

50.            }

51.        };

52.  

53.      timer.schedule(task, 1,20);           //曲线

54.       //获取SurfaceView控件

55.      preview = (SurfaceView) findViewById(R.id.preview);

56.      previewHolder = preview.getHolder();

57.         previewHolder.addCallback(surfaceCallback);

58.      previewHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);

59.      //       image = findViewById(R.id.image);

60.         text = (TextView) findViewById(R.id.text);

61.       text1 = (TextView) findViewById(R.id.text1);

62.         text2 = (TextView) findViewById(R.id.text2);

63.         PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);

64.        wakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK, &quot;DoNotDimScreen&quot;);

65.   }
</code></pre><h5 id="4-创建图表的方法buildRenderer"><a href="#4-创建图表的方法buildRenderer" class="headerlink" title="(4)创建图表的方法buildRenderer"></a>(4)创建图表的方法buildRenderer</h5><p>这个方法主要是利用了第三方的类库类实现创建图标的操作。</p>
<p>具体代码实现如下</p>
<pre><code>    1. /**

2.      * 创建图表

3.      * @param color

4.     * @param style

5.     * @param fill

6.      * @return

7.      */

8.    protected XYMultipleSeriesRenderer buildRenderer(int color, PointStyle style, boolean fill) {

9.       XYMultipleSeriesRenderer renderer = new XYMultipleSeriesRenderer();

10.  

11.       //设置图表中曲线本身的样式，包括颜色、点的大小以及线的粗细等

12.        XYSeriesRenderer r = new XYSeriesRenderer();

13.       r.setColor(Color.RED);

14. //     r.setPointStyle(null);

15. //      r.setFillPoints(fill);

16.        r.setLineWidth(1);

17.      renderer.addSeriesRenderer(r);

18.       return renderer;

19.   }
</code></pre><h5 id="5-设置图表的样式方法setChartSettings"><a href="#5-设置图表的样式方法setChartSettings" class="headerlink" title="(5)设置图表的样式方法setChartSettings"></a>(5)设置图表的样式方法setChartSettings</h5><p>这个方法主要是对(4)中创建的图表，进行样式的设置。</p>
<p>具体代码如下：</p>
<pre><code>    1. /**

2.      * 设置图标的样式

3.   * @param renderer

4.      * @param xTitle：x标题

5.    * @param yTitle：y标题

6.    * @param xMin：x最小长度

7.    * @param xMax：x最大长度

8.    * @param yMin:y最小长度

9.    * @param yMax：y最大长度

10.   * @param axesColor：颜色

11.     * @param labelsColor：标签

12.   */

13.   protected void setChartSettings(XYMultipleSeriesRenderer renderer, String xTitle, String yTitle,

14.             double xMin, double xMax, double yMin, double yMax, int axesColor, int labelsColor) {

15.        //有关对图表的渲染可参看api文档

16.         renderer.setChartTitle(title);

17.       renderer.setXTitle(xTitle);

18.      renderer.setYTitle(yTitle);

19.      renderer.setXAxisMin(xMin);

20.      renderer.setXAxisMax(xMax);

21.      renderer.setYAxisMin(yMin);

22.      renderer.setYAxisMax(yMax);

23.      renderer.setAxesColor(axesColor);

24.        renderer.setLabelsColor(labelsColor);

25.        renderer.setShowGrid(true);

26.        renderer.setGridColor(Color.GREEN);

27.      renderer.setXLabels(20);

28.        renderer.setYLabels(10);

29.        renderer.setXTitle(&quot;Time&quot;);

30.         renderer.setYTitle(&quot;mmHg&quot;);

31.         renderer.setYLabelsAlign(Align.RIGHT);

32.       renderer.setPointSize((float) 3 );

33.        renderer.setShowLegend(false);

34.     }
</code></pre><h5 id="6-更新图表updateChart"><a href="#6-更新图表updateChart" class="headerlink" title="(6)更新图表updateChart"></a>(6)更新图表updateChart</h5><p>这个方法主要实现了对图表中曲线图的更新绘制，同时检测手机摄像头感应的手指位置，如果手指位置不正确，则会提示“请用您的指尖盖住摄像头镜头”的信息来提示用户。动态的更新绘制曲线图来模拟用户心跳频率。</p>
<p>具体代码实现如下：</p>
<pre><code>    1. /**

2.     * 更新图标信息

3.    */

4.    private void updateChart() {

5.  

6.      //设置好下一个需要增加的节点

7.         if(flag==1)

8.            addY=10;

9.         else{

10. //            addY=250;

11.             flag=1;

12.             if(gx&lt;200){

13.                if(hua[20]&gt;1){

14.                    Toast.makeText(MainActivity.this, &quot;请用您的指尖盖住摄像头镜头！&quot;, Toast.LENGTH_SHORT).show();

15.                   hua[20]=0;}

16.                hua[20]++;

17.              return;}

18.           else

19.               hua[20]=10;

20.            j=0;

21.            

22.         }

23.        if(j&lt;20){

24.          addY=hua[j];

25.             j++;

26.         }

27.            

28.         //移除数据集中旧的点集

29.       mDataset.removeSeries(series);

30.  

31.      //判断当前点集中到底有多少点，因为屏幕总共只能容纳100个，所以当点数超过100时，长度永远是100

32.        int length = series.getItemCount();

33.        int bz=0;

34.         //addX = length;

35.       if (length &gt; 300) {

36.            length = 300;

37.           bz=1;

38.       }

39.        addX = length;

40.       //将旧的点集中x和y的数值取出来放入backup中，并且将x的值加1，造成曲线向右平移的效果

41.        for (int i = 0; i &lt; length; i++) {

42.           xv[i] = (int) series.getX(i) -bz;

43.          yv[i] = (int) series.getY(i);

44.      }

45.  

46.       //点集先清空，为了做成新的点集而准备

47.        series.clear();

48.      mDataset.addSeries(series);

49.      //将新产生的点首先加入到点集中，然后在循环体中将坐标变换后的一系列点都重新加入到点集中

50.       //这里可以试验一下把顺序颠倒过来是什么效果，即先运行循环体，再添加新产生的点

51.        series.add(addX, addY);

52.      for (int k = 0; k &lt; length; k++) {

53.           series.add(xv[k], yv[k]);

54.        }

55.        //在数据集中添加新的点集

56.      //mDataset.addSeries(series);

57.  

58.         //视图更新，没有这一步，曲线不会呈现动态

59.      //如果在非UI主线程中，需要调用postInvalidate()，具体参考api

60.      chart.invalidate();

61.  } //曲线
</code></pre><h5 id="7-相机预览回调方法previewCallback"><a href="#7-相机预览回调方法previewCallback" class="headerlink" title="(7)相机预览回调方法previewCallback"></a>(7)相机预览回调方法previewCallback</h5><p>这个方法中实现动态更新界面UI的功能，通过获取手机摄像头的参数来实时动态计算平均像素值、脉冲数，从而实时动态计算心率值。</p>
<p>具体代码实现如下：</p>
<pre><code>    1. /**

2.     * 相机预览方法

3.    * 这个方法中实现动态更新界面UI的功能，

4.   * 通过获取手机摄像头的参数来实时动态计算平均像素值、脉冲数，从而实时动态计算心率值。

5.     */

6.    private static PreviewCallback previewCallback = new PreviewCallback() {

7.        public void onPreviewFrame(byte[] data, Camera cam) {

8.           if (data == null)

9.                 throw new NullPointerException();

10.            Camera.Size size = cam.getParameters().getPreviewSize();

11.             if (size == null)

12.                throw new NullPointerException();

13.            if (!processing.compareAndSet(false, true))

14.                return;

15.            int width = size.width;

16.            int height = size.height;

17.          //图像处理

18.             int imgAvg = ImageProcessing.decodeYUV420SPtoRedAvg(data.clone(),height,width);

19.            gx=imgAvg;

20.           text1.setText(&quot;平均像素值是&quot;+String.valueOf(imgAvg));

21.             //像素平均值imgAvg,日志

22.           //Log.i(TAG, &quot;imgAvg=&quot; + imgAvg);

23.          if (imgAvg == 0 || imgAvg == 255) {

24.              processing.set(false);

25.                 return;

26.            }

27.            //计算平均值

28.            int averageArrayAvg = 0;

29.          int averageArrayCnt = 0;

30.          for (int i = 0; i &lt; averageArray.length; i++) {

31.              if (averageArray[i] &gt; 0) {

32.                     averageArrayAvg += averageArray[i];

33.                  averageArrayCnt++;

34.               }

35.            }

36.            //计算平均值

37.            int rollingAverage = (averageArrayCnt &gt; 0)?(averageArrayAvg/averageArrayCnt):0;

38.           TYPE newType = currentType;

39.          if (imgAvg &lt; rollingAverage) {

40.              newType = TYPE.RED;

41.              if (newType != currentType) {

42.                  beats++;

43.                     flag=0;

44.                     text2.setText(&quot;脉冲数是&quot;+String.valueOf(beats));

45.                    //Log.e(TAG, &quot;BEAT!! beats=&quot; + beats);

46.                 }

47.            } else if (imgAvg &gt; rollingAverage) {

48.                 newType = TYPE.GREEN;

49.            }

50.  

51.           if (averageIndex == averageArraySize)

52.              averageIndex = 0;

53.           averageArray[averageIndex] = imgAvg;

54.             averageIndex++;

55.  

56.             // Transitioned from one state to another to the same

57.          if (newType != currentType) {

58.              currentType = newType;

59.               //image.postInvalidate();

60.          }

61.            //获取系统结束时间（ms）

62.             long endTime = System.currentTimeMillis();

63.             double totalTimeInSecs = (endTime - startTime) / 1000d;

64.           if (totalTimeInSecs &gt;= 2) {

65.                double bps = (beats / totalTimeInSecs);

66.                int dpm = (int) (bps * 60d);

67.                if (dpm &lt; 30 || dpm &gt; 180||imgAvg&lt;200) {

68.                   //获取系统开始时间（ms）

69.                     startTime = System.currentTimeMillis();

70.                  //beats心跳总数

71.                    beats = 0;

72.                  processing.set(false);

73.                     return;

74.                }

75.                //Log.e(TAG, &quot;totalTimeInSecs=&quot; + totalTimeInSecs + &quot; beats=&quot;+ beats);

76.                 if (beatsIndex == beatsArraySize)

77.                  beatsIndex = 0;

78.                 beatsArray[beatsIndex] = dpm;

79.                beatsIndex++;

80.                int beatsArrayAvg = 0;

81.                int beatsArrayCnt = 0;

82.                for (int i = 0; i &lt; beatsArray.length; i++) {

83.                    if (beatsArray[i] &gt; 0) {

84.                       beatsArrayAvg += beatsArray[i];

85.                      beatsArrayCnt++;

86.                     }

87.                }

88.                int beatsAvg = (beatsArrayAvg / beatsArrayCnt);

89.                text.setText(&quot;您的的心率是&quot;+String.valueOf(beatsAvg)+&quot;  zhi:&quot;+String.valueOf(beatsArray.length)

90.                      +&quot;    &quot;+String.valueOf(beatsIndex)+&quot;    &quot;+String.valueOf(beatsArrayAvg)+&quot;    &quot;+String.valueOf(beatsArrayCnt));

91.                //获取系统时间（ms）

92.               startTime = System.currentTimeMillis();

93.              beats = 0;

94.          }

95.            processing.set(false);

96.         }

97.    };
</code></pre><h5 id="8-SurfaceHolder-Callback"><a href="#8-SurfaceHolder-Callback" class="headerlink" title="(8)SurfaceHolder.Callback"></a>(8)SurfaceHolder.Callback</h5><p>这个方法主要是相机摄像头，捕捉信息改变时调用。</p>
<p>具体代码实现如下：</p>
<pre><code>    1. /**

2.     * 预览回调接口

3.    */

4.    private static SurfaceHolder.Callback surfaceCallback = new SurfaceHolder.Callback() {

5.      //创建时调用

6.         @Override

7.      public void surfaceCreated(SurfaceHolder holder) {

8.            try {

9.               camera.setPreviewDisplay(previewHolder);

10.                 camera.setPreviewCallback(previewCallback);

11.          } catch (Throwable t) {

12.                Log.e(&quot;PreviewDemo-surfaceCallback&quot;,&quot;Exception in setPreviewDisplay()&quot;, t);

13.            }

14.        }

15.        //当预览改变的时候回调此方法

16.        @Override

17.         public void surfaceChanged(SurfaceHolder holder, int format, int width,int height) {

18.           Camera.Parameters parameters = camera.getParameters();

19.           parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);

20.             Camera.Size size = getSmallestPreviewSize(width, height, parameters);

21.            if (size != null) {

22.              parameters.setPreviewSize(size.width, size.height);

23.              //               Log.d(TAG, &quot;Using width=&quot; + size.width + &quot; height=&quot; + size.height);

24.           }

25.            camera.setParameters(parameters);

26.            camera.startPreview();

27.       }

28.        //销毁的时候调用

29.      @Override

30.         public void surfaceDestroyed(SurfaceHolder holder) {

31.             // Ignore

32.      }

33.    };
</code></pre><h5 id="9-获取相机最小的预览尺寸方法getSmallestPreviewSize"><a href="#9-获取相机最小的预览尺寸方法getSmallestPreviewSize" class="headerlink" title="(9)获取相机最小的预览尺寸方法getSmallestPreviewSize"></a>(9)获取相机最小的预览尺寸方法getSmallestPreviewSize</h5><p>这个方法的功能是获取当前手机相机最小的预览尺寸。</p>
<p>具体代码实现如下:</p>
<pre><code>    1. /**

2.      * 获取相机最小的预览尺寸

3.   * @param width

4.     * @param height

5.    * @param parameters

6.    * @return

7.      */

8.    private static Camera.Size getSmallestPreviewSize(int width, int height,

9.           Camera.Parameters parameters) {

10.       Camera.Size result = null;

11.         for (Camera.Size size : parameters.getSupportedPreviewSizes()) {

12.           if (size.width &lt;= width &amp;&amp; size.height &lt;= height) {

13.              if (result == null) {

14.                    result = size;

15.               } else {

16.                   int resultArea = result.width * result.height;

17.                     int newArea = size.width * size.height;

18.                    if (newArea &lt; resultArea)

19.                       result = size;

20.               }

21.            }

22.        }

23.        return result;

24.     }
</code></pre><h5 id="10-onCreate方法"><a href="#10-onCreate方法" class="headerlink" title="(10)onCreate方法"></a>(10)onCreate方法</h5><p>这个方法是Android原生自带的方法，通常在这个方法中我们会实现页面控件的初始化以及一些数据的初始化工作。我们这个项目中，主要是设置要显示的UI和调用initConfig方法来启动应用程序的配置，从而实现应用程序的顺利运行。</p>
<p>具体实现代码如下：</p>
<pre><code>    1. @Override

2.   public void onCreate(Bundle savedInstanceState) {

3.         super.onCreate(savedInstanceState);

4.         setContentView(R.layout.activity_main);

5.       initConfig();

6.     }
</code></pre><h5 id="11-其他一些Android原生自带方法"><a href="#11-其他一些Android原生自带方法" class="headerlink" title="(11)其他一些Android原生自带方法"></a>(11)其他一些Android原生自带方法</h5><pre><code>    1. @Override

2. public void onDestroy() {

3.   //当结束程序时关掉Timer

4.     timer.cancel();

5.   super.onDestroy();

6. };

7. @Override

8.  public void onConfigurationChanged(Configuration newConfig) {

9.     super.onConfigurationChanged(newConfig);

10. }

11.  

12. @Override

13. public void onResume() {

14.     super.onResume();

15.  wakeLock.acquire();

16.  camera = Camera.open();

17.  startTime = System.currentTimeMillis();

18. }

19.  

20. @Override

21. public void onPause() {

22.     super.onPause();

23.   wakeLock.release();

24.  camera.setPreviewCallback(null);

25.   camera.stopPreview();

26.    camera.release();

27.    camera = null;

28. }
</code></pre><h5 id="12-MainActivity完整代码"><a href="#12-MainActivity完整代码" class="headerlink" title="(12)MainActivity完整代码"></a>(12)MainActivity完整代码</h5><p>最后我还是给出MainActivity的完整代码吧，大家根据上面的分析仔细阅读几遍，便会体会这其中的奥妙了。嘿嘿，加油哦！</p>
<pre><code>    1. package com.lyz.xinlv.activity;

2. import java.util.Timer;

3. import java.util.TimerTask;

4. import java.util.concurrent.atomic.AtomicBoolean;

5.  

6. import org.achartengine.ChartFactory;

7. import org.achartengine.GraphicalView;

8. import org.achartengine.chart.PointStyle;

9. import org.achartengine.model.XYMultipleSeriesDataset;

10. import org.achartengine.model.XYSeries;

11. import org.achartengine.renderer.XYMultipleSeriesRenderer;

12. import org.achartengine.renderer.XYSeriesRenderer;

13.  

14. import android.app.Activity;

15. import android.content.Context;

16. import android.content.res.Configuration;

17. import android.graphics.Color;

18. import android.graphics.Paint.Align;

19. import android.hardware.Camera;

20. import android.hardware.Camera.PreviewCallback;

21. import android.os.Bundle;

22. import android.os.Handler;

23. import android.os.Message;

24. import android.os.PowerManager;

25. import android.os.PowerManager.WakeLock;

26. import android.util.Log;

27. import android.view.SurfaceHolder;

28. import android.view.SurfaceView;

29. import android.view.ViewGroup.LayoutParams;

30. import android.widget.LinearLayout;

31. import android.widget.TextView;

32. import android.widget.Toast;

33.  

34. import com.lyz.monitor.utils.ImageProcessing;

35.  

36. /**

37.  * 程序的主入口

38.  * @author liuyazhuang

39.  *

40.  */

41. public class MainActivity extends Activity {

42.  //曲线

43.   private Timer timer = new Timer();

44.   //Timer任务，与Timer配套使用

45.   private TimerTask task;

46.    private static int gx;

47.     private static int j;

48.  

49.     private static double flag=1;

50.     private Handler handler;

51.   private String title = &quot;pulse&quot;;

52.   private XYSeries series;

53.   private XYMultipleSeriesDataset mDataset;

54.  private GraphicalView chart;

55.   private XYMultipleSeriesRenderer renderer;

56.     private Context context;

57.   private int addX = -1;

58.  double addY;

59.   int[] xv = new int[300];

60.  int[] yv = new int[300];

61.  int[] hua=new int[]{9,10,11,12,13,14,13,12,11,10,9,8,7,6,7,8,9,10,11,10,10};

62.  

63.     //   private static final String TAG = &quot;HeartRateMonitor&quot;;

64.     private static final AtomicBoolean processing = new AtomicBoolean(false);

65.  //Android手机预览控件

66.    private static SurfaceView preview = null;

67.     //预览设置信息

68.   private static SurfaceHolder previewHolder = null;

69.     //Android手机相机句柄

70.    private static Camera camera = null;

71.   //private static View image = null;

72.    private static TextView text = null;

73.   private static TextView text1 = null;

74.  private static TextView text2 = null;

75.  private static WakeLock wakeLock = null;

76.   private static int averageIndex = 0;

77.  private static final int averageArraySize = 4;

78.  private static final int[] averageArray = new int[averageArraySize];

79.  

80.    /**

81.    * 类型枚举

82.     * @author liuyazhuang

83.     *

84.      */

85.   public static enum TYPE {

86.      GREEN, RED

87.   };

88.   //设置默认类型

89.   private static TYPE currentType = TYPE.GREEN;

90.    //获取当前类型

91.   public static TYPE getCurrent() {

92.        return currentType;

93.    }

94.    //心跳下标值

95.    private static int beatsIndex = 0;

96.    //心跳数组的大小

97.  private static final int beatsArraySize = 3;

98.    //心跳数组

99.     private static final int[] beatsArray = new int[beatsArraySize];

100.    //心跳脉冲

101.    private static double beats = 0;

102.     //开始时间

103.    private static long startTime = 0;

104.  

105.     @Override

106.    public void onCreate(Bundle savedInstanceState) {

107.       super.onCreate(savedInstanceState);

108.       setContentView(R.layout.activity_main);

109.         initConfig();

110.   }

111.  

112.     /**

113.   * 初始化配置

114.   */

115.  private void initConfig() {

116.         //曲线

117.      context = getApplicationContext();

118.  

119.        //这里获得main界面上的布局，下面会把图表画在这个布局里面

120.       LinearLayout layout = (LinearLayout)findViewById(R.id.linearLayout1);

121.  

122.         //这个类用来放置曲线上的所有点，是一个点的集合，根据这些点画出曲线

123.        series = new XYSeries(title);

124.  

125.       //创建一个数据集的实例，这个数据集将被用来创建图表

126.        mDataset = new XYMultipleSeriesDataset();

127.  

128.       //将点集添加到这个数据集中

129.        mDataset.addSeries(series);

130.  

131.       //以下都是曲线的样式和属性等等的设置，renderer相当于一个用来给图表做渲染的句柄

132.      int color = Color.GREEN;

133.      PointStyle style = PointStyle.CIRCLE;

134.       renderer = buildRenderer(color, style, true);

135.  

136.       //设置好图表的样式

137.        setChartSettings(renderer, &quot;X&quot;, &quot;Y&quot;, 0, 300, 4, 16, Color.WHITE, Color.WHITE);

138.  

139.      //生成图表

140.        chart = ChartFactory.getLineChartView(context, mDataset, renderer);

141.  

142.       //将图表添加到布局中去

143.      layout.addView(chart, new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));

144.  

145.        //这里的Handler实例将配合下面的Timer实例，完成定时更新图表的功能

146.       handler = new Handler() {

147.             @Override

148.            public void handleMessage(Message msg) {

149.                //               刷新图表

150.                 updateChart();

151.              super.handleMessage(msg);

152.             }

153.       };

154.  

155.        task = new TimerTask() {

156.          @Override

157.            public void run() {

158.                 Message message = new Message();

159.              message.what = 1;

160.              handler.sendMessage(message);

161.           }

162.       };

163.  

164.        timer.schedule(task, 1,20);           //曲线

165.      //获取SurfaceView控件

166.         preview = (SurfaceView) findViewById(R.id.preview);

167.         previewHolder = preview.getHolder();

168.        previewHolder.addCallback(surfaceCallback);

169.         previewHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);

170.         //       image = findViewById(R.id.image);

171.        text = (TextView) findViewById(R.id.text);

172.      text1 = (TextView) findViewById(R.id.text1);

173.        text2 = (TextView) findViewById(R.id.text2);

174.        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);

175.       wakeLock = pm.newWakeLock(PowerManager.FULL_WAKE_LOCK, &quot;DoNotDimScreen&quot;);

176.  }

177.  

178.     //   曲线

179.   @Override

180.    public void onDestroy() {

181.       //当结束程序时关掉Timer

182.       timer.cancel();

183.         super.onDestroy();

184.    };

185.  

186.    /**

187.   * 创建图表

188.    * @param color

189.   * @param style

190.   * @param fill

191.    * @return

192.    */

193.  protected XYMultipleSeriesRenderer buildRenderer(int color, PointStyle style, boolean fill) {

194.         XYMultipleSeriesRenderer renderer = new XYMultipleSeriesRenderer();

195.  

196.         //设置图表中曲线本身的样式，包括颜色、点的大小以及线的粗细等

197.       XYSeriesRenderer r = new XYSeriesRenderer();

198.      r.setColor(Color.RED);

199. //        r.setPointStyle(null);

200. //     r.setFillPoints(fill);

201.       r.setLineWidth(1);

202.         renderer.addSeriesRenderer(r);

203.      return renderer;

204.  }

205.  

206.     /**

207.   * 设置图标的样式

208.     * @param renderer

209.    * @param xTitle：x标题

210.      * @param yTitle：y标题

211.      * @param xMin：x最小长度

212.      * @param xMax：x最大长度

213.      * @param yMin:y最小长度

214.      * @param yMax：y最大长度

215.      * @param axesColor：颜色

216.    * @param labelsColor：标签

217.      */

218.  protected void setChartSettings(XYMultipleSeriesRenderer renderer, String xTitle, String yTitle,

219.            double xMin, double xMax, double yMin, double yMax, int axesColor, int labelsColor) {

220.       //有关对图表的渲染可参看api文档

221.        renderer.setChartTitle(title);

222.      renderer.setXTitle(xTitle);

223.         renderer.setYTitle(yTitle);

224.         renderer.setXAxisMin(xMin);

225.         renderer.setXAxisMax(xMax);

226.         renderer.setYAxisMin(yMin);

227.         renderer.setYAxisMax(yMax);

228.         renderer.setAxesColor(axesColor);

229.       renderer.setLabelsColor(labelsColor);

230.       renderer.setShowGrid(true);

231.       renderer.setGridColor(Color.GREEN);

232.         renderer.setXLabels(20);

233.       renderer.setYLabels(10);

234.       renderer.setXTitle(&quot;Time&quot;);

235.        renderer.setYTitle(&quot;mmHg&quot;);

236.        renderer.setYLabelsAlign(Align.RIGHT);

237.      renderer.setPointSize((float) 3 );

238.       renderer.setShowLegend(false);

239.    }

240.  

241.     /**

242.   * 更新图标信息

243.      */

244.  private void updateChart() {

245.  

246.      //设置好下一个需要增加的节点

247.       if(flag==1)

248.          addY=10;

249.       else{

250. //           addY=250;

251.            flag=1;

252.            if(gx&lt;200){

253.               if(hua[20]&gt;1){

254.                   Toast.makeText(MainActivity.this, &quot;请用您的指尖盖住摄像头镜头！&quot;, Toast.LENGTH_SHORT).show();

255.                  hua[20]=0;}

256.               hua[20]++;

257.                 return;}

258.          else

259.              hua[20]=10;

260.           j=0;

261.           

262.        }

263.       if(j&lt;20){

264.             addY=hua[j];

265.            j++;

266.        }

267.           

268.        //移除数据集中旧的点集

269.      mDataset.removeSeries(series);

270.  

271.        //判断当前点集中到底有多少点，因为屏幕总共只能容纳100个，所以当点数超过100时，长度永远是100

272.       int length = series.getItemCount();

273.       int bz=0;

274.        //addX = length;

275.      if (length &gt; 300) {

276.           length = 300;

277.          bz=1;

278.      }

279.       addX = length;

280.      //将旧的点集中x和y的数值取出来放入backup中，并且将x的值加1，造成曲线向右平移的效果

281.       for (int i = 0; i &lt; length; i++) {

282.          xv[i] = (int) series.getX(i) -bz;

283.             yv[i] = (int) series.getY(i);

284.         }

285.  

286.         //点集先清空，为了做成新的点集而准备

287.       series.clear();

288.         mDataset.addSeries(series);

289.         //将新产生的点首先加入到点集中，然后在循环体中将坐标变换后的一系列点都重新加入到点集中

290.      //这里可以试验一下把顺序颠倒过来是什么效果，即先运行循环体，再添加新产生的点

291.       series.add(addX, addY);

292.         for (int k = 0; k &lt; length; k++) {

293.          series.add(xv[k], yv[k]);

294.       }

295.       //在数据集中添加新的点集

296.         //mDataset.addSeries(series);

297.  

298.       //视图更新，没有这一步，曲线不会呈现动态

299.         //如果在非UI主线程中，需要调用postInvalidate()，具体参考api

300.         chart.invalidate();

301.     } //曲线

302.  

303.  

304.    @Override

305.    public void onConfigurationChanged(Configuration newConfig) {

306.       super.onConfigurationChanged(newConfig);

307.  }

308.  

309.     @Override

310.    public void onResume() {

311.        super.onResume();

312.         wakeLock.acquire();

313.         camera = Camera.open();

314.         startTime = System.currentTimeMillis();

315.     }

316.  

317.     @Override

318.    public void onPause() {

319.         super.onPause();

320.      wakeLock.release();

321.         camera.setPreviewCallback(null);

322.      camera.stopPreview();

323.       camera.release();

324.       camera = null;

325.    }

326.   

327.    

328.    /**

329.   * 相机预览方法

330.      * 这个方法中实现动态更新界面UI的功能，

331.     * 通过获取手机摄像头的参数来实时动态计算平均像素值、脉冲数，从而实时动态计算心率值。

332.   */

333.  private static PreviewCallback previewCallback = new PreviewCallback() {

334.      public void onPreviewFrame(byte[] data, Camera cam) {

335.             if (data == null)

336.               throw new NullPointerException();

337.           Camera.Size size = cam.getParameters().getPreviewSize();

338.            if (size == null)

339.               throw new NullPointerException();

340.           if (!processing.compareAndSet(false, true))

341.               return;

342.           int width = size.width;

343.           int height = size.height;

344.             //图像处理

345.            int imgAvg = ImageProcessing.decodeYUV420SPtoRedAvg(data.clone(),height,width);

346.           gx=imgAvg;

347.          text1.setText(&quot;平均像素值是&quot;+String.valueOf(imgAvg));

348.            //像素平均值imgAvg,日志

349.          //Log.i(TAG, &quot;imgAvg=&quot; + imgAvg);

350.             if (imgAvg == 0 || imgAvg == 255) {

351.                 processing.set(false);

352.                return;

353.           }

354.           //计算平均值

355.           int averageArrayAvg = 0;

356.             int averageArrayCnt = 0;

357.             for (int i = 0; i &lt; averageArray.length; i++) {

358.                 if (averageArray[i] &gt; 0) {

359.                    averageArrayAvg += averageArray[i];

360.                     averageArrayCnt++;

361.              }

362.           }

363.           //计算平均值

364.           int rollingAverage = (averageArrayCnt &gt; 0)?(averageArrayAvg/averageArrayCnt):0;

365.          TYPE newType = currentType;

366.             if (imgAvg &lt; rollingAverage) {

367.                 newType = TYPE.RED;

368.                 if (newType != currentType) {

369.                     beats++;

370.                    flag=0;

371.                    text2.setText(&quot;脉冲数是&quot;+String.valueOf(beats));

372.                   //Log.e(TAG, &quot;BEAT!! beats=&quot; + beats);

373.                }

374.           } else if (imgAvg &gt; rollingAverage) {

375.                newType = TYPE.GREEN;

376.           }

377.  

378.             if (averageIndex == averageArraySize)

379.                 averageIndex = 0;

380.          averageArray[averageIndex] = imgAvg;

381.            averageIndex++;

382.  

383.           // Transitioned from one state to another to the same

384.             if (newType != currentType) {

385.                 currentType = newType;

386.              //image.postInvalidate();

387.             }

388.           //获取系统结束时间（ms）

389.            long endTime = System.currentTimeMillis();

390.            double totalTimeInSecs = (endTime - startTime) / 1000d;

391.          if (totalTimeInSecs &gt;= 2) {

392.               double bps = (beats / totalTimeInSecs);

393.               int dpm = (int) (bps * 60d);

394.               if (dpm &lt; 30 || dpm &gt; 180||imgAvg&lt;200) {

395.                  //获取系统开始时间（ms）

396.                    startTime = System.currentTimeMillis();

397.                     //beats心跳总数

398.                   beats = 0;

399.                     processing.set(false);

400.                    return;

401.               }

402.               //Log.e(TAG, &quot;totalTimeInSecs=&quot; + totalTimeInSecs + &quot; beats=&quot;+ beats);

403.                if (beatsIndex == beatsArraySize)

404.                     beatsIndex = 0;

405.                beatsArray[beatsIndex] = dpm;

406.               beatsIndex++;

407.               int beatsArrayAvg = 0;

408.               int beatsArrayCnt = 0;

409.               for (int i = 0; i &lt; beatsArray.length; i++) {

410.                   if (beatsArray[i] &gt; 0) {

411.                      beatsArrayAvg += beatsArray[i];

412.                         beatsArrayCnt++;

413.                    }

414.               }

415.               int beatsAvg = (beatsArrayAvg / beatsArrayCnt);

416.               text.setText(&quot;您的的心率是&quot;+String.valueOf(beatsAvg)+&quot;  zhi:&quot;+String.valueOf(beatsArray.length)

417.                         +&quot;    &quot;+String.valueOf(beatsIndex)+&quot;    &quot;+String.valueOf(beatsArrayAvg)+&quot;    &quot;+String.valueOf(beatsArrayCnt));

418.               //获取系统时间（ms）

419.              startTime = System.currentTimeMillis();

420.                 beats = 0;

421.             }

422.           processing.set(false);

423.        }

424.   };

425.  

426.    /**

427.   * 预览回调接口

428.      */

429.  private static SurfaceHolder.Callback surfaceCallback = new SurfaceHolder.Callback() {

430.        //创建时调用

431.       @Override

432.        public void surfaceCreated(SurfaceHolder holder) {

433.          try {

434.                 camera.setPreviewDisplay(previewHolder);

435.                camera.setPreviewCallback(previewCallback);

436.             } catch (Throwable t) {

437.               Log.e(&quot;PreviewDemo-surfaceCallback&quot;,&quot;Exception in setPreviewDisplay()&quot;, t);

438.           }

439.       }

440.       //当预览改变的时候回调此方法

441.       @Override

442.        public void surfaceChanged(SurfaceHolder holder, int format, int width,int height) {

443.          Camera.Parameters parameters = camera.getParameters();

444.          parameters.setFlashMode(Camera.Parameters.FLASH_MODE_TORCH);

445.            Camera.Size size = getSmallestPreviewSize(width, height, parameters);

446.           if (size != null) {

447.                 parameters.setPreviewSize(size.width, size.height);

448.                 //               Log.d(TAG, &quot;Using width=&quot; + size.width + &quot; height=&quot; + size.height);

449.          }

450.           camera.setParameters(parameters);

451.           camera.startPreview();

452.      }

453.       //销毁的时候调用

454.         @Override

455.        public void surfaceDestroyed(SurfaceHolder holder) {

456.            // Ignore

457.         }

458.   };

459.  

460.    /**

461.   * 获取相机最小的预览尺寸

462.     * @param width

463.   * @param height

464.      * @param parameters

465.      * @return

466.    */

467.  private static Camera.Size getSmallestPreviewSize(int width, int height,

468.             Camera.Parameters parameters) {

469.      Camera.Size result = null;

470.        for (Camera.Size size : parameters.getSupportedPreviewSizes()) {

471.          if (size.width &lt;= width &amp;&amp; size.height &lt;= height) {

472.                 if (result == null) {

473.                   result = size;

474.              } else {

475.                  int resultArea = result.width * result.height;

476.                    int newArea = size.width * size.height;

477.                   if (newArea &lt; resultArea)

478.                      result = size;

479.              }

480.           }

481.       }

482.       return result;

483.    }

484. }
</code></pre><h4 id="3、UI布局"><a href="#3、UI布局" class="headerlink" title="3、UI布局"></a>3、UI布局</h4><p>这里就不多说了，对于UI布局的实现，相信大家看了源码都懂得。</p>
<p>具体代码实现如下：</p>
<pre><code>    1. &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

2.     xmlns:tools=&quot;http://schemas.android.com/tools&quot;

3.     android:layout_width=&quot;match_parent&quot;

4.     android:layout_height=&quot;match_parent&quot;

5.     android:orientation=&quot;vertical&quot; &gt;

6.  

7.     &lt;SurfaceView

8.         android:id=&quot;@+id/preview&quot;

9.         android:layout_width=&quot;fill_parent&quot;

10.         android:layout_height=&quot;200dp&quot;

11.         android:layout_marginLeft=&quot;50dip&quot;

12.         android:layout_marginRight=&quot;50dip&quot; /&gt;

13.  

14.     &lt;LinearLayout

15.         android:id=&quot;@+id/linearLayout1&quot;

16.         android:layout_width=&quot;match_parent&quot;

17.         android:layout_height=&quot;200dp&quot;

18.         android:orientation=&quot;vertical&quot; &gt;

19.     &lt;/LinearLayout&gt;

20.  

21.     &lt;TextView

22.         android:id=&quot;@+id/text&quot;

23.         android:layout_width=&quot;wrap_content&quot;

24.         android:layout_height=&quot;wrap_content&quot;

25.         android:layout_marginLeft=&quot;50dip&quot;

26.         android:layout_weight=&quot;1&quot;

27.         android:text=&quot;@string/show&quot; &gt;

28.     &lt;/TextView&gt;

29.  

30.     &lt;TextView

31.         android:id=&quot;@+id/text1&quot;

32.         android:layout_width=&quot;wrap_content&quot;

33.         android:layout_height=&quot;wrap_content&quot;

34.         android:layout_marginLeft=&quot;50dip&quot;

35.         android:layout_weight=&quot;1&quot;

36.         android:text=&quot;@string/show&quot; &gt;

37.     &lt;/TextView&gt;

38.  

39.     &lt;TextView

40.         android:id=&quot;@+id/text2&quot;

41.         android:layout_width=&quot;wrap_content&quot;

42.         android:layout_height=&quot;wrap_content&quot;

43.         android:layout_marginLeft=&quot;50dip&quot;

44.         android:layout_weight=&quot;1&quot;

45.         android:text=&quot;@string/show&quot; &gt;

46.     &lt;/TextView&gt;

47.  

48. &lt;/LinearLayout&gt;
</code></pre><h4 id="4、strings-xml"><a href="#4、strings-xml" class="headerlink" title="4、strings.xml"></a>4、strings.xml</h4><pre><code>    1. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

2. &lt;resources&gt;

3.  

4.     &lt;string name=&quot;app_name&quot;&gt;心率检测&lt;/string&gt;

5.     &lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt;

6.     &lt;string name=&quot;hello_world&quot;&gt;Hello world!&lt;/string&gt;

7.     &lt;string name=&quot;show&quot;&gt;显示&lt;/string&gt;

8. &lt;/resources&gt;
</code></pre><h4 id="5、授权AndroidManifest-xml"><a href="#5、授权AndroidManifest-xml" class="headerlink" title="5、授权AndroidManifest.xml"></a>5、授权AndroidManifest.xml</h4><p>最后，我把授权文件贴出来吧。</p>
<p>具体代码实现如下：</p>
<pre><code>    1. &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

2. &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;

3.     package=&quot;com.lyz.xinlv.activity&quot;

4.     android:versionCode=&quot;1&quot;

5.     android:versionName=&quot;1.0&quot; &gt;

6.  

7.     &lt;uses-sdk

8.         android:minSdkVersion=&quot;15&quot;

9.         android:targetSdkVersion=&quot;15&quot; /&gt;

10.     &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt;

11.     &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;

12.     &lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;

13.     &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;

14.  

15.     &lt;application

16.         android:allowBackup=&quot;true&quot;

17.         android:icon=&quot;@drawable/ic_launcher&quot;

18.         android:label=&quot;@string/app_name&quot;

19.         android:theme=&quot;@style/AppTheme&quot; &gt;

20.         &lt;activity

21.             android:name=&quot;com.lyz.xinlv.activity.MainActivity&quot;

22.             android:label=&quot;@string/app_name&quot; &gt;

23.             &lt;intent-filter&gt;

24.                 &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

25.  

26.                 &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;

27.             &lt;/intent-filter&gt;

28.         &lt;/activity&gt;

29.     &lt;/application&gt;

30.  

31. &lt;/manifest&gt;
</code></pre><p>至此，这个应用开发完成，亲们，是不是比想象的简单呢？  </p>
<h3 id="三、运行效果"><a href="#三、运行效果" class="headerlink" title="三、运行效果"></a>三、运行效果</h3><p><img src="https://img-
blog.csdn.net/20150731150731132?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><img src="https://img-
blog.csdn.net/20150731150909022?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>
<p><img src="https://img-
blog.csdn.net/20150731151115964?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><img src="https://img-
blog.csdn.net/20150731151054385?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p><img src="https://img-
blog.csdn.net/20150731151739678?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h3 id="四、温馨提示"><a href="#四、温馨提示" class="headerlink" title="四、温馨提示"></a>四、温馨提示</h3><p>本实例中，为了方面，我把一些文字直接写在了布局文件中和相关的类中，大家在真实的项目中要把这些文字写在string.xml文件中，在外部引用这些资源，切记，这是作为一个Android程序员最基本的开发常识和规范，我在这里只是为了方便直接写在了类和布局文件中。</p>
<p>大家可以到链接 <a href="http://download.csdn.net/detail/l1028386804/8949597" target="_blank" rel="noopener"> http://download.csdn.net/detail/l1028386804/8949597
</a> 获取完整模拟实现检测心率变化的应用源代码  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/07/28/Gson自定义序列化与反序列化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/28/Gson自定义序列化与反序列化/" itemprop="url">Gson自定义序列化与反序列化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-28T12:49:42+08:00">
                2018-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用Gson的时候我们经常需要根据自己的需求定义序列化和反序列化的规则，本文主要讲解如何优雅地进行Gson的序列化和反序列化。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>实现 <code>JsonSerializer</code> 接口 </li>
<li>注册自定义的序列化实现 </li>
</ul>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><ul>
<li>自定义UserInformationBeanSerializer并实现JsonSerializer接口 </li>
</ul>
<pre><code>public class UserInformationBeanSerializer implements JsonSerializer&lt;UserInformationBean&gt; {
    @Override
    public JsonElement serialize(UserInformationBean userInformationBean, Type type, JsonSerializationContext jsonSerializationContext) {
        JsonObject Server = new JsonObject();
        JsonObject data = new JsonObject();


        data.addProperty(&quot;report&quot;, getReport(userInformationBean));
        data.addProperty(&quot;time&quot;, getTimeStr());

        JsonObject pollData = new JsonObject();
        data.add(&quot;pollData&quot;, pollData);


        JsonObject basicData = new JsonObject();
        basicData.addProperty(&quot;gender&quot;, userInformationBean.getSex().ordinal() + &quot;&quot;);
        basicData.addProperty(&quot;payWay&quot;, &quot;0&quot;);


        data.add(&quot;basicData&quot;, basicData);
        Server.add(&quot;data&quot;, data);

        return Server;

    }



}
</code></pre><ul>
<li><p>注册自定义的UserInformationBeanSerializer </p>
<pre><code>UserInformationBeanSerializer userInformationBeanSerializer = new                     UserInformationBeanSerializer();
</code></pre><p>Type IntListType = new TypeToken<userinformationbean>() {}.getType();</userinformationbean></p>
<p>GsonBuilder builder = new GsonBuilder();<br>builder.registerTypeAdapter(IntListType, userInformationBeanSerializer);</p>
<p>Gson gson = builder.create();</p>
<p>String datacontent = gson.toJson(userInformationBean);</p>
</li>
</ul>
<h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><ul>
<li>实现 <code>JsonDeserializer</code> 接口 </li>
<li>注册自定义的反序列化实现 </li>
</ul>
<h3 id="demo-1"><a href="#demo-1" class="headerlink" title="demo"></a>demo</h3><ul>
<li><p>自定义TcmJsonBeanDeserializer并实现JsonDeserializer接口 </p>
<pre><code>public class TcmJsonBeanDeserializer implements JsonDeserializer&lt;TcmJsonBean&gt; {
</code></pre><p>  @Override<br>  public TcmJsonBean deserialize(JsonElement jsonElement, Type type, JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {</p>
</li>
</ul>
<pre><code>      JsonObject jsonObject = jsonElement.getAsJsonObject();
      TcmJsonBean tcmJsonBean = new TcmJsonBean();

      if (jsonObject.has(&quot;代茶饮&quot;)) {
          tcmJsonBean.setDaiChaYin(jsonObject.get(&quot;代茶饮&quot;).getAsString());
      }

      if (jsonObject.has(&quot;体质类型&quot;)) {
          tcmJsonBean.setDaiChaYin(jsonObject.get(&quot;体质类型&quot;).getAsString());
      }

      if (jsonObject.has(&quot;穴位按摩&quot;)) {
          tcmJsonBean.setDaiChaYin(jsonObject.get(&quot;穴位按摩&quot;).getAsString());
      }

      if (jsonObject.has(&quot;运动&quot;)) {
          tcmJsonBean.setDaiChaYin(jsonObject.get(&quot;运动&quot;).getAsString());
      }

      if (jsonObject.has(&quot;食疗&quot;)) {
          tcmJsonBean.setDaiChaYin(jsonObject.get(&quot;食疗&quot;).getAsString());
      }


      return null;
  }
}
</code></pre><ul>
<li>注册自定义的反序列化实现 </li>
</ul>
<pre><code>String json = readFileToStringUtil.ReadJsonToString(filename);
       Gson gson = new Gson();
       List&lt;JsonElement&gt; list = new ArrayList();
       JsonParser jsonParser = new JsonParser();
       JsonElement jsonElement = jsonParser.parse(json);  //将json字符串转换成JsonElement
       JsonArray jsonArray = jsonElement.getAsJsonArray();  //将JsonElement转换成JsonArray
       Iterator it = jsonArray.iterator();  //Iterator处理
       tcmJsonBeans = new ArrayList&lt;TcmJsonBean&gt;();

       while (it.hasNext()) {  //循环
           jsonElement = (JsonElement) it.next(); //提取JsonElement
           json = jsonElement.toString();  //JsonElement转换成String
           TcmJsonBean questionInJsonBean = gson.fromJson(json, TcmJsonBean.class); //String转化成JavaBean
           tcmJsonBeans.add(questionInJsonBean);
       }
       return tcmJsonBeans;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/07/27/使用gradle打包指定类为jar包的方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/27/使用gradle打包指定类为jar包的方法/" itemprop="url">使用gradle打包指定类为jar包的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T13:04:22+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Android studio中通过gralde脚本打包指定类的为jar包的示例脚本：</p>
<h2 id="打包某个包下的所有文件"><a href="#打包某个包下的所有文件" class="headerlink" title="打包某个包下的所有文件"></a>打包某个包下的所有文件</h2><pre><code>task clearJar(type: Delete) { 
    delete &apos;libs/sdk.jar&apos; 
} 

task makeJar(type:org.gradle.api.tasks.bundling.Jar) {
    //指定生成的jar名
    baseName &apos;sdk&apos;
    //从哪里打包class文件
    from(&apos;build/intermediates/classes/debug/org/cmdmac/cloud/pluginsdk/&apos;)
    //打包到jar后的目录结构 
    into(&apos;org/cmdmac/cloud/pluginsdk/&apos;)
    //去掉不需要打包的目录和文件 
    exclude(&apos;test/&apos;, &apos;BuildConfig.class&apos;, &apos;R.class&apos;)
    //去掉R$开头的文件 
    exclude{ it.name.startsWith(&apos;R$&apos;);} 
} 

makeJar.dependsOn(clearJar, build)
</code></pre><p>在build.gradle写上后，只要在命令行执行gradle makeJar就可以在build/libs目录下找到这个jar。</p>
<p>上面是个简单的例子，只能打包某个包下面的所有文件，如果要实现只打某个包下面的某些子包或者文件可参考如下示例</p>
<pre><code>task makeSdkJar(type:org.gradle.api.tasks.bundling.Jar) {
    baseName &apos;pluginsdk&apos;
    //只打包org.cmdmac下的org.cmdmac.pluginsdk.impl和org.cmdmac.gamecenter,其他子包不会被打包进去
    from(&apos;build/intermediates/classes/debug/org/cmdmac/&apos;) {
        include &apos;pluginsdk/impl&apos;
        include &apos;gamecenter&apos;
    }
    into(&apos;org/cmdmac/&apos;)
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/07/27/Android控件设置透明度的三种方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/27/Android控件设置透明度的三种方法/" itemprop="url">Android控件设置透明度的三种方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-27T12:39:59+08:00">
                2018-07-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>有时会需要改变布局颜色透明度，比如设置控件（如View,Button等）的透明度，有3种方法。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h3><pre><code>text = (TextView) findViewById(R.id.text);
text.getBackground().setAlpha(12);
</code></pre><p>setAlpha()的括号中可以填0–255之间的数字。数字越大，越不透明。</p>
<p>注意点：在5.0以上系统时，有些机型会出现莫名其妙的颜色值不起作用，变成透明了，也就是用此方法会导致其他共用一个资源的布局（例如：@color/white）透明度也跟着改变。<br>比如text用上述方法设置成透明后，项目中，其他用到text颜色值的控件，都变成透明了。<br>原因：在布局中多个控件同时使用一个资源的时候，这些控件会共用一个状态，例如ColorState，如果你改变了一个控件的状态，其他的控件都会接收到相同的通知。这时我们可以使用mutate()方法使该控件状态不定，这样不定状态的控件就不会共享自己的状态了。</p>
<pre><code>text.getBackground().mutate().setAlpha(12);
</code></pre><h3 id="在xml布局中进行设置"><a href="#在xml布局中进行设置" class="headerlink" title="在xml布局中进行设置"></a>在xml布局中进行设置</h3><pre><code>&lt;TextView
      android:id=&quot;@+id/text&quot;
      android:text=&quot;Hello World!&quot;
      android:background=&quot;#987654&quot;
      android:layout_width=&quot;match_parent&quot;
      android:alpha=&quot;0.5&quot;
      android:layout_height=&quot;100dp&quot; /&gt;
</code></pre><p>android:alpha的值为0~1之间的数。数字越大，越不透明。1表示完全不透明，0表示完全透明。</p>
<h3 id="在xml布局中通过android-background设置"><a href="#在xml布局中通过android-background设置" class="headerlink" title="在xml布局中通过android:background设置"></a>在xml布局中通过android:background设置</h3><pre><code>&lt;TextView
        android:id=&quot;@+id/text&quot;
        android:text=&quot;Hello World!&quot;
        android:background=&quot;#80987654&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;100dp&quot; /&gt;123456
</code></pre><p>颜色和不透明度 (alpha) 值以十六进制表示法表示。任何一种颜色的值范围都是 0 到 255(00 到 ff)。对于 alpha，00<br>表示完全透明，ff<br>表示完全不透明。android:background的值的格式为”#AARRGGBB”。AA即透明度，R、G、B是红绿蓝三色。每一位均为0–F的十六位数。其中透明度的数值越大，越不透明。因此这里如果想设置透明度为50%的白色的话，可以如上设置。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
