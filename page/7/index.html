<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="DmrfCoder的个人主页">
<meta property="og:url" content="http://www.mashangxue123.com/page/7/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DmrfCoder的个人主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/page/7/">





  <title>DmrfCoder的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/07/回溯算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/回溯算法/" itemprop="url">回溯算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T17:19:42+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>回溯算法是一种组织搜索的一般技术，它常常可以避免搜索所有的可能性，适用于求解那些有潜在的大量解但是有限个数的解已经检查过的问题。</p>
<h1 id="3着色问题"><a href="#3着色问题" class="headerlink" title="3着色问题"></a>3着色问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给出一个无向图G=(V,E)，需要用三种颜色之一为V中的每个顶点着色，要求没有两个相邻的顶点有相同的颜色。</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>我们称没有两个邻接顶点有同样颜色的着色方案为合法的，反之成为非法的。如果不考虑合法性的要求，给出n个顶点的无向图，将其用三种颜色着色，共有n^3种不同的方法，因为没一个顶点都有三种不同的着色方案，这就构成了一颗三叉树，如图：<br><img src="https://img-
blog.csdn.net/20180505141608137?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在该三叉树中，从根到叶子节点的每一条路径代表一种着色方法（合法的和不合法的），我们需要做的就是选出一条合法的从根到叶子的路径即可。所以我们从跟节点开始向叶子节点走，这时有两种情况：</p>
<ul>
<li><p>从根到当前节点的路径对应一个合法的着色：   </p>
<ul>
<li>当前路径长度小于n：过程终止（除非希望找到不止一种着色方案） </li>
<li>当前路径长度等于n：生成当前节点的一个子节点，并将生成的当前节点的子节点标记为新的当前节点 </li>
</ul>
</li>
<li>从根到当前节点的路径对应一个非法的着色：回溯到当前节点的父节点即将当前节点的父节点标记为新的当前节点 </li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用数组c[1…n]代表图的顶点集合，判断合法性只需判断与当前有联系的点中是否存在与之涂色相同的点即可，此处为节省时间省略该部分代码的实现。</p>
<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><pre><code>void ColorItre(int *c) {//c[1...n]
    for (int i = 1; i &lt;= n; ++i) {
        c[i] = 0;
    }
    bool flag = false;
    int k = 1;
    while (k &gt;= 1) {
        while (c[k] &lt;= 2) {
            c[k] = c[k] + 1;
            if (c[k]为合法的){
                if (k == n) {
                    flag = true;
                    break;
                } else {
                    k++;
                }

            }
        }

        if (flag) {
            break;
        }

        //如果第二个循环跳出执行到这里，则说明当前节点k试遍了三种颜色仍然没有找到合法的着色，则将k--进行回溯，注意要将c[k]置为初始值0
        c[k] = 0;
        k--;
    }

    if (flag) {
        cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl;
    }

}
</code></pre><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><pre><code>void ColorRec(int *c) {//c[1...n]
    for (int i = 1; i &lt;= n; ++i) {
        c[i] = 0;
    }

    bool flag = false;
    flag = graphcolor(c, 1);
    if (flag) {
        cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl;
    }
}

bool graphcolor(int *c, int i) {
    for (int color = 1; color &lt;= 3; ++color) {
        c[i] = color;
        if (c[i]是合法的){
            if (i &lt; n) {
                graphcolor(c, i + 1);
            } else {
                return true;
            }
        }
    }
    //如果执行到这里说明当前节点不存在合法着色，需要回溯，返回false即可激活前一次递归（即让前一层for循环的color加一），以此达到回溯的目的
    return false;
}
</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>这两种实现方式在最坏情况下生成了O(3^n)个节点，对于每个生成的节点，判断当前节点的合法性（合法、部分、二者都不是）需要O(n)的工作来检查，因此，最坏情况下的运行时间是O(n3^n)。</p>
<h2 id="回溯法的特点"><a href="#回溯法的特点" class="headerlink" title="回溯法的特点"></a>回溯法的特点</h2><ul>
<li>节点是使用深度优先搜索算法生成的 </li>
<li>不需要存储整棵搜索树，只需存储根到当前活动节点的路径 </li>
</ul>
<h1 id="8皇后问题"><a href="#8皇后问题" class="headerlink" title="8皇后问题"></a>8皇后问题</h1><p>代码见 <a href="https://blog.csdn.net/qq_36982160/article/details/78585680" target="_blank" rel="noopener"> 两种不同方式解决八皇后问题
</a> ，此处主要介绍算法思路。</p>
<h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8<br>的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当<br>n = 1 或 n ≥ 4 时问题有解。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>代码和着色问题代码几乎一样，这里不做过多介绍，给出参考代码：</p>
<pre><code>void eight_Queens() {
    int c[9];
    for (int i = 1; i &lt;= 8; ++i) {
        c[i] = 0;
    }

    bool flag = false;
    int k = 1;
    while (k &gt;= 1) {
        while (c[k] &lt;= 7) {
            c[k]++;
            if (c[k]为合法着色){
                if (k == 8) {
                    flag = true;
                    break;
                } else {
                    k++;
                }
            }
        }
        if (flag) {
            break;
        }
        c[k] = 0;
        k--;
    }

    if (flag) {
        cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl;
    }
}
</code></pre><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>回溯法在最坏情况下需要O（n^2）的运行时间。<br>但是需要注意，虽然蛮力搜索法的最坏情况也需要<br>O（n^2）的时间，但是根据经验回溯法的有效性远远超过蛮力法。(鬼知道这是谁的经验，反正只要知道考试用蛮力法肯定会xx)</p>
<h1 id="一般回溯方法"><a href="#一般回溯方法" class="headerlink" title="一般回溯方法"></a>一般回溯方法</h1><h2 id="什么是一般回溯法"><a href="#什么是一般回溯法" class="headerlink" title="什么是一般回溯法"></a>什么是一般回溯法</h2><p>在回溯法中，解向量中每个xi都属于一个有限的线序集Xi，因此，算法最初从空向量开始，然后选择X1中最小的元素作为x1，如果（x1）是一个部分解，算法从X2中找出最小的元素作为x2继续，如果（x1，x2）是一个部分解，则从X3中找出最小元素作为x3，否则跳过x2寻找下一个。一般地，假如算法已经找到部分解（x1,x2,x3…,xj），在判断v=（x1,x2,x3…,xj,x_j+1）时有以下情况：</p>
<ul>
<li>v是最终解：记录下当前v作为一组解，如果只想求得一组解则算法结束，否则继续寻找其他解 </li>
<li>v是一组部分解：从X_j+2中寻找新的最小元素继续向前走 </li>
<li><p>v既不是最终解也不是部分解：   </p>
<ul>
<li>X_j+1中还有其他元素可供选择：在X_j+1中寻找下一个元素 </li>
<li>X_j+1中没有其他元素可供选择：将x_j置为X_j中的下一个元素回溯，如果X_j中仍然没有其他元素可供选择，则照此方法继续向前回溯。 </li>
</ul>
</li>
</ul>
<h1 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h1><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>分支限界法（branch and bound method）是求解 <strong>纯整数规划</strong> 或 <strong>混合整数规划</strong> 问题的经典方法，在上世纪六十年代由Land<br>Doig和Dakin等人提出。这种方法灵活且便于用计算机求解，目前已经成功运用于求解生产进度问题、旅行推销员问题、工厂选址问题、背包问题及分配问题等。算法基本思想如下：</p>
<ul>
<li>按宽度优先策略遍历解空间树； </li>
<li>在遍历过程中，对处理的每个结点vi，根据界限函数，估计沿该结点向下搜索所可能达到的完全解的目标函数的可能取值范围—界限bound(vi)=[downi, upi]； </li>
<li>从中选择使目标函数取的极值(最大、最小)的结点优先进行宽度优先搜索，从而不断调整搜索方向，尽快找到问题解。 </li>
</ul>
<p>各结点的界限函数bound(vi)=[downi,<br>upi]是解决问题的关键，通常依据具体问题而定。常见的两种分支限界法是队列式分支限界法和优先队列式分支限界法，它们分别按照队列先进先出的原则和优先队列中规定的优先级选取下一个节点为扩展节点。</p>
<h2 id="分支限界法与回溯法的区别"><a href="#分支限界法与回溯法的区别" class="headerlink" title="分支限界法与回溯法的区别"></a>分支限界法与回溯法的区别</h2><h3 id="求解目标不同"><a href="#求解目标不同" class="headerlink" title="求解目标不同"></a>求解目标不同</h3><ul>
<li><p>回溯法的求解目标是找出解空间树中满足约束条件的 <strong>所有解</strong></p>
</li>
<li><p>分支限界法的求解目标则是尽快找出满足约束条件的 <strong>一个解</strong> ，或是在满足约束条件的解中找出在某种意义下的 <strong>最优解</strong></p>
</li>
<li><p>分支限界法通常用于解决 <strong>离散值的最优化问题</strong></p>
</li>
</ul>
<h3 id="搜索方式不同"><a href="#搜索方式不同" class="headerlink" title="搜索方式不同"></a>搜索方式不同</h3><ul>
<li>回溯法以 <strong>深度优先</strong> 的方式（遍历结点）搜索解空间树 </li>
<li>分支限界法以 <strong>广度优先</strong> 或 <strong>最小耗费优先</strong> 的方式搜索解空间树 </li>
</ul>
<h3 id="对扩展结点的扩展方式不同"><a href="#对扩展结点的扩展方式不同" class="headerlink" title="对扩展结点的扩展方式不同"></a>对扩展结点的扩展方式不同</h3><ul>
<li>分支限界法中，每一个活结点只有一次机会成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点 </li>
<li>重复上述结点扩展过程，直至到找到所需的解或活结点表为空时为止 </li>
</ul>
<h2 id="Demo——旅行商问题求解"><a href="#Demo——旅行商问题求解" class="headerlink" title="Demo——旅行商问题求解"></a>Demo——旅行商问题求解</h2><p>参考： <a href="https://blog.csdn.net/qq_32400847/article/details/51813606" target="_blank" rel="noopener"> 这里 </a></p>
<h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个城市的集合和一个定义在 <strong>每一对城市之间</strong> 的耗费函数，找出耗费最小的旅行。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>考虑下图所示的情况及其代价矩阵，假定起始城市为1号城市：</p>
<p><img src="https://img-blog.csdn.net/20160703014447395" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20160703014332283" alt="这里写图片描述"><br>注意代价矩阵的特点，每条满足要求的回路在代价矩阵中的每一行每一列有且只有1个元素与之对应。据此，我们可以用贪心算法计算问题的上界：<br>以起始城市作为出发城市，每次从当前出发城市发出的多条边中，选择没有遍历过的最短边连接的城市，作为下一步达到城市。在这个问题中，从城市1出发，途经1→3→5→4→2→1，路径长度1+2+3+7+3=16作为上界，即最短路径长度<br>&lt;=16。<br>对于下界，一个简单的办法是直接将矩阵中每一行的最小元素相加，在这个问题中，路径长度1+3+1+3+2=10作为下界，即最短路径长度&gt;=10。更优的计算方式是<br><strong>将矩阵中每一行最小的2个元素相加除以2并向上取整</strong><br>。因为在一条路径上，每个城市有2条邻接边：进入该城市、离开该城市。对每一步经过的城市j，从最近的上一个城市i来，再到下一个最近城市k去，即i→j→k。在这个问题中，路径长度{(1+3)+(3+6)+(1+2)+(3+4)+(2+3)}/2向上取整等于14作为下界，即最短路径长度</p>
<blockquote>
<p>=14。因此，以最短路径长度dist作为TSP问题目标函数，则dist的界为[14,16]。在问题求解过程中，如果1个部分解的目标函数dist下界超出此界限，则该部分解对应了死结点，可剪枝。对于1条正在生成的路径/部分解，设已经确定的顶点(已经经过/遍历的城市)集合为U=(r1,<br>r2, …,<br>rk)，则该部分解的目标函数的下界为(已经经过的路径的总长的2倍+从起点到最近未遍历城市的距离+从终点到最近未遍历城市的距离+进入/离开未遍历城市时各未遍历城市带来的最小路径成本)除以2并向上取整。假设正在生成的路径/部分解为1→4,U={1,4},未遍历城市={2,3,5},该部分解下界为{2*5+1+3+(3+6)+(1+2)+(2+3)}/2向上取整等于16：<br><img src="https://img-blog.csdn.net/20160703021801114" alt="这里写图片描述"></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/30/分治算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/分治算法/" itemprop="url">分治算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-30T16:45:40+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是分治"><a href="#什么是分治" class="headerlink" title="什么是分治"></a>什么是分治</h1><p>一个分治算法把问题实例划分为若干个子问题（一般是两个），并分别使用递归解决每个子实例，然后把这些子实例的解组合起来，得到原问题的解。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>考虑这样一个问题：我们需要在序列Ａ[1….n]中找到该序列的最大值元素和最小值元素，一种直接的算法是扫描一遍Ａ序列，用两个标志位max和min分别表示最大值和最小值元素，然后扫描时根据每个元素与当前最大最小值的比较情况动态调整最大最小值直至最后找到最大最小值，代码如下：</p>
<pre><code>void MaxMin(int *A,int n){
    int max,min;
    min=max=A[0];
    for (int i = 1; i &lt;n ; ++i) {
        if(A[i]&gt;max)max=A[i];
        if(A[i]&lt;min)min=A[i];
    }

    cout&lt;&lt;max&lt;&lt;min&lt;&lt;endl;
}
</code></pre><p>显然，此种方法的元素比较次数是２ｎ－２，但是利用分治策略就可以将元素比较次数减少到(３ｎ)/2-2，具体做法：将数组分割成凉拌，Ａ[1…n/2]和Ａ[n/2+1…n]，在每一半中分别找到最大值和最小值，并返回这两个最小值中的最小值、这两个最大值中的最大值作为最终的最小、最大值。对应伪代码如下：</p>
<pre><code>(max min) MaxMin2(int *A,int low,int high){
    if (high-low==1){
        if (A[low]&lt;A[high])return (A[low],A[high]);
        else return (A[high],A[low]);
    } else{
        int mid=(high+low)/2;
        (x1,y1)=MaxMin2(A,low,mid);
        (x2,y2)=MaxMin2(A,mid+1,high);
        x=min(x1,x2);
        y=max(y1,y2);

        return (x,y);
    }
}
</code></pre><p>按照上述算法，设Ａ[1…n]有ｎ个元素，ｎ为２的幂，则仅用３ｎ/2-2次元素比较就可以在数组Ａ中找出最大值和最小值。</p>
<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><h2 id="分治（递归）实现"><a href="#分治（递归）实现" class="headerlink" title="分治（递归）实现"></a>分治（递归）实现</h2><p>原理比较简单，给出代码：</p>
<pre><code>int binarysearch(int *A, int low, int high, int x) {//A是已经排序过的数组,A[1....n]

    if (low &gt; high)return 0;
    int mid = (high + low) / 2;
    if (x == A[mid])return mid;
    if (x &lt; A[mid])return binarysearch(A, low, mid, x - 1);
    else return binarysearch(A, mid + 1, high, x);


}
</code></pre><p>算法BINARYSEARCHREC在ｎ个元素组成的数组中搜索某个元素所执行的比较次数不超过((int)lohn)+1，时间复杂度是Ｏ(logn)。</p>
<h2 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h2><pre><code>int binarysearch(int *A, int n, int x) {//A是已经排序过的数组,A[1....n]

    int low, high, j;
    low =1;
    high = n;
    j = 0;//j表示ｘ的下标
    while (low &lt;= high &amp;&amp; j == 0) {
        int mid = (high + low) / 2;
        if (x == A[mid])  j = mid;
        else if (x &lt; A[mid])high = mid - 1;
        else low = mid + 1;
    }
    return j;
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>递归和迭代实现二分搜索算法的元素比较次数都在int(logn)+１内，但是迭代算法只需要senta(１)的空间，而迭代算法由于迭代深度为Ｏ(logn)，每个递归层次需要senta(1)的空间，所以总的需要的空间总量是Ｏ(logn)。</p>
<h1 id="归并（合并）排序"><a href="#归并（合并）排序" class="headerlink" title="归并（合并）排序"></a>归并（合并）排序</h1><p>这里需要区分迭代式合并排序和递归式合并排序的区别：</p>
<ul>
<li><p>迭代式 自底向上<br><img src="/home/dmrf/图片/merge2.jpg" alt=""></p>
</li>
<li><p>递归式 自顶向下<br><img src="/home/dmrf/图片/merge1.jpg" alt=""></p>
</li>
</ul>
<h2 id="迭代式"><a href="#迭代式" class="headerlink" title="迭代式"></a>迭代式</h2><p>主要思路是将索要排序数列看做若干个有序的小数列，因为将两个有序数列合并之后所得数列还是有序数列，所以经过不断合并，最后可将数列排为有序。</p>
<h3 id="时间空间复杂度及稳定性"><a href="#时间空间复杂度及稳定性" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h3><ul>
<li>T(n)=O(nlog2–&gt;n) </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>void MSort(vector&lt;int&gt; v) {


    vector&lt;int&gt; h;
    h = v;

    int start, seg;


    for (seg = 1; seg &lt; v.size(); seg *= 2) {
        int k = 0;
        for (start = 0; start &lt; v.size(); start = start + seg * 2) {
            int end;
            end = start + seg;
            int low = start;
            while (low &lt; start + seg &amp;&amp; end &lt; start + seg + seg &amp;&amp; low &lt; v.size() &amp;&amp; end &lt; v.size()) {
                if (v[low] &lt;= v[end]) {
                    h[k++] = v[low];
                    low++;
                } else {
                    h[k++] = v[end];
                    end++;
                }
            }

            while (low &lt; start + seg &amp;&amp; low &lt; v.size()) {
                h[k++] = v[low++];
            }
            while (end &lt; start + seg + seg &amp;&amp; end &lt; v.size()) {
                h[k++] = v[end++];
            }

        }

        v = h;
    }
    show(v);

}
</code></pre><h2 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h2><p>主要思路是将待排序序列分成两个小部分，然后再对两个小部分运行相同的排序方法进行递归排序，最后将两个小部分合并起来。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>MergeSort（A,1,n）;</p>
<pre><code>void MergeSort(int *A, int low, int high) {
    if (low &lt; high) {
        int mid = (high + low) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, high, mid + 1);
        Merge(A, low, mid, high);
    }
}

void Merge(int *A, int low, int mid, int high) {
    int n = high - low;
    int B[high - low];
    int b = mid;
    int i;
    for (i = 0; i &lt; n &amp;&amp; low &lt; mid &amp;&amp; b &lt; high; ++i) {
        if (A[low] &lt; A[b]) {
            B[i] = A[low++];
        } else {
            B[i] = A[b++];
        }
    }

    for (int j = low; j &lt; mid; ++j) {
        B[i] = A[j];
    }
    for (int k = b; k &lt; high; ++k) {
        B[i] = A[k];
    }

    for (int l = low; l &lt;high ; ++l) {
        A[l]=B[i];
    }
}
</code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>算法MergeSort对一个n个元素的数组排序所需的时间是senta(nlogn)，空间是senta(n).</p>
<h1 id="寻找中项和第k小元素"><a href="#寻找中项和第k小元素" class="headerlink" title="寻找中项和第k小元素"></a>寻找中项和第k小元素</h1><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>寻找序列A[1…n]中的第k小元素。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>传统的方法是直接将A[1…n]进行排序，然后取排序后的序列的第k个即为第k小元素，但是这种方法需要oumiga(nlogn)的时间，因为任何基于比较的排序过程在最坏情况下必须花费这么多时间，所以我们选择一种新的算法：<br>我们要在n个元素中找到第k小元素的实质是寻找第k小元素在A中的位置，所以我们可以将A划分成三个子序列A1 A2<br>A3，其中A2为单个元素的序列，A1中的所有元素小于A2，A3中的所有元素大于A2，此时就有以下几种情况：</p>
<ul>
<li>如果A1的长度大于k则A序列中第K小元素一定在A1中，我们只需寻找A1中的第k小元素即可 </li>
<li>如果A1的长度等于k-1，则A2中的那个单元素就是我们要找的第k小元素 </li>
<li>如果A1的长度小鱼k-1，则我们需要在A3序列中找到第k-len(A1)-1小元素 </li>
</ul>
<p>这样，我们就可以采用分治的思想将原来的n个元素中寻找第k小元素不断缩小范围最终找到目标元素，具体算法步骤描述如下：</p>
<h3 id="SELECT-算法描述"><a href="#SELECT-算法描述" class="headerlink" title="SELECT 算法描述"></a>SELECT 算法描述</h3><ol>
<li>如果数组元素个数小于 44,则直接将数组排序并返回第 k小元素(采用直接的方法来解决问题,因为当总元素个数小于44*5=220的时候用直接的方法解决问题更快)。 </li>
<li>把 n 个元素以每组 5 个元素划分为 int( n/5) 组,如果 n 不是 5的倍数则抛弃剩余元素。 </li>
<li>对每组进行排序,之后取出每组的中间项(第 3 个元素)。 </li>
<li>递归调用 SELECT 算法,得到这些中间项序列中的中项元素 mm </li>
<li><p>根据 mm,将原数组 A 划分为三个子数组: </p>
<ul>
<li>A1={小于 mm 的元素}; </li>
<li>A2={等于 mm 的元素}; </li>
<li>A3={大于 mm 的元素}; </li>
</ul>
</li>
<li><p>根据 k 的大小,判断第 k 小元素会出现在 A1,A2,A3 中的<br>哪一个数组里,之后,或者返回第 k 小元素(mm,在 A2<br>中),或者在 A1 或 A3 上递归。</p>
<ul>
<li>k </li>
</ul>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>void sort(int *A, int low, int high) {
    for (int i = low; i &lt; high; ++i) {
        for (int j = i + 1; j &lt; high; ++j) {
            if (A[i] &gt; A[j]) {
                int t = A[i];
                A[i] = A[j];
                A[j] = t;
            }
        }
    }
}

int Select(int *A, int low, int high, int k) {
    int p = high - low + 1;
    if (p &lt; 44) {
        sort(A, low, high);
        return A[k];

    }
    int q = p / 5;
    int M[q];

    for (int i = 0; i &lt; q; ++i) {
        sort(A, i * 5, (i + 1) * 5);//将A分成q组，每组5个元素，如果5不整除p，则排除剩余元素
        M[i] = A[i * 5 + 3];//M为q个子序列中的中项（中项集合）
    }

    int mm = M[q / 2];//mm为中项集合的中项
    int *A1, a1 = 0;
    int *A2, a2 = 0;
    int *A3, a3 = 0;
    for (int j = low; j &lt; high; ++j) {
        if (A[j] &lt; mm)A1[a1++] = A[j];
        if (A[j] = mm)A2[a2++] = A[j];
        if (A[j] &gt; mm)A3[a3++] = A[j];
    }
    if (a1 &gt;= k)return Select(A1, 1, a1, k);
    if (a1 + a2 == k)return mm;
    if (a1 + a2 &lt; k)return Select(A3, 1, a3, k - a1 - a2);


}
</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>在一个由n个元素组成的线序集合中提取第k小元素，所需的时间是senta(n)(T(n)&lt;=20cn,c是排序43个元素所需的时间)，特别地，n个元素元素的中值可以在senta(n)时间找出。<br>需要注意的是，虽然此算法所需的时间是senta(n)但是其中的倍数常量（20c）还是太大，我们会在随讲机算法的时候提出一个具有较小倍数常量的算法。</p>
<h1 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h1><p>快速排序（QuickSort）是一种具有senta(nlogn)时间复杂度的排序算法，相比MergeSort，QuickSort不需要辅助的存储空间，这是它的优势。</p>
<h2 id="划分算法（Split）"><a href="#划分算法（Split）" class="headerlink" title="划分算法（Split）"></a>划分算法（Split）</h2><p>在进行快速排序算法的实现之前我们需要先实现划分算法，它是快速排序算法的基础。</p>
<h3 id="什么是划分算法"><a href="#什么是划分算法" class="headerlink" title="什么是划分算法"></a>什么是划分算法</h3><p>设A[low…high]是一个包含n个数的序列，设x=a[low],我们希望对A中的元素进行位置调整后实现当i&lt; new index of x时A[i]</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>对一个指定序列A[low…high]，从A[low+1]开始向后扫描元素，如果当前元素a&lt;=A[low]，则将a与第A[i]的元素互换位置，其中i是从low开始的，每进行一次元素的互换之前i++，最后，当A中元素扫描完毕时所有小于等于A[low]的元素都在i之前的位置（包括A[i]），所以此时只需将A[low]和A[i]的元素互换位置即可满足划分的定义，此时的i对应的就是元素A[low]的新位置.</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>int Split(int *A, int low, int high) {//输入一个序列，返回A[low]对应元素的新位置
    int i = low;
    int x = A[low];
    for (int j = low + 1; j &lt;= high; ++j) {
        if (A[j] &lt;= x) {
            i++;
            if (i != j) {
                int t = A[i];
                A[i] = A[j];
                A[j] = t;
            }
        }
    }

    int t;
    t = A[low];
    A[low] = A[i];
    A[i] = t;

    return i;
}
</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>因为算法split的元素比较次数恰好是n-1，所以它的时间复杂性为senta(n).</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>算法QuickSort的主要思路是利用Split算法将A[low…high]中的A[low]排列到其正确的位置A[w]，然后对子数组A[low…w-1]和子数组A[w+1…high]递归地进行排序从而产生整个排序数组。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>void QuickSort(int *A, int low, int high) {
    if (low &lt; high) {
        int w = Split(A, low, high);//w为A[low]的新位置
        QuickSort(A, low, w - 1);
        QuickSort(A, w + 1, high);
    }
}
</code></pre><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>算法QuickSort对n个元素的数组进行排序时执行的平均比较次数是senta(nlogn)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/30/致敬那些用键盘改变世界的劳动者！/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/致敬那些用键盘改变世界的劳动者！/" itemprop="url">致敬那些用键盘改变世界的劳动者！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-30T14:50:15+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZFd6miaKCfDZgQZ1icuPxNicAfYRMYkJwrqkHOd08t8oBuAN2V7wccicx7eA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt="640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1"><br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZF9w9HpG3JIYolHrKXUFJNB8z6GXyyADlicv3VJfU0E6bkBNuBEFU8sUA/640?wx_fmt=png" alt="640?wx_fmt=png"><br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZFDtYmNVjCB1EO5HuRYP9FkrnUdUXC0T5HBelHzIRMBdJeDPeD50JiajA/640?wx_fmt=png" alt="640?wx_fmt=png"><br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZFFhHdkLZVe9blrpYfPkCITyp8TyuODTrLToHUWiaYwNiaJ4m3frj07cCQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<hr>
<p>end</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/29/归纳法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/归纳法/" itemprop="url">归纳法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T15:16:51+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>只调用一次的递归叫做尾递归</p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>基数排序需要经历d次，d为所要排序数列中位数最多的数的位数，其过程是首先根据数列中数的个位的数值将所有数入0~9这10个队列，然后从0~9将元素依次出队，然后再根据十位元素的数值再次入队，然后出队，以此类推重复d次，最终即可完成排序。</p>
<h2 id="时间空间复杂度及稳定性"><a href="#时间空间复杂度及稳定性" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(d*n) d为排序数中最大数的位数 </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>void radixSort(vector&lt;int&gt; v) {

    int d = GetMaxBit(v);

    int *count = new int[10];
    queue&lt;int&gt; q[10];

    int radix = 1;
    for (int i = 0; i &lt; d; ++i) {
        for (int j = 0; j &lt; v.size(); ++j) {
            int t;
            t = (v[j] / radix) % 10;
            q[t].push(v[j]);
        }

        int p = 0;
        for (int k = 0; k &lt; 10; ++k) {
            while (!q[k].empty()) {
                v[p++] = q[k].front();
                q[k].pop();
            }
        }
        radix *= 10;
    }
    show(v);

}
</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>对于任何的基数都可以归纳出算法，而不仅仅是以10做基数。比如可以把二进制的每四位作为一个数字，也就是用16作为基数，表的数目将和基数相等但是要保证从低位开始将数分配到表中。</p>
<h1 id="整数幂"><a href="#整数幂" class="headerlink" title="整数幂"></a>整数幂</h1><h2 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>很多时候我们需要求实数x的n次方即x^n，按照常规做法一般会对x进行n次自乘以得到x^n，但是这是非常低效的，因为它需要senta（n）次乘法，按照输入的大小来说它是指数级的。</p>
<h2 id="归纳法思路"><a href="#归纳法思路" class="headerlink" title="归纳法思路"></a>归纳法思路</h2><p>一个比较高效的归纳算法是令m=int(n/2)，假设已经知道如何计算x^m,那么根据x^m次方来计算x^n次方就有两种情况：</p>
<ul>
<li>n为偶数 则x^n=（x^m）^2 </li>
<li>n为奇数 则x^n=x(x^m)^2 </li>
</ul>
<h2 id="归纳法实现代码（Exprec）"><a href="#归纳法实现代码（Exprec）" class="headerlink" title="归纳法实现代码（Exprec）"></a>归纳法实现代码（Exprec）</h2><pre><code>int power(int x,int n){
    if (n==0){
        return 1;
    }

    int m=n/2;
    int y;
    y=power(x,n/2);
    y=y*y;
    if (n%2!=0){//如果n是奇数
        y=y*x;
    }

    return y;
}
</code></pre><h2 id="迭代法实现思路"><a href="#迭代法实现思路" class="headerlink" title="迭代法实现思路"></a>迭代法实现思路</h2><p>上述归纳法实现求x^n的关键部分在于采用递归不断判断n/2的奇偶性，所以我们可以采用迭代的办法，因为一个数除以2的k次方后的奇偶性由其化为二进制数的第k低位决定的（因为除法除以2就相当于二进制的左移操作），所以我们可以将n化为二进制数字d_k,d_(k-1)……d_0，从y=1开始，从左到右扫描二进制数字，如果当前二进制数字为0，则对应递归情况下的偶数情况即应该y=y^2，否则即为y=y(y^m)^2</p>
<h2 id="迭代法实现代码（Exp）"><a href="#迭代法实现代码（Exp）" class="headerlink" title="迭代法实现代码（Exp）"></a>迭代法实现代码（Exp）</h2><pre><code>int Exp(int x,int n){
    int d[10];//假设n化为2进制数字后存在d数组里面
    int y=1;
    for (int i = len(d); i &gt;=0 ; --i) {
        y=y*y;
        if(d[i]==1){
            y=y*x;
        }
    }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>假设每次乘法的时间是常数，那么这两种方法所需的运行时间都是 <strong>senta(lohn)</strong> ，他们对于输入大小来说都是 <strong>线性</strong> 的。</p>
<h1 id="多项式求值（Horner规则）"><a href="#多项式求值（Horner规则）" class="headerlink" title="多项式求值（Horner规则）"></a>多项式求值（Horner规则）</h1><h2 id="场景介绍-1"><a href="#场景介绍-1" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>假设有n+2个数a_0,a_1,……,a_n和x序列，要对多项式 <strong>P_n(x)=a_n<em>x^n+a_(n-1)</em>x^(n-1)+…+a_1*x</strong><br>求值，传统的办法是分别对每一个子项求值，然后再对整个式子求值，但是这种方法很低效，因为它需要n+（n-1）+（n-2）+…..+1=n(n+1)/2次乘法。</p>
<h2 id="归纳法解决思路"><a href="#归纳法解决思路" class="headerlink" title="归纳法解决思路"></a>归纳法解决思路</h2><p>首先我们发现原式可进行如下化简：<br><img src="https://img-
blog.csdn.net/20180429163357184?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>化简之后我们可以发现如果我们假设已知P_(n-1)(x)，那么P_n(x)=x*P_(n-1)(x)+a_0,所以就有了算法HORNER。</p>
<h2 id="HORNER算法代码实现"><a href="#HORNER算法代码实现" class="headerlink" title="HORNER算法代码实现"></a>HORNER算法代码实现</h2><pre><code>int Horner(int *A,int n,int x){//数组A的长度为n+2，从A[0]到A[n+1]代表了a_0到a_(n+1)

    int p=A[n+1];//p=a_(n+1)
    for (int i = 1; i &lt;=n ; ++i) {
        p=p*x+A[n+1-i];//p=p*x+a_(n-i)
    }

}
</code></pre><h1 id="寻找多数元素"><a href="#寻找多数元素" class="headerlink" title="寻找多数元素"></a>寻找多数元素</h1><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>令A[1…n]是一个整数序列，如果该序列中的某一个数x在该序列中出现的次数多余int(n/2)，则称x为该序列的 <strong>多数元素</strong> 。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>蛮力法 将每个元素与其他因素进行比较，并且对每一个元素计数，如果某个元素的计数大于int(n/2)，就可以断言它是多数元素。但是这种方法的比较次数是n(n-1)/2=senta(n^2)，代价过于昂贵。 </li>
<li>利用排序 先将原序列进行排序，在最坏情况下，排序这一步需要oumiga(nlogn)次比较。 </li>
<li>寻找中间元素 因为多数元素排序后一定是中间元素，可以找到该序列的中间元素后扫描整个序列该中间元素的出现次数来验证该元素是否为多数元素，由于中间元素可以再senta(n)时间内找到，这个方法要花费ｓｅｎｔａ(n)时间。 </li>
<li>MAJORITY算法 首先我们需要知道，去掉一个序列中的两个不同的数后该序列原来的多数元素现在依然是新序列的多数元素，所以我们……我们能怎么样呢，这不好描述啊，还是看代码吧…… </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>int majority(int *A, int n) {
    int c = candidate(A, 1, n);
    int count = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (A[i] == c) {
            count++;
        }
    }
    if (count &gt; (int) n / 2) {
        return c;
    } else {
        return NULL;
    }
}

int candidate(int *A, int m, int n) {
    int j = m;
    int c = A[m];
    int count = 1;
    while (j &lt; n &amp;&amp; count &gt; 0) {
        j++;
        if (A[j] == c) {
            count++;
        } else {
            count--;
        }
    }
    if (j == n) {
        return c;
    } else {
        return candidate(A, j + 1, n);
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/29/算法复杂度分析中的符号（Θ、Ο、ο、Ω、ω）简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/算法复杂度分析中的符号（Θ、Ο、ο、Ω、ω）简介/" itemprop="url">算法复杂度分析中的符号（Θ、Ο、ο、Ω、ω）简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T10:44:21+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Θ，读音：theta、西塔；既是上界也是下界(tight)，等于的意思。</p>
<p>Ο，读音：big-oh、欧米可荣（大写）；表示上界(tightness unknown)，小于等于的意思。</p>
<p>ο，读音：small-oh、欧米可荣（小写）；表示上界(not tight)，小于的意思。</p>
<p>Ω，读音：big omega、  欧米伽  （大写）  ；表示下界  (tightness unknown)，大于等于的意思。</p>
<p>ω，读音：small omega、  欧米伽  （小写）；表示下界(not tight)，大于的意思。</p>
<p>Ο是渐进上界，Ω是渐进下界。Θ需同时满足大Ο和Ω，故称为确界（必须同时符合上界和下界）。Ο极其有用，因为它表示了最差性能。具体如图所示：</p>
<p><img src="https://img-
blog.csdn.net/20150717164320363?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/29/堆和不相交集数据机构——堆/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/堆和不相交集数据机构——堆/" itemprop="url">堆和不相交集数据机构——堆</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T10:37:08+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>在很多情况下我们需要使用一种具有 <strong>插入元素</strong> 和 <strong>查找最大值元素</strong> 的数据结构，这种数据结构叫做 <strong>优先队列</strong><br>，如果采用普通队列，那么寻找最大元素需要搜索整个队列，开销比较大；如果使用排序数组，插入运算就需要移动很多的元素，开销也会比较大。这时候 <strong>堆</strong><br>就是一种 <strong>有效的实现优先队列的数据结构</strong> 。</p>
<p>堆的特点：</p>
<ul>
<li>父节点大于等于子节点（但是两个子节点之间的大小关系没有要求），这样可以做到 <strong>沿着每条从根节点到叶子节点的路径，元素的键值都是以非升序排列的</strong> 。 </li>
<li>堆是一个 <strong>几乎完全的二叉树</strong> ，所以具有和完全二叉树一样的特点，即一般是存储在一个数组A[n]中，A[i]的左子节点在A[2i]中，右子节点在A[2i+1]中（当他们存在的时候）,A[i]的父亲节点在A[i/2]中（如果存在，i/2向下取整）。 </li>
</ul>
<p>堆需要支持的几种运算：</p>
<pre><code>* delete-max[H] 从一个非空的堆H中删除最大元素并将数据项返回 
* insert[H,x] 将x插入到对H中 
* delete[H,i] 从堆中删除第i项（注意不是删除i） 
* makeheap[A] 将A转换成一个堆 
</code></pre><h2 id="堆上的运算"><a href="#堆上的运算" class="headerlink" title="堆上的运算"></a>堆上的运算</h2><h3 id="两个辅助运算"><a href="#两个辅助运算" class="headerlink" title="两个辅助运算"></a>两个辅助运算</h3><h4 id="SIFT-DOWN"><a href="#SIFT-DOWN" class="headerlink" title="SIFT-DOWN"></a>SIFT-DOWN</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>当某个节点（H[i]）的值大于他的父亲节点的值时，需要通过SITF-UP将这个节点 <strong>沿着从H[i]到H[1]这条唯一的路径</strong><br>上移到合适的位置以形成一个合格的堆。</p>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>将H[i]与其父亲节点H[i/2]比较，如果H[i]大于H[i/2]，则将H[i]与H[i/2]互换，直到H[i]没有父节点或者H[i]不大于H[i/2]。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code> int SiftUp(int *H, int i) {

    while (true) {
        if (i == 1) {
            break;//说明当前i是根节点
        }
        if (H[i] &gt; H[(int) i / 2]) {//如果当前节点比父亲节点大
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
            i = i / 2;
        } else {
            break;
        }
    }
    return 0;
}
</code></pre><h4 id="SIFT-DOWN-1"><a href="#SIFT-DOWN-1" class="headerlink" title="SIFT-DOWN"></a>SIFT-DOWN</h4><h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><p>当某个节点（H[i]，i&lt;=(int)n/2即 <strong>非叶子节点</strong><br>）的值小于它的两个子节点H[2i]和H[2i+1]（如果存在的话）的最大值时，需要将SIFT-DOWN将渗到合适的位置。</p>
<h5 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h5><p>将H[i]与其两个子节点中值最大的元素比较，如果小于最大的那个节点，则将H[i]与其最大的那个子节点互换。</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code> int SiftDown(int *H, int i, int n) {
    while (true) {
        i = 2 * i;
        if (i &gt; n) {
            break;
        }

        if (i + 1 &lt;= n) {
            if (H[i + 1] &gt; H[i]) {//比较两个子节点哪个最大
                i++;
            }
        }

        if (H[i] &gt; H[(int) i / 2]) {
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
        }
    }
}
</code></pre><h3 id="插入（insert）"><a href="#插入（insert）" class="headerlink" title="插入（insert）"></a>插入（insert）</h3><h5 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h5><p>将元素x插入到已有的堆H中</p>
<h5 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先将堆的大小增加1（n++），然后将x放在H[n]中，然后根据需要将H[n]中的元素x进行上移操作，直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以将一个元素插入大小为n的堆中所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code> void insert(int *H,int x,int &amp;n){
    n++;
    //这里默认H开的空间够用
    H[n]=x;
    SiftUp(H, n);//将x根据需要上移
}
</code></pre><h3 id="删除（delete）"><a href="#删除（delete）" class="headerlink" title="删除（delete）"></a>删除（delete）</h3><h5 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h5><p>将堆H中的元素x删除</p>
<h5 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h5><p>用堆中的最后一个元素H[n]替换需要删除的元素H[i]，然后堆的大小减一（n–），然后根据需要对H[i]进行上移或者下渗直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析-1"><a href="#算法时间复杂度分析-1" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><pre><code> void Delete(int *H, int i, int &amp;n) {

    if (i == n) {//如果需要删除的是最后一个元素
        n--;
        return;
    }

    H[i] = H[n];
    n--;

    if (H[i] &gt; H[(int) i / 2]) {//如果当前节点比父亲节点大则需要上移
        SiftUp(H, i);
    } else {//否则进行下渗
        SiftDown(H, i, n);
    }
}
</code></pre><h3 id="删除最大值（deletemax）"><a href="#删除最大值（deletemax）" class="headerlink" title="删除最大值（deletemax）"></a>删除最大值（deletemax）</h3><h5 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h5><p>将堆H中的最大元素x删除并返回最大值。</p>
<h5 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h5><p>用堆中的最后一个元素H[n]替换需要删除的元素H[1]，然后堆的大小减一（n–），然后根据需要对H[1]进行上移或者下渗直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析-2"><a href="#算法时间复杂度分析-2" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><pre><code> int DeleteMax(int *H,int &amp;n){
    int x=H[1];
    Delete(H, 1, n);
    return x;
}
</code></pre><h3 id="创建堆（makeheap）"><a href="#创建堆（makeheap）" class="headerlink" title="创建堆（makeheap）"></a>创建堆（makeheap）</h3><h5 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h5><p>给出一个有n个元素的数组H[1….n]，创建一个包含这些元素的堆。</p>
<h5 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h5><p>类似于分治，首先，H的叶子节点（即最下面的一层单个元素）可以认为是若干个小堆，然后我们从倒数第二层开始，将倒数第二层和倒数第一层的元素进行适当调整，使得调整之后整个二叉完全数的最后两层是若干个子堆，按照这个思路，依次向上走，最终走到第1层的时候就可以保证整个完全二叉树是一个符合要求的堆。</p>
<p>需要注意的是对于一个完全二叉树， <strong>倒数第二层的最后一个元素的下标为int(n/2)</strong> ，（因为倒数第二层的最后一个节点的下标x应该满足x*2=n）.</p>
<h5 id="算法时间复杂度分析-3"><a href="#算法时间复杂度分析-3" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>senta(n)</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><pre><code> void makeheap(int *H,int n){
    for (int i = n/2; i &gt;=1 ; --i) {//从倒数第二层到第一层
        SiftDown(H,i,n);
    }
}
</code></pre><h3 id="堆排序（heapsort）"><a href="#堆排序（heapsort）" class="headerlink" title="堆排序（heapsort）"></a>堆排序（heapsort）</h3><h5 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h5><p>利用堆对数组H[n]进行排序。</p>
<h5 id="实现思路-6"><a href="#实现思路-6" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先将数组H[n]调整成为一个（大顶）堆，这时可以保证H[1]是数组中的最大元素，然后将H[1]与H[n]互换位置，然后再调整1——n-1为一个大顶堆，然后将H[1]与H[n-1]互换，以此类推，最后就可以保证H为一个非升序的数组。</p>
<h5 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h5><p>空间复杂度：因为本算法是在数组H原有的空间基础上进行排序的，所以空间复杂度是Senta（1）。<br>时间复杂度：<br>+ 建堆 senta(n)<br>+ 执行n-1次siftdown nlog(n)<br>所以总的时间复杂度是nlog（n）</p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><pre><code>void HeapSort(int *H,int n){
    makeheap(H,n);
    int t;
    for (int i = n; i &gt;=2 ; --i) {
        t=H[i];
        H[i]=H[1];
        H[1]=t;
        SiftDown(H,1,i-1);
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/27/爬取了3W+用户评价后发现用户眼中的坚果3是这样的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/爬取了3W+用户评价后发现用户眼中的坚果3是这样的/" itemprop="url">爬取了3W+用户评价后发现用户眼中的坚果3是这样的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T13:21:03+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现过程介绍"><a href="#实现过程介绍" class="headerlink" title="实现过程介绍"></a>实现过程介绍</h1><h2 id="从网页爬取数据"><a href="#从网页爬取数据" class="headerlink" title="从网页爬取数据"></a>从网页爬取数据</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们打开京东商城坚果3 的购买页面：<br><img src="https://img-
blog.csdn.net/20180427131455676?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>然后按F12进入开发者控制台（审查元素）：<br><img src="https://img-
blog.csdn.net/20180427131508694?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>发现什么都没有，不要紧，点开评论区，你就会发现控制台出现类似这些信息：<br><img src="https://img-
blog.csdn.net/20180427131732633?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>控制台从刚才的没有信息到现在获取到当前信息，唯一的变化就是你打开了评论，所以网页返回的评论区内容一定在当前控制台的某个位置，从Name字段一个一个分析，就可以发现很明显的一行：<br><img src="https://img-
blog.csdn.net/20180427131757161?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>很明显这里就是我们需要的评论区数据，然后仔细分析其对应的Headers，就会发现我们获取数据需要的基本信息：<br><img src="https://img-
blog.csdn.net/20180427131809302?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>然后点开preview，就会发现返回数据转化为json格式后的内容：<br><img src="https://img-
blog.csdn.net/20180427131818464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>进一步打开Response，看到网页返回的原始数据：<br><img src="https://img-
blog.csdn.net/20180427131827248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看到，网页返回的原始数据是用一个fetchJSON_comment98vv1587包裹着的json字符串，到这里，我们的思路就很清晰了：<br><strong>首先用URL和对应的Query String<br>Parameters模仿网页发送请求，收到的Response将会是一份由fetchJSON_comment98vv1587（）包裹着的包含json数据的String，我们用正则表达式将json数据提取出来，然后对json数据进行解析并获取想要字段的数据即可。</strong></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先根据网页控制台的信息定义相关必要的变量：</p>
<pre><code>url=&apos;https://club.jd.com/comment/productPageComments.action&apos;

QueryStringParameters={ &apos;callback&apos;:&apos;fetchJSON_comment98vv1587&apos;,
       &apos;productId&apos;:&apos;7029545&apos;,
       &apos;score&apos;:0,
       &apos;sortType&apos;:5,
       &apos;page&apos;:0,
       &apos;pageSize&apos;:10,
       &apos;isShadowSku&apos;:0,
       &apos;fold&apos;:1 }
</code></pre><p>需要注意的是这里的url并不是直接将控制台显示的url全部拿过来，而是只要其前一部分，因为如果用控制台上的url，则只能获取到当前页面的评论，我们想要获取全部的评论，所以必须动态变化url，这里我们将url分为两部分写，这样方便后面调整page以获取不同页面的评论。<br>然后实现爬取数据的逻辑代码：</p>
<pre><code>hotcomments = []
while(True):
    t=s.get(url,params=data).text #模拟网页发送请求并接收返回数据

    try:
        t=re.search(r&apos;(?&lt;=fetchJSON_comment98vv1587\().*(?=\);)&apos;,t).group(0)#使用正则表达式匹配‘fetchJSON_comment98vv1587’
    except Exception as e:
        break
    j=json.loads(t) #解析json

    commentSummary=j[&apos;comments&apos;]
    flag=0
    for comment in commentSummary:
        flag=1
        num=num+1
        item = {
            &apos;content&apos;: comment[&apos;content&apos;] ,
            &apos;nickname&apos;: comment[&apos;nickname&apos;],
            &apos;score&apos;: comment[&apos;score&apos;],
            &apos;creationTime&apos;:comment[&apos;creationTime&apos;],
            &apos;productColor&apos;:comment[&apos;productColor&apos;]
        }
        hotcomments.append(item)
    if flag==0:
        break
    data[&apos;page&apos;]+=1  #改变page字段，下一次循环爬取下一页评论
</code></pre><p>当以上当以上代码执行完成之后就可以将所有评论信息放在 hotcomments中，然后就可以从中拿取数据进行分析了。</p>
<h2 id="使用Bar进行各项指标柱状图可视化"><a href="#使用Bar进行各项指标柱状图可视化" class="headerlink" title="使用Bar进行各项指标柱状图可视化"></a>使用Bar进行各项指标柱状图可视化</h2><h3 id="三种不同颜色评论数量所占百分比"><a href="#三种不同颜色评论数量所占百分比" class="headerlink" title="三种不同颜色评论数量所占百分比"></a>三种不同颜色评论数量所占百分比</h3><pre><code>a= productColor.count(u&apos;碳黑色&apos;)
b=productColor.count(u&apos;酒红色&apos;)
c=productColor.count(u&apos;浅金色&apos;)
d=float(a+b+c)
a=float(a/d)
b=float(b/d)
c=float(c/d)

ds = tablib.Dataset()
ds.headers = [&apos;颜色&apos;, &apos;评论数&apos;]

ds.append([&apos;碳黑色&apos;,a])
ds.append([&apos;酒红色&apos;, b])
ds.append([&apos;浅金色&apos;, c])

bar = Bar(&apos;颜色&apos;)
bar.add(&apos;评论数量(%)&apos;, ds.get_col(0), ds.get_col(1))
bar.render(&apos;color_bar.html&apos;)
</code></pre><h3 id="从9号到26号单天评价数量所占百分比"><a href="#从9号到26号单天评价数量所占百分比" class="headerlink" title="从9号到26号单天评价数量所占百分比"></a>从9号到26号单天评价数量所占百分比</h3><pre><code>ds2 = tablib.Dataset()
ds2.headers = [&apos;评价时间&apos;, &apos;评论数&apos;]
f=0.0
for i in range(9,27):
    f=f+creationTime.count(i)

for i in range(9,27):
    ds2.append([str(i), creationTime.count(i)/f])

bar2 = Bar(&apos;评价时间（购买时间）&apos;)
bar2.add(&apos;评论数量(%)&apos;, ds2.get_col(0), ds2.get_col(1))
bar2.render(&apos;time_bar.html&apos;)
</code></pre><h3 id="不同评分所占百分比"><a href="#不同评分所占百分比" class="headerlink" title="不同评分所占百分比"></a>不同评分所占百分比</h3><pre><code>ds3 = tablib.Dataset()
ds3.headers = [&apos;评分&apos;, &apos;评论数&apos;]
e=0.0
for i in range(0,6):
    j=5-i
    e+=score.count(j)


for i in range(0,6):
    j=5-i
    ds3.append([str(j), score.count(j)/e])

bar3 = Bar(&apos;评分&apos;)
bar3.add(&apos;评论数量(%)&apos;, ds3.get_col(0), ds3.get_col(1))
bar3.render(&apos;score_bar.html&apos;)
</code></pre><h2 id="使用WordCloud进行评论词云可视化"><a href="#使用WordCloud进行评论词云可视化" class="headerlink" title="使用WordCloud进行评论词云可视化"></a>使用WordCloud进行评论词云可视化</h2><pre><code>content_text = &quot; &quot;.join(content_list)
bg_pic = imread(&apos;../WoMen_EasonChen/eason2.png&apos;)
wordcloud = WordCloud(mask=bg_pic,font_path=&apos;../Font/SourceHanSansSC-Heavy.otf&apos;,background_color=&apos;white&apos;,max_words=200).generate(content_text)
plt.figure()
plt.imshow(wordcloud,interpolation=&apos;bilinear&apos;)
plt.axis(&apos;off&apos;)
plt.show()
</code></pre><h2 id="可视化结果"><a href="#可视化结果" class="headerlink" title="可视化结果"></a>可视化结果</h2><p><img src="https://img-
blog.csdn.net/20180427131847405?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从图中可以看出，大部分用户比较喜欢碳黑色（74.38%），购买浅金色的用户最少，约占5%<br><img src="https://img-
blog.csdn.net/20180427131913305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看到95%的用户都给出了5分好评<br><img src="https://img-
blog.csdn.net/20180427131924220?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h4 id="最后看一下词云显示的内容"><a href="#最后看一下词云显示的内容" class="headerlink" title="最后看一下词云显示的内容"></a>最后看一下词云显示的内容</h4><p><img src="https://img-
blog.csdn.net/20180427131931868?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在给一张：<br><img src="https://img-
blog.csdn.net/20180427131939309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>坚果3刚发布的时候在网上可以看到很多人在黑他，罗老师也毫不客气地表示“拉黑”这些锤黑，本人不是锤粉也不是锤黑，只是觉得中国像罗老师这样天生骄傲的企业家不多了，就像罗振宇老师说的希望罗永浩成功那样，我也希望罗老师成功，因为中国需要这么一个天生骄傲的企业家，希望罗老师会是下一个乔布斯甚至超越乔布斯，期待锤子科技515可以创造传奇。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/22/使用python绘制混淆矩阵（confusion_matrix）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/使用python绘制混淆矩阵（confusion_matrix）/" itemprop="url">使用python绘制混淆矩阵（confusion_matrix）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T13:46:00+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>涉及到分类问题，我们经常需要通过可视化混淆矩阵来分析实验结果进而得出调参思路，本文介绍如何利用python绘制混淆矩阵（confusion_matrix），本文只提供代码，给出必要注释。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code># -*-coding:utf-8-*-
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import numpy as np

#labels表示你不同类别的代号，比如这里的demo中有13个类别
labels = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;]

#y_true代表真实的label值 y_pred代表预测得到的lavel值
y_true = np.loadtxt(&apos;../Data/re_label.txt&apos;)
y_pred = np.loadtxt(&apos;../Data/pr_label.txt&apos;)

tick_marks = np.array(range(len(labels))) + 0.5


def plot_confusion_matrix(cm, title=&apos;Confusion Matrix&apos;, cmap=plt.cm.binary):
    plt.imshow(cm, interpolation=&apos;nearest&apos;, cmap=cmap)
    plt.title(title)
    plt.colorbar()
    xlocations = np.array(range(len(labels)))
    plt.xticks(xlocations, labels, rotation=90)
    plt.yticks(xlocations, labels)
    plt.ylabel(&apos;True label&apos;)
    plt.xlabel(&apos;Predicted label&apos;)


cm = confusion_matrix(y_true, y_pred)
np.set_printoptions(precision=2)
cm_normalized = cm.astype(&apos;float&apos;) / cm.sum(axis=1)[:, np.newaxis]
print cm_normalized
plt.figure(figsize=(12, 8), dpi=120)

ind_array = np.arange(len(labels))
x, y = np.meshgrid(ind_array, ind_array)

for x_val, y_val in zip(x.flatten(), y.flatten()):
    c = cm_normalized[y_val][x_val]
    if c &gt; 0.01:
        plt.text(x_val, y_val, &quot;%0.2f&quot; % (c,), color=&apos;red&apos;, fontsize=7, va=&apos;center&apos;, ha=&apos;center&apos;)
# offset the tick
plt.gca().set_xticks(tick_marks, minor=True)
plt.gca().set_yticks(tick_marks, minor=True)
plt.gca().xaxis.set_ticks_position(&apos;none&apos;)
plt.gca().yaxis.set_ticks_position(&apos;none&apos;)
plt.grid(True, which=&apos;minor&apos;, linestyle=&apos;-&apos;)
plt.gcf().subplots_adjust(bottom=0.15)

plot_confusion_matrix(cm_normalized, title=&apos;Normalized confusion matrix&apos;)
# show confusion matrix
plt.savefig(&apos;../Data/confusion_matrix.png&apos;, format=&apos;png&apos;)
plt.show()
</code></pre><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p><img src="https://img-
blog.csdn.net/20180422134149170?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h1 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h1><p>按照代码中的注释将labels、y_true 、y_pred替换为你自己的数据即可。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/guoyilin/article/details/42047615" target="_blank" rel="noopener"> 如何用python画好confusion matrix
</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/17/白话设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/白话设计模式/" itemprop="url">白话设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T22:37:34+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p><strong>对象怎么来</strong> 提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new<br>运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>重点在于Factory类，当一个类的实例化依赖于不同场景时需要使用的，比如根据形状不同实例化不同形状类并返回的demo，根据不同的形状，实例化的Shape对象内部的实现逻辑不一样，这时候就可以使用工厂方法模式，将类内部的实现细节隐藏起来，用户只需要告诉工厂类自己需要什么情况下的产品，工厂就可以自动调用自己内部对应场景的代码从而返回一个用户需要的“产品”。</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂可以理解为工厂的工厂，比如demo中，首先有两个工厂Factory，分别用来实例化不同场景下的shape和color，然后再有过一个工厂的工厂即FactoryProducer，其根据用户的需求（shape或者color）返回shape工厂或者color工厂，然后用户再用返回的工厂去实例化自己需要的shape或者color。<br>对比工厂方法模式，因为一个工厂只能生产一个产品，比如一个ShapeFactory只能根据不同情况实例化一个不同的Shape，那么当我们需要一整套的产品（比如形状和颜色形成了一套产品）时使用工厂方法显然就不能解决了，所以就需要抽象工厂模式，抽象工厂模式实际上是工厂的工厂，即其作用的目的是为了实例化不同的工厂，用户再通过不同的工厂实例化不同场景下成套的产品。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>通俗来讲就是替用户实现对象的实例化，用户需要使用类的时候不需要实例化，直接通过getInstance就可以拿到需要使用的对象，进而调用对象的方法即可，这个设计模式平时用到的比较多，也比较容易理解。</p>
<h3 id="生成器（建造者）模式"><a href="#生成器（建造者）模式" class="headerlink" title="生成器（建造者）模式"></a>生成器（建造者）模式</h3><p>生成器模式的目的是使用多个简单的对象一步一步构建成一个复杂的对象，比如在一个快餐店的商业案例中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold<br>drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold<br>drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>那么，生成器（MealBuilder）的作用就是实现不同类型汉堡（Burger）与不同类型冷饮（Cold<br>drink）的搭配，即通过MealBuilder这个生成器可以通过组合不同汉堡和冷饮这样简单的类从而狗仔出一个复杂的套餐（Meal）类，这就体现了生成器模式“使用多个简单的对象一步一步构建成一个复杂的对象”的要点，需要注意的是建造者模式与工厂方法模式有类似的地方，但是建造者模式更加关注零件装配的顺序而且生成的对象内部属性本身具有相互依赖性，比如Demo中的食物和对应的容器具有很强的相互依赖性。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式实现的功能就是对象的拷贝，只不过这种拷贝的功能是在类中定义好的，即在定义类的时候就定义好了一个clone的接口，当这个类对应的对象在某一时刻需要拷贝出另一个对象时，只需调用这个对象的clone方法即可返回一个本对象的克隆体，那么为什么不直接实例化一个新的对象而要采用这种克隆的机制呢？想象一下如果一个类的某些属性的值需要从数据库中查询，这样每实例化一个新类就需要做查询的耗时操作，这时候如果直接用一个已有的对象去clone出一个新的对象就可以避免诸如数据库查询之类的耗时操作，提高了软件的执行效率。</p>
<h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p><strong>对象和谁有关</strong> 关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式的要点在于组合和结构，通俗来讲就是通过不同的组合来形成一个体系结构，实现要点是list的使用，以上述demo为例，CEO的下属包含headSales和headMarketing，即CEO这个对象的下属list里面只要添加headSales和headMarketing即可，所以如果把CEO理解为一个东西的话它是由headSales和headMarketing组合而成的（如果没有这两者真不知道CEO存在的意义是什么，一自己当自己的CEO？），而headSales又有若干个salesExecutive下属，所以headSales对象的下属list里面应该添加若干个salesExecutive对象，以此类推（headMarketing由若干个clerk组成）。至此，通过不断的组合，我们就可以由salesExecutive和clerk一路不断组合直到CEO，这就是“组合”的含义，同时也体现了很强的层级关系。</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者模式（Decorator<br>Pattern）的目的是向一个现有的对象添加新的功能，同时又不改变其结构，这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供额外的功能。</p>
<p>装饰者模式的主要思路是通过一个新类（Decorator ）将原来的类包装起来，在Decorator 中给原来的类添加新的功能。</p>
<p>装饰者模式顾名思义就是起到一个装饰的作用，即在不改变原来类结构的前提下增加一些新的功能，这种模式一般会产生一个专门的装饰类，联想结构型设计模式的定义（描述不同类之间的关系），装饰者模式实际上描述的就是一个装饰与被装饰的关系，结合上面的demo，被装饰类是实现了shape接口的Rectangle类和Circle类，而装饰类ShapeDecorator是一个抽象装饰类，在其内部定义了装饰shape的方法draw，事实上是一种方法重写（准确来说是增加方法功能），然后在ShapeDecorator的子类RedShapeDecorator中的draw调用了起装饰作用的setRedBorder方法最终达到装饰实现shape子类的目的，从最终的输出也可以看出，装饰类的作用实际上就是在原有类的基础上新增加新的东西，还有一个比较接近现实的例子是玩游戏时开局一个英雄，玩着玩着英雄的装备越来越多、英雄的技能越来越多、英雄的皮肤越来越多，这些效果实际上都是在原来开局裸体（额实在不知道用什么形容词，懂我意思就好～）英雄的基础上装饰进去的，很好地体现了装饰的精髓。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>现实生活中代理的例子其实很多，比如大家搭建服务器从而实现访问某些xx的网址的访问，其原理其实就是在云端搭建一台云主机，这台主机的地址一般是在可以访问你当前计算机不能访问的xx网址的地域（比如东亚的计算机可以访问很多nj访问不到的xx网址），所以当你想要从xx网址获取信息的时候就可以先把请求发给你搭建的云主机，让它去访问xx，然后再把信息返回给你，这样就像你直接访问了xx一样，这就是代理的意思。回到设计模式，代理模式实际上讲的就是一种“代理访问”的概念，当A类不能暴露给B类而B类又想调用A类的方法的时候必须通过一种折中的方法，即B类通过向可以调用A类的C类发送请求从而让C类调用A类干同样的事情，就是这个意思……<br>具先实现其实也很简单，就是一个代理类将被代理类包裹起来，只对外界暴露调用被代理类方法的方法，从而实现代理模式，需要特别注意的是代理模式和适配器模式的区别：<br><strong>适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口</strong> ，和装饰器模式的区别：<br><strong>装饰器模式为了增强功能，而代理模式是为了加以控制</strong> 。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>顾名思义，享元模式体现的就是一种“分享”的实质，即当很多地方都需要用到一个类的对象而实例化这个类又需要耗费很多资源的时候我们就可以把这个类的对象抽取出来，仅仅实例化一次，当以后需要实例化这个类的对象的时候直接把之前实例化的对象返回即可，比如demo中需要实例化不同颜色不同形状的shape对象，而这些对象的存在状态就那么几种，所以使用一个Factory类，当第一次接收到实例化shape类的请求时进行一次实例化并将实例化得到的结果存下来，以后再接收到实例化的请求时直接把之前实例化的同类型的对象返回即可，这样可以大大提高程序执行的效率。</p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>当一个抽象类有多个实现时，通常用集成来协调他们。抽象类定义对该抽象的接口，而具体子类则用不同方式加以实现。但是此方法的缺点是将子类的抽象部分和实现部分固定在了一起，使得难以对抽象部分和实现部分进行修改、扩充和重用。<br>实现抽象化和实现化之间的解耦，具体到上述demo，抽象化指的是 draw redCircle和draw<br>greenCircle，如果不使用桥接模式，一般的实现方法是根据用户指令的不同（以参数的形式体现），实现不同的draw方法，而使用桥接模式，Circle类不用关心具体如何根据用户传入参数的不同实现不同的draw方法（即实现化部分），Circle类只需要根据用户传入接口的不同调用draw方法即可，具体的实现全都交给了DrawAPI（GreenCircle、ReadCircle）来做，即将draw这个功能的抽象化放在Circle类，实现化放在DrawAPI（GreenCircle、ReadCircle），从而实现了抽象化和实例化的分离。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>（这个模式描述的不是很好，感觉还是demo更容易理解一点）<br>作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。<br>注意，要点是要在原来类的基础上使原本不兼容的功能变得兼容。<br>Adapter类一般是用来实现与原有类不兼容的功能，比如demo中的MediaAdapter实现了MediaPlayer没有的特殊功能，用户只要调用AudioPlayer中的play方法，AudioPlayer会自动根据音频的类型选择不同的play方式，当音频类型不符合传统player的能力时AudioPlayer会使用adapter去调用之前不兼容的方法（功能），这样就实现了所谓的适配。</p>
<p>类适配器和对象适配器的区别：<br>类适配器的重点在于类，是通过构造一个继承Adaptee类来实现适配器的功能；<br>对象适配器的重点在于对象，是通过在直接包含Adaptee类来实现的，当需要调用特殊功能的时候直接使用Adapter中包含的那个Adaptee对象来调用特殊功能的方法即可。</p>
<h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><p>对象与对象在干嘛<br>这些设计模式特别关注对象之间的通信</p>
<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>模板方法模式顾名思义就是定义了一个特殊的方法，这个方法的大体框架是写死的，比如demo中抽象类Game的play方法，它规定了所有实现类的play方法有且仅能有模板方法中定义中的行为，但是这些行为具体如何实现则不是模板方法所关心的，说白了就是模板方法规定了如果调用这个方法会干嘛，但是怎么去干就不是它所关心的重点了。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式用一句话描述就是当一个类的对象（被观察者）的状态发生改变时同时其他依赖于它的对象（观察者）的状态也做相应的改变（做相应的动作）。</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式本质上就是一种遍历聚合对象的方式，这里的聚合对象一般具有较多的实例，比如java中的list等，也就是说对于有些对象，我们更加偏向于它的属性而不是行为，而迭代器模式提供了一种较为隐蔽的遍历这些对象属性的方法，通过经典的hasnext方法和next方法的配合使用，从而实现顺序访问聚合对象中各个元素,<br>而又无须暴露该对象的内部表示。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式的本质就是一条链，通过demo可以发现其实现方式和数据结构中的链表有很相似的地方，思想就是形成一条链，如果当前节点处理不了某些行为，则把这个行为请求转移到其下一级，以此类推，比较常见的实例就是java或者python中经常用到的try<br>catch机制，当某个方法有可能抛出异常而当前方法无法处理的时候我们就会可能将这个异常throw到外层，即责任链中的下一级。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式的本质就是一种备份机制，其思路是将对象的状态在用户需要的时候备份下来，当需要状态回滚的时候直接将将对象的状态恢复到之前备份的状态，我们经常用的git版本控制管理系统其实就是一个特殊的备忘录模式，其在你需要的时候将你的仓库备份下来，这样你就可以在后期的开发中随时找到你之前备份的仓库状态，但是需要注意的是备忘录模式的重点是对象，其真正的目的是将单个对象的状态保存下来，至于其他的状态备份则不是它所侧重的。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式实质上就是将命令抽象到一个具体的类中，即这个类是专门去执行某个命令的，比如demo中，SellStock就是专门执行sell这个命令的，当用户需要sell的时候只要实例化SellStock然后excute就可以完成sell，还有一个比较常用的例子是GUI开发中按钮（button）的作用，每一个按钮都是一个对象，当用户点击某个按钮后就会触发一个相应的命令，用户看到的是点击按钮产生效果，而代码层面上是实例化的按钮对象执行类似于demo中的excute方法完成自己的“命令”。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式将各个状态所对应的操作分离开来,即对于不同的状态,由不同的子类实现具体操作,不同状态的切换由子类实现，比如上面的demo，同样是实现doAction根据不同的状态执行不同的逻辑，按照传统的方法需要使用if<br>else进行判断，但是使用状态模式则可以将不同的状态实例化为不同的子类，然后在不同的子类（实际上是不同的状态）中实现不同的逻辑，客户端使用的时候只需要实例化不同的状态的子类就可以调用不同状态下的同名方法。</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式解决的是根据访问者的不同而执行不同的行为，即同样一个方法（方法名相同），但是当A调用这个方法时执行的是逻辑A，B调用这个方法时执行逻辑B，这种情况下就需要使用访问者模式来实现。具体到demo，我们想要实现不同的ComputerPart调用accept的时候执行不同的逻辑，只需要构造一个访问者类ComputerPartDisplayVisitor，它根据accept的调用者的不用执行不同的逻辑，而调用者只需要将this传入accept方法即可，accept方法会根据传入的参数类型的不同调用不同的逻辑（visit）。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>当一个类的行为需要根据不同的状态改变时就需要使用策略模式，比如demo中Context类的executeStrategy方法执行的逻辑需要根据Context的Strategy成员的状态的变化而变化，传统地可以通过if<br>else语句来实现对Strategy状态的判断进而实现不同的算法，但是如果采用策略模式，Context类就不必关心当前Strategy的状态，而将这种执行不同算法的控制权交给了客户端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/16/适配器模式之类适配器与对象适配器的区别及代码实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/适配器模式之类适配器与对象适配器的区别及代码实现/" itemprop="url">适配器模式之类适配器与对象适配器的区别及代码实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T19:22:49+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是适配器模式？"><a href="#什么是适配器模式？" class="headerlink" title="什么是适配器模式？"></a>什么是适配器模式？</h1><p>适配器模式（Adapter）：直观理解就是使原来不能一起相互工作（接口不兼容）的两个功能通过Adapter兼容在一起。</p>
<h1 id="类适配器和对象适配器"><a href="#类适配器和对象适配器" class="headerlink" title="类适配器和对象适配器"></a>类适配器和对象适配器</h1><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p>Adapter 类继承Adaptee （被适配类），同时实现Target 接口（因为 Java 不支持多继承，所以只能通过接口的方法来实现多继承），在<br>Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。</p>
<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>不使用多继承或继承的方式，而是使用直接关联，或者称为委托的方式。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>类适配器的重点在于类，是通过构造一个继承Adaptee类来实现适配器的功能；<br>对象适配器的重点在于对象，是通过在直接包含Adaptee类来实现的，当需要调用特殊功能的时候直接使用Adapter中包含的那个Adaptee对象来调用特殊功能的方法即可。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="类适配器-1"><a href="#类适配器-1" class="headerlink" title="类适配器"></a>类适配器</h2><pre><code>// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
class Adaptee {
    public void specificRequest() {
        System.out.println(&quot;被适配类 具有特殊功能...&quot;);
    }
}

// 目标接口，或称为标准接口
interface Target {
    public void request();
}

// 具体目标类，只提供普通功能
class ConcreteTarget implements Target {
    public void request() {
        System.out.println(&quot;普通类 具有普通功能...&quot;);
    }
}

// 适配器类，继承了被适配类，同时实现标准接口
class Adapter extends Adaptee implements Target{
    public void request() {
        super.specificRequest();
    }
}

// 测试类
public class Client {
    public static void main(String[] args) {
        // 使用普通功能类
        Target concreteTarget = new ConcreteTarget();//实例化一个普通类
        concreteTarget.request();

        // 使用特殊功能类，即适配类
        Target adapter = new Adapter();
        adapter.request();
    }
}
</code></pre><p>测试结果：<br>普通类 具有普通功能…<br>被适配类 具有特殊功能…</p>
<h2 id="对象适配器-1"><a href="#对象适配器-1" class="headerlink" title="对象适配器"></a>对象适配器</h2><pre><code>// 适配器类，直接关联被适配类，同时实现标准接口
class Adapter implements Target{
    // 直接关联被适配类
    private Adaptee adaptee;

    // 可以通过构造函数传入具体需要适配的被适配类对象
    public Adapter (Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        // 这里是使用委托的方式完成特殊功能
        this.adaptee.specificRequest();
    }
}

// 测试类
public class Client {
    public static void main(String[] args) {
        // 使用普通功能类
        Target concreteTarget = new ConcreteTarget();
        concreteTarget.request();

        // 使用特殊功能类，即适配类，
        // 需要先创建一个被适配类的对象作为参数
        Target adapter = new Adapter(new Adaptee());
        adapter.request();
    }
}
</code></pre><p>测试结果：<br>普通类 具有普通功能…<br>被适配类 具有特殊功能…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">128</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">94</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
