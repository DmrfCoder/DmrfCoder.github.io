<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="DmrfCoder的个人主页">
<meta property="og:url" content="http://www.mashangxue123.com/page/7/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DmrfCoder的个人主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/page/7/">





  <title>DmrfCoder的个人主页</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/30/分治算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/分治算法/" itemprop="url">分治算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-30T16:45:40+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是分治"><a href="#什么是分治" class="headerlink" title="什么是分治"></a>什么是分治</h1><p>一个分治算法把问题实例划分为若干个子问题（一般是两个），并分别使用递归解决每个子实例，然后把这些子实例的解组合起来，得到原问题的解。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>考虑这样一个问题：我们需要在序列Ａ[1….n]中找到该序列的最大值元素和最小值元素，一种直接的算法是扫描一遍Ａ序列，用两个标志位max和min分别表示最大值和最小值元素，然后扫描时根据每个元素与当前最大最小值的比较情况动态调整最大最小值直至最后找到最大最小值，代码如下：</p>
<pre><code>void MaxMin(int *A,int n){
    int max,min;
    min=max=A[0];
    for (int i = 1; i &lt;n ; ++i) {
        if(A[i]&gt;max)max=A[i];
        if(A[i]&lt;min)min=A[i];
    }

    cout&lt;&lt;max&lt;&lt;min&lt;&lt;endl;
}
</code></pre><p>显然，此种方法的元素比较次数是２ｎ－２，但是利用分治策略就可以将元素比较次数减少到(３ｎ)/2-2，具体做法：将数组分割成凉拌，Ａ[1…n/2]和Ａ[n/2+1…n]，在每一半中分别找到最大值和最小值，并返回这两个最小值中的最小值、这两个最大值中的最大值作为最终的最小、最大值。对应伪代码如下：</p>
<pre><code>(max min) MaxMin2(int *A,int low,int high){
    if (high-low==1){
        if (A[low]&lt;A[high])return (A[low],A[high]);
        else return (A[high],A[low]);
    } else{
        int mid=(high+low)/2;
        (x1,y1)=MaxMin2(A,low,mid);
        (x2,y2)=MaxMin2(A,mid+1,high);
        x=min(x1,x2);
        y=max(y1,y2);

        return (x,y);
    }
}
</code></pre><p>按照上述算法，设Ａ[1…n]有ｎ个元素，ｎ为２的幂，则仅用３ｎ/2-2次元素比较就可以在数组Ａ中找出最大值和最小值。</p>
<h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><h2 id="分治（递归）实现"><a href="#分治（递归）实现" class="headerlink" title="分治（递归）实现"></a>分治（递归）实现</h2><p>原理比较简单，给出代码：</p>
<pre><code>int binarysearch(int *A, int low, int high, int x) {//A是已经排序过的数组,A[1....n]

    if (low &gt; high)return 0;
    int mid = (high + low) / 2;
    if (x == A[mid])return mid;
    if (x &lt; A[mid])return binarysearch(A, low, mid, x - 1);
    else return binarysearch(A, mid + 1, high, x);


}
</code></pre><p>算法BINARYSEARCHREC在ｎ个元素组成的数组中搜索某个元素所执行的比较次数不超过((int)lohn)+1，时间复杂度是Ｏ(logn)。</p>
<h2 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h2><pre><code>int binarysearch(int *A, int n, int x) {//A是已经排序过的数组,A[1....n]

    int low, high, j;
    low =1;
    high = n;
    j = 0;//j表示ｘ的下标
    while (low &lt;= high &amp;&amp; j == 0) {
        int mid = (high + low) / 2;
        if (x == A[mid])  j = mid;
        else if (x &lt; A[mid])high = mid - 1;
        else low = mid + 1;
    }
    return j;
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>递归和迭代实现二分搜索算法的元素比较次数都在int(logn)+１内，但是迭代算法只需要senta(１)的空间，而迭代算法由于迭代深度为Ｏ(logn)，每个递归层次需要senta(1)的空间，所以总的需要的空间总量是Ｏ(logn)。</p>
<h1 id="归并（合并）排序"><a href="#归并（合并）排序" class="headerlink" title="归并（合并）排序"></a>归并（合并）排序</h1><p>这里需要区分迭代式合并排序和递归式合并排序的区别：</p>
<ul>
<li><p>迭代式 自底向上<br><img src="/home/dmrf/图片/merge2.jpg" alt=""></p>
</li>
<li><p>递归式 自顶向下<br><img src="/home/dmrf/图片/merge1.jpg" alt=""></p>
</li>
</ul>
<h2 id="迭代式"><a href="#迭代式" class="headerlink" title="迭代式"></a>迭代式</h2><p>主要思路是将索要排序数列看做若干个有序的小数列，因为将两个有序数列合并之后所得数列还是有序数列，所以经过不断合并，最后可将数列排为有序。</p>
<h3 id="时间空间复杂度及稳定性"><a href="#时间空间复杂度及稳定性" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h3><ul>
<li>T(n)=O(nlog2–&gt;n) </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>void MSort(vector&lt;int&gt; v) {


    vector&lt;int&gt; h;
    h = v;

    int start, seg;


    for (seg = 1; seg &lt; v.size(); seg *= 2) {
        int k = 0;
        for (start = 0; start &lt; v.size(); start = start + seg * 2) {
            int end;
            end = start + seg;
            int low = start;
            while (low &lt; start + seg &amp;&amp; end &lt; start + seg + seg &amp;&amp; low &lt; v.size() &amp;&amp; end &lt; v.size()) {
                if (v[low] &lt;= v[end]) {
                    h[k++] = v[low];
                    low++;
                } else {
                    h[k++] = v[end];
                    end++;
                }
            }

            while (low &lt; start + seg &amp;&amp; low &lt; v.size()) {
                h[k++] = v[low++];
            }
            while (end &lt; start + seg + seg &amp;&amp; end &lt; v.size()) {
                h[k++] = v[end++];
            }

        }

        v = h;
    }
    show(v);

}
</code></pre><h2 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h2><p>主要思路是将待排序序列分成两个小部分，然后再对两个小部分运行相同的排序方法进行递归排序，最后将两个小部分合并起来。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>MergeSort（A,1,n）;</p>
<pre><code>void MergeSort(int *A, int low, int high) {
    if (low &lt; high) {
        int mid = (high + low) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, high, mid + 1);
        Merge(A, low, mid, high);
    }
}

void Merge(int *A, int low, int mid, int high) {
    int n = high - low;
    int B[high - low];
    int b = mid;
    int i;
    for (i = 0; i &lt; n &amp;&amp; low &lt; mid &amp;&amp; b &lt; high; ++i) {
        if (A[low] &lt; A[b]) {
            B[i] = A[low++];
        } else {
            B[i] = A[b++];
        }
    }

    for (int j = low; j &lt; mid; ++j) {
        B[i] = A[j];
    }
    for (int k = b; k &lt; high; ++k) {
        B[i] = A[k];
    }

    for (int l = low; l &lt;high ; ++l) {
        A[l]=B[i];
    }
}
</code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>算法MergeSort对一个n个元素的数组排序所需的时间是senta(nlogn)，空间是senta(n).</p>
<h1 id="寻找中项和第k小元素"><a href="#寻找中项和第k小元素" class="headerlink" title="寻找中项和第k小元素"></a>寻找中项和第k小元素</h1><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>寻找序列A[1…n]中的第k小元素。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>传统的方法是直接将A[1…n]进行排序，然后取排序后的序列的第k个即为第k小元素，但是这种方法需要oumiga(nlogn)的时间，因为任何基于比较的排序过程在最坏情况下必须花费这么多时间，所以我们选择一种新的算法：<br>我们要在n个元素中找到第k小元素的实质是寻找第k小元素在A中的位置，所以我们可以将A划分成三个子序列A1 A2<br>A3，其中A2为单个元素的序列，A1中的所有元素小于A2，A3中的所有元素大于A2，此时就有以下几种情况：</p>
<ul>
<li>如果A1的长度大于k则A序列中第K小元素一定在A1中，我们只需寻找A1中的第k小元素即可 </li>
<li>如果A1的长度等于k-1，则A2中的那个单元素就是我们要找的第k小元素 </li>
<li>如果A1的长度小鱼k-1，则我们需要在A3序列中找到第k-len(A1)-1小元素 </li>
</ul>
<p>这样，我们就可以采用分治的思想将原来的n个元素中寻找第k小元素不断缩小范围最终找到目标元素，具体算法步骤描述如下：</p>
<h3 id="SELECT-算法描述"><a href="#SELECT-算法描述" class="headerlink" title="SELECT 算法描述"></a>SELECT 算法描述</h3><ol>
<li>如果数组元素个数小于 44,则直接将数组排序并返回第 k小元素(采用直接的方法来解决问题,因为当总元素个数小于44*5=220的时候用直接的方法解决问题更快)。 </li>
<li>把 n 个元素以每组 5 个元素划分为 int( n/5) 组,如果 n 不是 5的倍数则抛弃剩余元素。 </li>
<li>对每组进行排序,之后取出每组的中间项(第 3 个元素)。 </li>
<li>递归调用 SELECT 算法,得到这些中间项序列中的中项元素 mm </li>
<li><p>根据 mm,将原数组 A 划分为三个子数组: </p>
<ul>
<li>A1={小于 mm 的元素}; </li>
<li>A2={等于 mm 的元素}; </li>
<li>A3={大于 mm 的元素}; </li>
</ul>
</li>
<li><p>根据 k 的大小,判断第 k 小元素会出现在 A1,A2,A3 中的<br>哪一个数组里,之后,或者返回第 k 小元素(mm,在 A2<br>中),或者在 A1 或 A3 上递归。</p>
<ul>
<li>k </li>
</ul>
</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>void sort(int *A, int low, int high) {
    for (int i = low; i &lt; high; ++i) {
        for (int j = i + 1; j &lt; high; ++j) {
            if (A[i] &gt; A[j]) {
                int t = A[i];
                A[i] = A[j];
                A[j] = t;
            }
        }
    }
}

int Select(int *A, int low, int high, int k) {
    int p = high - low + 1;
    if (p &lt; 44) {
        sort(A, low, high);
        return A[k];

    }
    int q = p / 5;
    int M[q];

    for (int i = 0; i &lt; q; ++i) {
        sort(A, i * 5, (i + 1) * 5);//将A分成q组，每组5个元素，如果5不整除p，则排除剩余元素
        M[i] = A[i * 5 + 3];//M为q个子序列中的中项（中项集合）
    }

    int mm = M[q / 2];//mm为中项集合的中项
    int *A1, a1 = 0;
    int *A2, a2 = 0;
    int *A3, a3 = 0;
    for (int j = low; j &lt; high; ++j) {
        if (A[j] &lt; mm)A1[a1++] = A[j];
        if (A[j] = mm)A2[a2++] = A[j];
        if (A[j] &gt; mm)A3[a3++] = A[j];
    }
    if (a1 &gt;= k)return Select(A1, 1, a1, k);
    if (a1 + a2 == k)return mm;
    if (a1 + a2 &lt; k)return Select(A3, 1, a3, k - a1 - a2);


}
</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>在一个由n个元素组成的线序集合中提取第k小元素，所需的时间是senta(n)(T(n)&lt;=20cn,c是排序43个元素所需的时间)，特别地，n个元素元素的中值可以在senta(n)时间找出。<br>需要注意的是，虽然此算法所需的时间是senta(n)但是其中的倍数常量（20c）还是太大，我们会在随讲机算法的时候提出一个具有较小倍数常量的算法。</p>
<h1 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h1><p>快速排序（QuickSort）是一种具有senta(nlogn)时间复杂度的排序算法，相比MergeSort，QuickSort不需要辅助的存储空间，这是它的优势。</p>
<h2 id="划分算法（Split）"><a href="#划分算法（Split）" class="headerlink" title="划分算法（Split）"></a>划分算法（Split）</h2><p>在进行快速排序算法的实现之前我们需要先实现划分算法，它是快速排序算法的基础。</p>
<h3 id="什么是划分算法"><a href="#什么是划分算法" class="headerlink" title="什么是划分算法"></a>什么是划分算法</h3><p>设A[low…high]是一个包含n个数的序列，设x=a[low],我们希望对A中的元素进行位置调整后实现当i&lt; new index of x时A[i]</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>对一个指定序列A[low…high]，从A[low+1]开始向后扫描元素，如果当前元素a&lt;=A[low]，则将a与第A[i]的元素互换位置，其中i是从low开始的，每进行一次元素的互换之前i++，最后，当A中元素扫描完毕时所有小于等于A[low]的元素都在i之前的位置（包括A[i]），所以此时只需将A[low]和A[i]的元素互换位置即可满足划分的定义，此时的i对应的就是元素A[low]的新位置.</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>int Split(int *A, int low, int high) {//输入一个序列，返回A[low]对应元素的新位置
    int i = low;
    int x = A[low];
    for (int j = low + 1; j &lt;= high; ++j) {
        if (A[j] &lt;= x) {
            i++;
            if (i != j) {
                int t = A[i];
                A[i] = A[j];
                A[j] = t;
            }
        }
    }

    int t;
    t = A[low];
    A[low] = A[i];
    A[i] = t;

    return i;
}
</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>因为算法split的元素比较次数恰好是n-1，所以它的时间复杂性为senta(n).</p>
<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>算法QuickSort的主要思路是利用Split算法将A[low…high]中的A[low]排列到其正确的位置A[w]，然后对子数组A[low…w-1]和子数组A[w+1…high]递归地进行排序从而产生整个排序数组。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>void QuickSort(int *A, int low, int high) {
    if (low &lt; high) {
        int w = Split(A, low, high);//w为A[low]的新位置
        QuickSort(A, low, w - 1);
        QuickSort(A, w + 1, high);
    }
}
</code></pre><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>算法QuickSort对n个元素的数组进行排序时执行的平均比较次数是senta(nlogn)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/30/致敬那些用键盘改变世界的劳动者！/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/30/致敬那些用键盘改变世界的劳动者！/" itemprop="url">致敬那些用键盘改变世界的劳动者！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-30T14:50:15+08:00">
                2018-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZFd6miaKCfDZgQZ1icuPxNicAfYRMYkJwrqkHOd08t8oBuAN2V7wccicx7eA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1" alt="640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1"><br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZF9w9HpG3JIYolHrKXUFJNB8z6GXyyADlicv3VJfU0E6bkBNuBEFU8sUA/640?wx_fmt=png" alt="640?wx_fmt=png"><br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZFDtYmNVjCB1EO5HuRYP9FkrnUdUXC0T5HBelHzIRMBdJeDPeD50JiajA/640?wx_fmt=png" alt="640?wx_fmt=png"><br><img src="https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuiaciazWxakTEAibLIg5bnCBZFFhHdkLZVe9blrpYfPkCITyp8TyuODTrLToHUWiaYwNiaJ4m3frj07cCQ/640?wx_fmt=png" alt="640?wx_fmt=png"></p>
<hr>
<p>end</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/29/归纳法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/归纳法/" itemprop="url">归纳法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T15:16:51+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>只调用一次的递归叫做尾递归</p>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>基数排序需要经历d次，d为所要排序数列中位数最多的数的位数，其过程是首先根据数列中数的个位的数值将所有数入0~9这10个队列，然后从0~9将元素依次出队，然后再根据十位元素的数值再次入队，然后出队，以此类推重复d次，最终即可完成排序。</p>
<h2 id="时间空间复杂度及稳定性"><a href="#时间空间复杂度及稳定性" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h2><ul>
<li>T(n)=O(d*n) d为排序数中最大数的位数 </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>void radixSort(vector&lt;int&gt; v) {

    int d = GetMaxBit(v);

    int *count = new int[10];
    queue&lt;int&gt; q[10];

    int radix = 1;
    for (int i = 0; i &lt; d; ++i) {
        for (int j = 0; j &lt; v.size(); ++j) {
            int t;
            t = (v[j] / radix) % 10;
            q[t].push(v[j]);
        }

        int p = 0;
        for (int k = 0; k &lt; 10; ++k) {
            while (!q[k].empty()) {
                v[p++] = q[k].front();
                q[k].pop();
            }
        }
        radix *= 10;
    }
    show(v);

}
</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>对于任何的基数都可以归纳出算法，而不仅仅是以10做基数。比如可以把二进制的每四位作为一个数字，也就是用16作为基数，表的数目将和基数相等但是要保证从低位开始将数分配到表中。</p>
<h1 id="整数幂"><a href="#整数幂" class="headerlink" title="整数幂"></a>整数幂</h1><h2 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>很多时候我们需要求实数x的n次方即x^n，按照常规做法一般会对x进行n次自乘以得到x^n，但是这是非常低效的，因为它需要senta（n）次乘法，按照输入的大小来说它是指数级的。</p>
<h2 id="归纳法思路"><a href="#归纳法思路" class="headerlink" title="归纳法思路"></a>归纳法思路</h2><p>一个比较高效的归纳算法是令m=int(n/2)，假设已经知道如何计算x^m,那么根据x^m次方来计算x^n次方就有两种情况：</p>
<ul>
<li>n为偶数 则x^n=（x^m）^2 </li>
<li>n为奇数 则x^n=x(x^m)^2 </li>
</ul>
<h2 id="归纳法实现代码（Exprec）"><a href="#归纳法实现代码（Exprec）" class="headerlink" title="归纳法实现代码（Exprec）"></a>归纳法实现代码（Exprec）</h2><pre><code>int power(int x,int n){
    if (n==0){
        return 1;
    }

    int m=n/2;
    int y;
    y=power(x,n/2);
    y=y*y;
    if (n%2!=0){//如果n是奇数
        y=y*x;
    }

    return y;
}
</code></pre><h2 id="迭代法实现思路"><a href="#迭代法实现思路" class="headerlink" title="迭代法实现思路"></a>迭代法实现思路</h2><p>上述归纳法实现求x^n的关键部分在于采用递归不断判断n/2的奇偶性，所以我们可以采用迭代的办法，因为一个数除以2的k次方后的奇偶性由其化为二进制数的第k低位决定的（因为除法除以2就相当于二进制的左移操作），所以我们可以将n化为二进制数字d<em>k,d</em>(k-1)……d_0，从y=1开始，从左到右扫描二进制数字，如果当前二进制数字为0，则对应递归情况下的偶数情况即应该y=y^2，否则即为y=y(y^m)^2</p>
<h2 id="迭代法实现代码（Exp）"><a href="#迭代法实现代码（Exp）" class="headerlink" title="迭代法实现代码（Exp）"></a>迭代法实现代码（Exp）</h2><pre><code>int Exp(int x,int n){
    int d[10];//假设n化为2进制数字后存在d数组里面
    int y=1;
    for (int i = len(d); i &gt;=0 ; --i) {
        y=y*y;
        if(d[i]==1){
            y=y*x;
        }
    }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>假设每次乘法的时间是常数，那么这两种方法所需的运行时间都是 <strong>senta(lohn)</strong> ，他们对于输入大小来说都是 <strong>线性</strong> 的。</p>
<h1 id="多项式求值（Horner规则）"><a href="#多项式求值（Horner规则）" class="headerlink" title="多项式求值（Horner规则）"></a>多项式求值（Horner规则）</h1><h2 id="场景介绍-1"><a href="#场景介绍-1" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>假设有n+2个数a<em>0,a_1,……,a_n和x序列，要对多项式 <em>*P_n(x)=a_n</em>x^n+a</em>(n-1)<em>x^(n-1)+…+a_1</em>x**<br>求值，传统的办法是分别对每一个子项求值，然后再对整个式子求值，但是这种方法很低效，因为它需要n+（n-1）+（n-2）+…..+1=n(n+1)/2次乘法。</p>
<h2 id="归纳法解决思路"><a href="#归纳法解决思路" class="headerlink" title="归纳法解决思路"></a>归纳法解决思路</h2><p>首先我们发现原式可进行如下化简：<br><img src="https://img-
blog.csdn.net/20180429163357184?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>化简之后我们可以发现如果我们假设已知P<em>(n-1)(x)，那么P_n(x)=x*P</em>(n-1)(x)+a_0,所以就有了算法HORNER。</p>
<h2 id="HORNER算法代码实现"><a href="#HORNER算法代码实现" class="headerlink" title="HORNER算法代码实现"></a>HORNER算法代码实现</h2><pre><code>int Horner(int *A,int n,int x){//数组A的长度为n+2，从A[0]到A[n+1]代表了a_0到a_(n+1)

    int p=A[n+1];//p=a_(n+1)
    for (int i = 1; i &lt;=n ; ++i) {
        p=p*x+A[n+1-i];//p=p*x+a_(n-i)
    }

}
</code></pre><h1 id="寻找多数元素"><a href="#寻找多数元素" class="headerlink" title="寻找多数元素"></a>寻找多数元素</h1><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>令A[1…n]是一个整数序列，如果该序列中的某一个数x在该序列中出现的次数多余int(n/2)，则称x为该序列的 <strong>多数元素</strong> 。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>蛮力法 将每个元素与其他因素进行比较，并且对每一个元素计数，如果某个元素的计数大于int(n/2)，就可以断言它是多数元素。但是这种方法的比较次数是n(n-1)/2=senta(n^2)，代价过于昂贵。 </li>
<li>利用排序 先将原序列进行排序，在最坏情况下，排序这一步需要oumiga(nlogn)次比较。 </li>
<li>寻找中间元素 因为多数元素排序后一定是中间元素，可以找到该序列的中间元素后扫描整个序列该中间元素的出现次数来验证该元素是否为多数元素，由于中间元素可以再senta(n)时间内找到，这个方法要花费ｓｅｎｔａ(n)时间。 </li>
<li>MAJORITY算法 首先我们需要知道，去掉一个序列中的两个不同的数后该序列原来的多数元素现在依然是新序列的多数元素，所以我们……我们能怎么样呢，这不好描述啊，还是看代码吧…… </li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>int majority(int *A, int n) {
    int c = candidate(A, 1, n);
    int count = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (A[i] == c) {
            count++;
        }
    }
    if (count &gt; (int) n / 2) {
        return c;
    } else {
        return NULL;
    }
}

int candidate(int *A, int m, int n) {
    int j = m;
    int c = A[m];
    int count = 1;
    while (j &lt; n &amp;&amp; count &gt; 0) {
        j++;
        if (A[j] == c) {
            count++;
        } else {
            count--;
        }
    }
    if (j == n) {
        return c;
    } else {
        return candidate(A, j + 1, n);
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/29/算法复杂度分析中的符号（Θ、Ο、ο、Ω、ω）简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/算法复杂度分析中的符号（Θ、Ο、ο、Ω、ω）简介/" itemprop="url">算法复杂度分析中的符号（Θ、Ο、ο、Ω、ω）简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T10:44:21+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Θ，读音：theta、西塔；既是上界也是下界(tight)，等于的意思。</p>
<p>Ο，读音：big-oh、欧米可荣（大写）；表示上界(tightness unknown)，小于等于的意思。</p>
<p>ο，读音：small-oh、欧米可荣（小写）；表示上界(not tight)，小于的意思。</p>
<p>Ω，读音：big omega、  欧米伽  （大写）  ；表示下界  (tightness unknown)，大于等于的意思。</p>
<p>ω，读音：small omega、  欧米伽  （小写）；表示下界(not tight)，大于的意思。</p>
<p>Ο是渐进上界，Ω是渐进下界。Θ需同时满足大Ο和Ω，故称为确界（必须同时符合上界和下界）。Ο极其有用，因为它表示了最差性能。具体如图所示：</p>
<p><img src="https://img-
blog.csdn.net/20150717164320363?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="">  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/29/堆和不相交集数据机构——堆/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/29/堆和不相交集数据机构——堆/" itemprop="url">堆和不相交集数据机构——堆</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-29T10:37:08+08:00">
                2018-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>在很多情况下我们需要使用一种具有 <strong>插入元素</strong> 和 <strong>查找最大值元素</strong> 的数据结构，这种数据结构叫做 <strong>优先队列</strong><br>，如果采用普通队列，那么寻找最大元素需要搜索整个队列，开销比较大；如果使用排序数组，插入运算就需要移动很多的元素，开销也会比较大。这时候 <strong>堆</strong><br>就是一种 <strong>有效的实现优先队列的数据结构</strong> 。</p>
<p>堆的特点：</p>
<ul>
<li>父节点大于等于子节点（但是两个子节点之间的大小关系没有要求），这样可以做到 <strong>沿着每条从根节点到叶子节点的路径，元素的键值都是以非升序排列的</strong> 。 </li>
<li>堆是一个 <strong>几乎完全的二叉树</strong> ，所以具有和完全二叉树一样的特点，即一般是存储在一个数组A[n]中，A[i]的左子节点在A[2i]中，右子节点在A[2i+1]中（当他们存在的时候）,A[i]的父亲节点在A[i/2]中（如果存在，i/2向下取整）。 </li>
</ul>
<p>堆需要支持的几种运算：</p>
<pre><code>* delete-max[H] 从一个非空的堆H中删除最大元素并将数据项返回 
* insert[H,x] 将x插入到对H中 
* delete[H,i] 从堆中删除第i项（注意不是删除i） 
* makeheap[A] 将A转换成一个堆 
</code></pre><h2 id="堆上的运算"><a href="#堆上的运算" class="headerlink" title="堆上的运算"></a>堆上的运算</h2><h3 id="两个辅助运算"><a href="#两个辅助运算" class="headerlink" title="两个辅助运算"></a>两个辅助运算</h3><h4 id="SIFT-DOWN"><a href="#SIFT-DOWN" class="headerlink" title="SIFT-DOWN"></a>SIFT-DOWN</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>当某个节点（H[i]）的值大于他的父亲节点的值时，需要通过SITF-UP将这个节点 <strong>沿着从H[i]到H[1]这条唯一的路径</strong><br>上移到合适的位置以形成一个合格的堆。</p>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>将H[i]与其父亲节点H[i/2]比较，如果H[i]大于H[i/2]，则将H[i]与H[i/2]互换，直到H[i]没有父节点或者H[i]不大于H[i/2]。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code> int SiftUp(int *H, int i) {

    while (true) {
        if (i == 1) {
            break;//说明当前i是根节点
        }
        if (H[i] &gt; H[(int) i / 2]) {//如果当前节点比父亲节点大
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
            i = i / 2;
        } else {
            break;
        }
    }
    return 0;
}
</code></pre><h4 id="SIFT-DOWN-1"><a href="#SIFT-DOWN-1" class="headerlink" title="SIFT-DOWN"></a>SIFT-DOWN</h4><h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><p>当某个节点（H[i]，i&lt;=(int)n/2即 <strong>非叶子节点</strong><br>）的值小于它的两个子节点H[2i]和H[2i+1]（如果存在的话）的最大值时，需要将SIFT-DOWN将渗到合适的位置。</p>
<h5 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h5><p>将H[i]与其两个子节点中值最大的元素比较，如果小于最大的那个节点，则将H[i]与其最大的那个子节点互换。</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code> int SiftDown(int *H, int i, int n) {
    while (true) {
        i = 2 * i;
        if (i &gt; n) {
            break;
        }

        if (i + 1 &lt;= n) {
            if (H[i + 1] &gt; H[i]) {//比较两个子节点哪个最大
                i++;
            }
        }

        if (H[i] &gt; H[(int) i / 2]) {
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
        }
    }
}
</code></pre><h3 id="插入（insert）"><a href="#插入（insert）" class="headerlink" title="插入（insert）"></a>插入（insert）</h3><h5 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h5><p>将元素x插入到已有的堆H中</p>
<h5 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先将堆的大小增加1（n++），然后将x放在H[n]中，然后根据需要将H[n]中的元素x进行上移操作，直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以将一个元素插入大小为n的堆中所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code> void insert(int *H,int x,int &amp;n){
    n++;
    //这里默认H开的空间够用
    H[n]=x;
    SiftUp(H, n);//将x根据需要上移
}
</code></pre><h3 id="删除（delete）"><a href="#删除（delete）" class="headerlink" title="删除（delete）"></a>删除（delete）</h3><h5 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h5><p>将堆H中的元素x删除</p>
<h5 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h5><p>用堆中的最后一个元素H[n]替换需要删除的元素H[i]，然后堆的大小减一（n–），然后根据需要对H[i]进行上移或者下渗直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析-1"><a href="#算法时间复杂度分析-1" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><pre><code> void Delete(int *H, int i, int &amp;n) {

    if (i == n) {//如果需要删除的是最后一个元素
        n--;
        return;
    }

    H[i] = H[n];
    n--;

    if (H[i] &gt; H[(int) i / 2]) {//如果当前节点比父亲节点大则需要上移
        SiftUp(H, i);
    } else {//否则进行下渗
        SiftDown(H, i, n);
    }
}
</code></pre><h3 id="删除最大值（deletemax）"><a href="#删除最大值（deletemax）" class="headerlink" title="删除最大值（deletemax）"></a>删除最大值（deletemax）</h3><h5 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h5><p>将堆H中的最大元素x删除并返回最大值。</p>
<h5 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h5><p>用堆中的最后一个元素H[n]替换需要删除的元素H[1]，然后堆的大小减一（n–），然后根据需要对H[1]进行上移或者下渗直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析-2"><a href="#算法时间复杂度分析-2" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><pre><code> int DeleteMax(int *H,int &amp;n){
    int x=H[1];
    Delete(H, 1, n);
    return x;
}
</code></pre><h3 id="创建堆（makeheap）"><a href="#创建堆（makeheap）" class="headerlink" title="创建堆（makeheap）"></a>创建堆（makeheap）</h3><h5 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h5><p>给出一个有n个元素的数组H[1….n]，创建一个包含这些元素的堆。</p>
<h5 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h5><p>类似于分治，首先，H的叶子节点（即最下面的一层单个元素）可以认为是若干个小堆，然后我们从倒数第二层开始，将倒数第二层和倒数第一层的元素进行适当调整，使得调整之后整个二叉完全数的最后两层是若干个子堆，按照这个思路，依次向上走，最终走到第1层的时候就可以保证整个完全二叉树是一个符合要求的堆。</p>
<p>需要注意的是对于一个完全二叉树， <strong>倒数第二层的最后一个元素的下标为int(n/2)</strong> ，（因为倒数第二层的最后一个节点的下标x应该满足x*2=n）.</p>
<h5 id="算法时间复杂度分析-3"><a href="#算法时间复杂度分析-3" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>senta(n)</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><pre><code> void makeheap(int *H,int n){
    for (int i = n/2; i &gt;=1 ; --i) {//从倒数第二层到第一层
        SiftDown(H,i,n);
    }
}
</code></pre><h3 id="堆排序（heapsort）"><a href="#堆排序（heapsort）" class="headerlink" title="堆排序（heapsort）"></a>堆排序（heapsort）</h3><h5 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h5><p>利用堆对数组H[n]进行排序。</p>
<h5 id="实现思路-6"><a href="#实现思路-6" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先将数组H[n]调整成为一个（大顶）堆，这时可以保证H[1]是数组中的最大元素，然后将H[1]与H[n]互换位置，然后再调整1——n-1为一个大顶堆，然后将H[1]与H[n-1]互换，以此类推，最后就可以保证H为一个非升序的数组。</p>
<h5 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h5><p>空间复杂度：因为本算法是在数组H原有的空间基础上进行排序的，所以空间复杂度是Senta（1）。<br>时间复杂度：<br>+ 建堆 senta(n)<br>+ 执行n-1次siftdown nlog(n)<br>所以总的时间复杂度是nlog（n）</p>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><pre><code>void HeapSort(int *H,int n){
    makeheap(H,n);
    int t;
    for (int i = n; i &gt;=2 ; --i) {
        t=H[i];
        H[i]=H[1];
        H[1]=t;
        SiftDown(H,1,i-1);
    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/27/爬取了3W+用户评价后发现用户眼中的坚果3是这样的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/爬取了3W+用户评价后发现用户眼中的坚果3是这样的/" itemprop="url">爬取了3W+用户评价后发现用户眼中的坚果3是这样的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-27T13:21:03+08:00">
                2018-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实现过程介绍"><a href="#实现过程介绍" class="headerlink" title="实现过程介绍"></a>实现过程介绍</h1><h2 id="从网页爬取数据"><a href="#从网页爬取数据" class="headerlink" title="从网页爬取数据"></a>从网页爬取数据</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先我们打开京东商城坚果3 的购买页面：<br><img src="https://img-
blog.csdn.net/20180427131455676?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>然后按F12进入开发者控制台（审查元素）：<br><img src="https://img-
blog.csdn.net/20180427131508694?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>发现什么都没有，不要紧，点开评论区，你就会发现控制台出现类似这些信息：<br><img src="https://img-
blog.csdn.net/20180427131732633?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>控制台从刚才的没有信息到现在获取到当前信息，唯一的变化就是你打开了评论，所以网页返回的评论区内容一定在当前控制台的某个位置，从Name字段一个一个分析，就可以发现很明显的一行：<br><img src="https://img-
blog.csdn.net/20180427131757161?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>很明显这里就是我们需要的评论区数据，然后仔细分析其对应的Headers，就会发现我们获取数据需要的基本信息：<br><img src="https://img-
blog.csdn.net/20180427131809302?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>然后点开preview，就会发现返回数据转化为json格式后的内容：<br><img src="https://img-
blog.csdn.net/20180427131818464?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>进一步打开Response，看到网页返回的原始数据：<br><img src="https://img-
blog.csdn.net/20180427131827248?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看到，网页返回的原始数据是用一个fetchJSON_comment98vv1587包裹着的json字符串，到这里，我们的思路就很清晰了：<br><strong>首先用URL和对应的Query String<br>Parameters模仿网页发送请求，收到的Response将会是一份由fetchJSON_comment98vv1587（）包裹着的包含json数据的String，我们用正则表达式将json数据提取出来，然后对json数据进行解析并获取想要字段的数据即可。</strong></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先根据网页控制台的信息定义相关必要的变量：</p>
<pre><code>url=&#39;https://club.jd.com/comment/productPageComments.action&#39;

QueryStringParameters={ &#39;callback&#39;:&#39;fetchJSON_comment98vv1587&#39;,
       &#39;productId&#39;:&#39;7029545&#39;,
       &#39;score&#39;:0,
       &#39;sortType&#39;:5,
       &#39;page&#39;:0,
       &#39;pageSize&#39;:10,
       &#39;isShadowSku&#39;:0,
       &#39;fold&#39;:1 }
</code></pre><p>需要注意的是这里的url并不是直接将控制台显示的url全部拿过来，而是只要其前一部分，因为如果用控制台上的url，则只能获取到当前页面的评论，我们想要获取全部的评论，所以必须动态变化url，这里我们将url分为两部分写，这样方便后面调整page以获取不同页面的评论。<br>然后实现爬取数据的逻辑代码：</p>
<pre><code>hotcomments = []
while(True):
    t=s.get(url,params=data).text #模拟网页发送请求并接收返回数据

    try:
        t=re.search(r&#39;(?&lt;=fetchJSON_comment98vv1587\().*(?=\);)&#39;,t).group(0)#使用正则表达式匹配‘fetchJSON_comment98vv1587’
    except Exception as e:
        break
    j=json.loads(t) #解析json

    commentSummary=j[&#39;comments&#39;]
    flag=0
    for comment in commentSummary:
        flag=1
        num=num+1
        item = {
            &#39;content&#39;: comment[&#39;content&#39;] ,
            &#39;nickname&#39;: comment[&#39;nickname&#39;],
            &#39;score&#39;: comment[&#39;score&#39;],
            &#39;creationTime&#39;:comment[&#39;creationTime&#39;],
            &#39;productColor&#39;:comment[&#39;productColor&#39;]
        }
        hotcomments.append(item)
    if flag==0:
        break
    data[&#39;page&#39;]+=1  #改变page字段，下一次循环爬取下一页评论
</code></pre><p>当以上当以上代码执行完成之后就可以将所有评论信息放在 hotcomments中，然后就可以从中拿取数据进行分析了。</p>
<h2 id="使用Bar进行各项指标柱状图可视化"><a href="#使用Bar进行各项指标柱状图可视化" class="headerlink" title="使用Bar进行各项指标柱状图可视化"></a>使用Bar进行各项指标柱状图可视化</h2><h3 id="三种不同颜色评论数量所占百分比"><a href="#三种不同颜色评论数量所占百分比" class="headerlink" title="三种不同颜色评论数量所占百分比"></a>三种不同颜色评论数量所占百分比</h3><pre><code>a= productColor.count(u&#39;碳黑色&#39;)
b=productColor.count(u&#39;酒红色&#39;)
c=productColor.count(u&#39;浅金色&#39;)
d=float(a+b+c)
a=float(a/d)
b=float(b/d)
c=float(c/d)

ds = tablib.Dataset()
ds.headers = [&#39;颜色&#39;, &#39;评论数&#39;]

ds.append([&#39;碳黑色&#39;,a])
ds.append([&#39;酒红色&#39;, b])
ds.append([&#39;浅金色&#39;, c])

bar = Bar(&#39;颜色&#39;)
bar.add(&#39;评论数量(%)&#39;, ds.get_col(0), ds.get_col(1))
bar.render(&#39;color_bar.html&#39;)
</code></pre><h3 id="从9号到26号单天评价数量所占百分比"><a href="#从9号到26号单天评价数量所占百分比" class="headerlink" title="从9号到26号单天评价数量所占百分比"></a>从9号到26号单天评价数量所占百分比</h3><pre><code>ds2 = tablib.Dataset()
ds2.headers = [&#39;评价时间&#39;, &#39;评论数&#39;]
f=0.0
for i in range(9,27):
    f=f+creationTime.count(i)

for i in range(9,27):
    ds2.append([str(i), creationTime.count(i)/f])

bar2 = Bar(&#39;评价时间（购买时间）&#39;)
bar2.add(&#39;评论数量(%)&#39;, ds2.get_col(0), ds2.get_col(1))
bar2.render(&#39;time_bar.html&#39;)
</code></pre><h3 id="不同评分所占百分比"><a href="#不同评分所占百分比" class="headerlink" title="不同评分所占百分比"></a>不同评分所占百分比</h3><pre><code>ds3 = tablib.Dataset()
ds3.headers = [&#39;评分&#39;, &#39;评论数&#39;]
e=0.0
for i in range(0,6):
    j=5-i
    e+=score.count(j)


for i in range(0,6):
    j=5-i
    ds3.append([str(j), score.count(j)/e])

bar3 = Bar(&#39;评分&#39;)
bar3.add(&#39;评论数量(%)&#39;, ds3.get_col(0), ds3.get_col(1))
bar3.render(&#39;score_bar.html&#39;)
</code></pre><h2 id="使用WordCloud进行评论词云可视化"><a href="#使用WordCloud进行评论词云可视化" class="headerlink" title="使用WordCloud进行评论词云可视化"></a>使用WordCloud进行评论词云可视化</h2><pre><code>content_text = &quot; &quot;.join(content_list)
bg_pic = imread(&#39;../WoMen_EasonChen/eason2.png&#39;)
wordcloud = WordCloud(mask=bg_pic,font_path=&#39;../Font/SourceHanSansSC-Heavy.otf&#39;,background_color=&#39;white&#39;,max_words=200).generate(content_text)
plt.figure()
plt.imshow(wordcloud,interpolation=&#39;bilinear&#39;)
plt.axis(&#39;off&#39;)
plt.show()
</code></pre><h2 id="可视化结果"><a href="#可视化结果" class="headerlink" title="可视化结果"></a>可视化结果</h2><p><img src="https://img-
blog.csdn.net/20180427131847405?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从图中可以看出，大部分用户比较喜欢碳黑色（74.38%），购买浅金色的用户最少，约占5%<br><img src="https://img-
blog.csdn.net/20180427131913305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看到95%的用户都给出了5分好评<br><img src="https://img-
blog.csdn.net/20180427131924220?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h4 id="最后看一下词云显示的内容"><a href="#最后看一下词云显示的内容" class="headerlink" title="最后看一下词云显示的内容"></a>最后看一下词云显示的内容</h4><p><img src="https://img-
blog.csdn.net/20180427131931868?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在给一张：<br><img src="https://img-
blog.csdn.net/20180427131939309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>坚果3刚发布的时候在网上可以看到很多人在黑他，罗老师也毫不客气地表示“拉黑”这些锤黑，本人不是锤粉也不是锤黑，只是觉得中国像罗老师这样天生骄傲的企业家不多了，就像罗振宇老师说的希望罗永浩成功那样，我也希望罗老师成功，因为中国需要这么一个天生骄傲的企业家，希望罗老师会是下一个乔布斯甚至超越乔布斯，期待锤子科技515可以创造传奇。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/22/使用python绘制混淆矩阵（confusion_matrix）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/使用python绘制混淆矩阵（confusion_matrix）/" itemprop="url">使用python绘制混淆矩阵（confusion_matrix）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T13:46:00+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>涉及到分类问题，我们经常需要通过可视化混淆矩阵来分析实验结果进而得出调参思路，本文介绍如何利用python绘制混淆矩阵（confusion_matrix），本文只提供代码，给出必要注释。</p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code># -*-coding:utf-8-*-
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import numpy as np

#labels表示你不同类别的代号，比如这里的demo中有13个类别
labels = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;, &#39;J&#39;, &#39;K&#39;, &#39;L&#39;, &#39;M&#39;, &#39;N&#39;, &#39;O&#39;]

#y_true代表真实的label值 y_pred代表预测得到的lavel值
y_true = np.loadtxt(&#39;../Data/re_label.txt&#39;)
y_pred = np.loadtxt(&#39;../Data/pr_label.txt&#39;)

tick_marks = np.array(range(len(labels))) + 0.5


def plot_confusion_matrix(cm, title=&#39;Confusion Matrix&#39;, cmap=plt.cm.binary):
    plt.imshow(cm, interpolation=&#39;nearest&#39;, cmap=cmap)
    plt.title(title)
    plt.colorbar()
    xlocations = np.array(range(len(labels)))
    plt.xticks(xlocations, labels, rotation=90)
    plt.yticks(xlocations, labels)
    plt.ylabel(&#39;True label&#39;)
    plt.xlabel(&#39;Predicted label&#39;)


cm = confusion_matrix(y_true, y_pred)
np.set_printoptions(precision=2)
cm_normalized = cm.astype(&#39;float&#39;) / cm.sum(axis=1)[:, np.newaxis]
print cm_normalized
plt.figure(figsize=(12, 8), dpi=120)

ind_array = np.arange(len(labels))
x, y = np.meshgrid(ind_array, ind_array)

for x_val, y_val in zip(x.flatten(), y.flatten()):
    c = cm_normalized[y_val][x_val]
    if c &gt; 0.01:
        plt.text(x_val, y_val, &quot;%0.2f&quot; % (c,), color=&#39;red&#39;, fontsize=7, va=&#39;center&#39;, ha=&#39;center&#39;)
# offset the tick
plt.gca().set_xticks(tick_marks, minor=True)
plt.gca().set_yticks(tick_marks, minor=True)
plt.gca().xaxis.set_ticks_position(&#39;none&#39;)
plt.gca().yaxis.set_ticks_position(&#39;none&#39;)
plt.grid(True, which=&#39;minor&#39;, linestyle=&#39;-&#39;)
plt.gcf().subplots_adjust(bottom=0.15)

plot_confusion_matrix(cm_normalized, title=&#39;Normalized confusion matrix&#39;)
# show confusion matrix
plt.savefig(&#39;../Data/confusion_matrix.png&#39;, format=&#39;png&#39;)
plt.show()
</code></pre><h1 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h1><p><img src="https://img-
blog.csdn.net/20180422134149170?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h1 id="Instructions"><a href="#Instructions" class="headerlink" title="Instructions"></a>Instructions</h1><p>按照代码中的注释将labels、y_true 、y_pred替换为你自己的数据即可。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://blog.csdn.net/guoyilin/article/details/42047615" target="_blank" rel="noopener"> 如何用python画好confusion matrix
</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/17/白话设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/17/白话设计模式/" itemprop="url">白话设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-17T22:37:34+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h2><p><strong>对象怎么来</strong> 提供一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new<br>运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>重点在于Factory类，当一个类的实例化依赖于不同场景时需要使用的，比如根据形状不同实例化不同形状类并返回的demo，根据不同的形状，实例化的Shape对象内部的实现逻辑不一样，这时候就可以使用工厂方法模式，将类内部的实现细节隐藏起来，用户只需要告诉工厂类自己需要什么情况下的产品，工厂就可以自动调用自己内部对应场景的代码从而返回一个用户需要的“产品”。</p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>抽象工厂可以理解为工厂的工厂，比如demo中，首先有两个工厂Factory，分别用来实例化不同场景下的shape和color，然后再有过一个工厂的工厂即FactoryProducer，其根据用户的需求（shape或者color）返回shape工厂或者color工厂，然后用户再用返回的工厂去实例化自己需要的shape或者color。<br>对比工厂方法模式，因为一个工厂只能生产一个产品，比如一个ShapeFactory只能根据不同情况实例化一个不同的Shape，那么当我们需要一整套的产品（比如形状和颜色形成了一套产品）时使用工厂方法显然就不能解决了，所以就需要抽象工厂模式，抽象工厂模式实际上是工厂的工厂，即其作用的目的是为了实例化不同的工厂，用户再通过不同的工厂实例化不同场景下成套的产品。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>通俗来讲就是替用户实现对象的实例化，用户需要使用类的时候不需要实例化，直接通过getInstance就可以拿到需要使用的对象，进而调用对象的方法即可，这个设计模式平时用到的比较多，也比较容易理解。</p>
<h3 id="生成器（建造者）模式"><a href="#生成器（建造者）模式" class="headerlink" title="生成器（建造者）模式"></a>生成器（建造者）模式</h3><p>生成器模式的目的是使用多个简单的对象一步一步构建成一个复杂的对象，比如在一个快餐店的商业案例中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold<br>drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold<br>drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>那么，生成器（MealBuilder）的作用就是实现不同类型汉堡（Burger）与不同类型冷饮（Cold<br>drink）的搭配，即通过MealBuilder这个生成器可以通过组合不同汉堡和冷饮这样简单的类从而狗仔出一个复杂的套餐（Meal）类，这就体现了生成器模式“使用多个简单的对象一步一步构建成一个复杂的对象”的要点，需要注意的是建造者模式与工厂方法模式有类似的地方，但是建造者模式更加关注零件装配的顺序而且生成的对象内部属性本身具有相互依赖性，比如Demo中的食物和对应的容器具有很强的相互依赖性。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式实现的功能就是对象的拷贝，只不过这种拷贝的功能是在类中定义好的，即在定义类的时候就定义好了一个clone的接口，当这个类对应的对象在某一时刻需要拷贝出另一个对象时，只需调用这个对象的clone方法即可返回一个本对象的克隆体，那么为什么不直接实例化一个新的对象而要采用这种克隆的机制呢？想象一下如果一个类的某些属性的值需要从数据库中查询，这样每实例化一个新类就需要做查询的耗时操作，这时候如果直接用一个已有的对象去clone出一个新的对象就可以避免诸如数据库查询之类的耗时操作，提高了软件的执行效率。</p>
<h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p><strong>对象和谁有关</strong> 关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式的要点在于组合和结构，通俗来讲就是通过不同的组合来形成一个体系结构，实现要点是list的使用，以上述demo为例，CEO的下属包含headSales和headMarketing，即CEO这个对象的下属list里面只要添加headSales和headMarketing即可，所以如果把CEO理解为一个东西的话它是由headSales和headMarketing组合而成的（如果没有这两者真不知道CEO存在的意义是什么，一自己当自己的CEO？），而headSales又有若干个salesExecutive下属，所以headSales对象的下属list里面应该添加若干个salesExecutive对象，以此类推（headMarketing由若干个clerk组成）。至此，通过不断的组合，我们就可以由salesExecutive和clerk一路不断组合直到CEO，这就是“组合”的含义，同时也体现了很强的层级关系。</p>
<h3 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>装饰者模式（Decorator<br>Pattern）的目的是向一个现有的对象添加新的功能，同时又不改变其结构，这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供额外的功能。</p>
<p>装饰者模式的主要思路是通过一个新类（Decorator ）将原来的类包装起来，在Decorator 中给原来的类添加新的功能。</p>
<p>装饰者模式顾名思义就是起到一个装饰的作用，即在不改变原来类结构的前提下增加一些新的功能，这种模式一般会产生一个专门的装饰类，联想结构型设计模式的定义（描述不同类之间的关系），装饰者模式实际上描述的就是一个装饰与被装饰的关系，结合上面的demo，被装饰类是实现了shape接口的Rectangle类和Circle类，而装饰类ShapeDecorator是一个抽象装饰类，在其内部定义了装饰shape的方法draw，事实上是一种方法重写（准确来说是增加方法功能），然后在ShapeDecorator的子类RedShapeDecorator中的draw调用了起装饰作用的setRedBorder方法最终达到装饰实现shape子类的目的，从最终的输出也可以看出，装饰类的作用实际上就是在原有类的基础上新增加新的东西，还有一个比较接近现实的例子是玩游戏时开局一个英雄，玩着玩着英雄的装备越来越多、英雄的技能越来越多、英雄的皮肤越来越多，这些效果实际上都是在原来开局裸体（额实在不知道用什么形容词，懂我意思就好～）英雄的基础上装饰进去的，很好地体现了装饰的精髓。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>现实生活中代理的例子其实很多，比如大家搭建服务器从而实现访问某些xx的网址的访问，其原理其实就是在云端搭建一台云主机，这台主机的地址一般是在可以访问你当前计算机不能访问的xx网址的地域（比如东亚的计算机可以访问很多nj访问不到的xx网址），所以当你想要从xx网址获取信息的时候就可以先把请求发给你搭建的云主机，让它去访问xx，然后再把信息返回给你，这样就像你直接访问了xx一样，这就是代理的意思。回到设计模式，代理模式实际上讲的就是一种“代理访问”的概念，当A类不能暴露给B类而B类又想调用A类的方法的时候必须通过一种折中的方法，即B类通过向可以调用A类的C类发送请求从而让C类调用A类干同样的事情，就是这个意思……<br>具先实现其实也很简单，就是一个代理类将被代理类包裹起来，只对外界暴露调用被代理类方法的方法，从而实现代理模式，需要特别注意的是代理模式和适配器模式的区别：<br><strong>适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口</strong> ，和装饰器模式的区别：<br><strong>装饰器模式为了增强功能，而代理模式是为了加以控制</strong> 。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>顾名思义，享元模式体现的就是一种“分享”的实质，即当很多地方都需要用到一个类的对象而实例化这个类又需要耗费很多资源的时候我们就可以把这个类的对象抽取出来，仅仅实例化一次，当以后需要实例化这个类的对象的时候直接把之前实例化的对象返回即可，比如demo中需要实例化不同颜色不同形状的shape对象，而这些对象的存在状态就那么几种，所以使用一个Factory类，当第一次接收到实例化shape类的请求时进行一次实例化并将实例化得到的结果存下来，以后再接收到实例化的请求时直接把之前实例化的同类型的对象返回即可，这样可以大大提高程序执行的效率。</p>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>当一个抽象类有多个实现时，通常用集成来协调他们。抽象类定义对该抽象的接口，而具体子类则用不同方式加以实现。但是此方法的缺点是将子类的抽象部分和实现部分固定在了一起，使得难以对抽象部分和实现部分进行修改、扩充和重用。<br>实现抽象化和实现化之间的解耦，具体到上述demo，抽象化指的是 draw redCircle和draw<br>greenCircle，如果不使用桥接模式，一般的实现方法是根据用户指令的不同（以参数的形式体现），实现不同的draw方法，而使用桥接模式，Circle类不用关心具体如何根据用户传入参数的不同实现不同的draw方法（即实现化部分），Circle类只需要根据用户传入接口的不同调用draw方法即可，具体的实现全都交给了DrawAPI（GreenCircle、ReadCircle）来做，即将draw这个功能的抽象化放在Circle类，实现化放在DrawAPI（GreenCircle、ReadCircle），从而实现了抽象化和实例化的分离。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>（这个模式描述的不是很好，感觉还是demo更容易理解一点）<br>作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。<br>注意，要点是要在原来类的基础上使原本不兼容的功能变得兼容。<br>Adapter类一般是用来实现与原有类不兼容的功能，比如demo中的MediaAdapter实现了MediaPlayer没有的特殊功能，用户只要调用AudioPlayer中的play方法，AudioPlayer会自动根据音频的类型选择不同的play方式，当音频类型不符合传统player的能力时AudioPlayer会使用adapter去调用之前不兼容的方法（功能），这样就实现了所谓的适配。</p>
<p>类适配器和对象适配器的区别：<br>类适配器的重点在于类，是通过构造一个继承Adaptee类来实现适配器的功能；<br>对象适配器的重点在于对象，是通过在直接包含Adaptee类来实现的，当需要调用特殊功能的时候直接使用Adapter中包含的那个Adaptee对象来调用特殊功能的方法即可。</p>
<h2 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h2><p>对象与对象在干嘛<br>这些设计模式特别关注对象之间的通信</p>
<h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><p>模板方法模式顾名思义就是定义了一个特殊的方法，这个方法的大体框架是写死的，比如demo中抽象类Game的play方法，它规定了所有实现类的play方法有且仅能有模板方法中定义中的行为，但是这些行为具体如何实现则不是模板方法所关心的，说白了就是模板方法规定了如果调用这个方法会干嘛，但是怎么去干就不是它所关心的重点了。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式用一句话描述就是当一个类的对象（被观察者）的状态发生改变时同时其他依赖于它的对象（观察者）的状态也做相应的改变（做相应的动作）。</p>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式本质上就是一种遍历聚合对象的方式，这里的聚合对象一般具有较多的实例，比如java中的list等，也就是说对于有些对象，我们更加偏向于它的属性而不是行为，而迭代器模式提供了一种较为隐蔽的遍历这些对象属性的方法，通过经典的hasnext方法和next方法的配合使用，从而实现顺序访问聚合对象中各个元素,<br>而又无须暴露该对象的内部表示。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链模式的本质就是一条链，通过demo可以发现其实现方式和数据结构中的链表有很相似的地方，思想就是形成一条链，如果当前节点处理不了某些行为，则把这个行为请求转移到其下一级，以此类推，比较常见的实例就是java或者python中经常用到的try<br>catch机制，当某个方法有可能抛出异常而当前方法无法处理的时候我们就会可能将这个异常throw到外层，即责任链中的下一级。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式的本质就是一种备份机制，其思路是将对象的状态在用户需要的时候备份下来，当需要状态回滚的时候直接将将对象的状态恢复到之前备份的状态，我们经常用的git版本控制管理系统其实就是一个特殊的备忘录模式，其在你需要的时候将你的仓库备份下来，这样你就可以在后期的开发中随时找到你之前备份的仓库状态，但是需要注意的是备忘录模式的重点是对象，其真正的目的是将单个对象的状态保存下来，至于其他的状态备份则不是它所侧重的。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式实质上就是将命令抽象到一个具体的类中，即这个类是专门去执行某个命令的，比如demo中，SellStock就是专门执行sell这个命令的，当用户需要sell的时候只要实例化SellStock然后excute就可以完成sell，还有一个比较常用的例子是GUI开发中按钮（button）的作用，每一个按钮都是一个对象，当用户点击某个按钮后就会触发一个相应的命令，用户看到的是点击按钮产生效果，而代码层面上是实例化的按钮对象执行类似于demo中的excute方法完成自己的“命令”。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式将各个状态所对应的操作分离开来,即对于不同的状态,由不同的子类实现具体操作,不同状态的切换由子类实现，比如上面的demo，同样是实现doAction根据不同的状态执行不同的逻辑，按照传统的方法需要使用if<br>else进行判断，但是使用状态模式则可以将不同的状态实例化为不同的子类，然后在不同的子类（实际上是不同的状态）中实现不同的逻辑，客户端使用的时候只需要实例化不同的状态的子类就可以调用不同状态下的同名方法。</p>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式解决的是根据访问者的不同而执行不同的行为，即同样一个方法（方法名相同），但是当A调用这个方法时执行的是逻辑A，B调用这个方法时执行逻辑B，这种情况下就需要使用访问者模式来实现。具体到demo，我们想要实现不同的ComputerPart调用accept的时候执行不同的逻辑，只需要构造一个访问者类ComputerPartDisplayVisitor，它根据accept的调用者的不用执行不同的逻辑，而调用者只需要将this传入accept方法即可，accept方法会根据传入的参数类型的不同调用不同的逻辑（visit）。</p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>当一个类的行为需要根据不同的状态改变时就需要使用策略模式，比如demo中Context类的executeStrategy方法执行的逻辑需要根据Context的Strategy成员的状态的变化而变化，传统地可以通过if<br>else语句来实现对Strategy状态的判断进而实现不同的算法，但是如果采用策略模式，Context类就不必关心当前Strategy的状态，而将这种执行不同算法的控制权交给了客户端。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/16/适配器模式之类适配器与对象适配器的区别及代码实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/适配器模式之类适配器与对象适配器的区别及代码实现/" itemprop="url">适配器模式之类适配器与对象适配器的区别及代码实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-16T19:22:49+08:00">
                2018-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是适配器模式？"><a href="#什么是适配器模式？" class="headerlink" title="什么是适配器模式？"></a>什么是适配器模式？</h1><p>适配器模式（Adapter）：直观理解就是使原来不能一起相互工作（接口不兼容）的两个功能通过Adapter兼容在一起。</p>
<h1 id="类适配器和对象适配器"><a href="#类适配器和对象适配器" class="headerlink" title="类适配器和对象适配器"></a>类适配器和对象适配器</h1><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p>Adapter 类继承Adaptee （被适配类），同时实现Target 接口（因为 Java 不支持多继承，所以只能通过接口的方法来实现多继承），在<br>Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。</p>
<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>不使用多继承或继承的方式，而是使用直接关联，或者称为委托的方式。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>类适配器的重点在于类，是通过构造一个继承Adaptee类来实现适配器的功能；<br>对象适配器的重点在于对象，是通过在直接包含Adaptee类来实现的，当需要调用特殊功能的时候直接使用Adapter中包含的那个Adaptee对象来调用特殊功能的方法即可。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="类适配器-1"><a href="#类适配器-1" class="headerlink" title="类适配器"></a>类适配器</h2><pre><code>// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类
class Adaptee {
    public void specificRequest() {
        System.out.println(&quot;被适配类 具有特殊功能...&quot;);
    }
}

// 目标接口，或称为标准接口
interface Target {
    public void request();
}

// 具体目标类，只提供普通功能
class ConcreteTarget implements Target {
    public void request() {
        System.out.println(&quot;普通类 具有普通功能...&quot;);
    }
}

// 适配器类，继承了被适配类，同时实现标准接口
class Adapter extends Adaptee implements Target{
    public void request() {
        super.specificRequest();
    }
}

// 测试类
public class Client {
    public static void main(String[] args) {
        // 使用普通功能类
        Target concreteTarget = new ConcreteTarget();//实例化一个普通类
        concreteTarget.request();

        // 使用特殊功能类，即适配类
        Target adapter = new Adapter();
        adapter.request();
    }
}
</code></pre><p>测试结果：<br>普通类 具有普通功能…<br>被适配类 具有特殊功能…</p>
<h2 id="对象适配器-1"><a href="#对象适配器-1" class="headerlink" title="对象适配器"></a>对象适配器</h2><pre><code>// 适配器类，直接关联被适配类，同时实现标准接口
class Adapter implements Target{
    // 直接关联被适配类
    private Adaptee adaptee;

    // 可以通过构造函数传入具体需要适配的被适配类对象
    public Adapter (Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    public void request() {
        // 这里是使用委托的方式完成特殊功能
        this.adaptee.specificRequest();
    }
}

// 测试类
public class Client {
    public static void main(String[] args) {
        // 使用普通功能类
        Target concreteTarget = new ConcreteTarget();
        concreteTarget.request();

        // 使用特殊功能类，即适配类，
        // 需要先创建一个被适配类的对象作为参数
        Target adapter = new Adapter(new Adaptee());
        adapter.request();
    }
}
</code></pre><p>测试结果：<br>普通类 具有普通功能…<br>被适配类 具有特殊功能…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/04/13/那些活在浪里的创业者最终被拍成了电影/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/13/那些活在浪里的创业者最终被拍成了电影/" itemprop="url">那些活在浪里的创业者最终被拍成了电影</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-13T17:41:58+08:00">
                2018-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>“我又融了一个亿。”</p>
<p>在创业圈，这句话是奖章，也是把创业者逼至悬崖的剑。</p>
<p>中国互联网创业刚经历了最初的十年，创业者活在浪里。</p>
<p>这些浪里的人，包括罗永浩、戴威、张颖、Papi、傅盛、安传东，也包括了金星、马薇薇、唐岩、许单单、孙海涛、孟雷和潘飞。</p>
<p>2008年，摇滚乐队R.E.M.把西南偏南带到了中国。</p>
<p>那年，《断背山》男主角希斯·莱杰去世，R.E.M.乐队在西南偏南演出时将新歌献给了他。中国媒体刊发了这篇报道，人们第一次认识到了这个大洋彼岸的音乐节。<br><img src="https://img-
blog.csdn.net/20180507190557455?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>其实，在那年的西南偏南上，最火爆的是扎克伯格的采访。因为话题过于陈旧，一位与会者直接大声打断，引来一片欢呼。人们将这件事发到了Twitter上，西南偏南的知名度也因此大幅提升。</p>
<p>就在西南偏南举办的同时，苹果相继发布了iPhone软件开发包和预装App<br>Store的3G版iPhone。智慧的迅速变现让不少人蜂拥而至，掀起了一股开发热潮，移动互联网浪潮的序幕正式拉开。</p>
<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>对大多数中国人来说，2008年最不可磨灭的记忆是北京奥运会，很多人为此开始苦练英语。</p>
<p>那年，36岁的罗永浩开始了人生的第一次创业，成立“老罗英语”。</p>
<p>消息公布后，他遭到了很多粉丝的谩骂，“你不是一个理想主义者吗？你怎么做生意去了？”罗永浩觉得这种指责十分滑稽，后来干脆把自己的演讲主题改成了《一个理想主义者的创业故事》。</p>
<p>在与这场演讲一同发售的自传《我的奋斗》里，罗永浩写道，“每一个生命来到世间，都注定要改变这个世界，你别无选择”。<br><img src="https://img-
blog.csdn.net/20180507190610663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="罗永浩"></p>
<p>那年，罗永浩的另一个身份是网易的评委，四处开炮。这个活动的发起人是唐岩。当时，唐岩还是网易奥运频道的主编。</p>
<p>后来，罗永浩想做手机，但始终筹不到钱，中途萌生过先做个网站赚钱的念头。唐岩问他，你到底想做什么？老罗老实说：手机。唐岩一口应下，“我帮你找钱”。</p>
<p>2013年，智能机的出货量首次超越功能机。两个传统巨头诺基亚和摩托罗拉先后被收购，功能机的时代画上了句号，智能机全面进入了人们的生活。</p>
<p>这其中流露出的机会，被一个叫张颖的人抓住了。2008年，他创立了经纬中国，投资团队只有8个人，也没有定下豪赌移动互联网的战略，并不被人看好。</p>
<p>那年，一个刚满30岁的产品经理跟所在的公司决裂离职，举目无亲。这个年轻人就是傅盛。</p>
<p>张颖看到这个消息，要来电话打了过去，俩人下午就碰了头。张颖建议傅盛去虎跳峡散散心，并邀请他到经纬做EIR（入驻企业家）作为创业前的过渡。这段经历，也为经纬之后大举从互联网公司招募年轻人埋下了伏笔。<br><img src="https://img-
blog.csdn.net/20180507190624171?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>张颖</p>
<p>那年秋天，美国第四大投行雷曼兄弟宣告破产。这只曾被纽约大学金融教授罗伊·史密斯形容为“有19条命的猫”，耗尽了自己的最后一条命。随后，美国次贷危机迅速演变成全球金融危机。</p>
<p>金星的第一次创业也在这时宣告失败。那是一个叫“美丽家族”的购物分享社区，模式与后来的蘑菇街很像。金融危机袭来后，已经谈妥的风投无法落实。他问家里借了一笔钱，强撑了一段时间，弹尽粮绝后不得不解散了公司。</p>
<p>他对仅剩的几名员工说，公司账上没钱了，就剩下这些电脑，大家分一分吧。吃完散伙饭后，金星一个人躲在办公室里哭了一下午。之后的很长一段时间，他都陷入在悲伤中不可自拔。</p>
<p>这些创始人只想躲起来乃至干脆去死的时刻其实是通往成功的必经之路。创业就像搏击，艰辛而孤独，你必须时刻准备着迎接击打，一次又一次。被击中后，可能痛苦不堪，但也只能等肾上腺素消失后，再去打下一个回合。</p>
<p>2008年，姜逸磊还在中戏导演系念大三，刚以“papi酱”为名注册了自己的豆瓣账号。</p>
<p>这一年，全球第一家共享经济公司Airbnb迎着金融危机诞生。为了推广，布莱恩·切斯基决定去西南偏南碰碰运气，但最终一共才定出去了两间房，其中一间还是他们自己定的。总之，这门生意当时完全没有任何火起来的迹象。</p>
<p>这时，后来成为中国共享经济引领者的戴威还在读高二，他的志向是考北大。</p>
<p>在移动互联网开端的这一年，未来还是面目模糊的样子，人人都在摸索着前行。</p>
<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>2011年，乔布斯的辞世引发了海啸般的悼念。</p>
<p>人们感叹苹果失去了一位有远见的天才，世界失去了一位出色的人类，一个传奇就此落幕。</p>
<p><img src="https://img-
blog.csdn.net/20180507190657755?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>很多人陷入到“成为下一个乔布斯”的期待中，江湖风起云涌。尽管罗永浩已经从英语培训里挣到了钱，但他感到自己真正热爱的事业终于来了，“手机行业唯一的聪明人死后，不是我选择了这个行业，是命运选中了我。”</p>
<p>他遭遇了很多人的嘲笑和质疑，甚至有600多人在网上诅咒他死全家。罗永浩一度觉得，自己好像没有那么爱这个世界了。但他坚持下来了，因为“不被嘲笑的愿望是不值得去实现的。”</p>
<p>罗永浩的手机梦想埋下种子时，他日后的投资人唐岩刚刚开始创业。上司方三文辞职创立雪球网后，唐岩意识到宴席终究要散场，他开始琢磨着自己出来单干。</p>
<p>唐岩判断，将来在移动端一定会有一个社交帝国，于是他做了陌陌。但这个想法投资人并不买账。有人问腾讯做陌陌这个事怎么办？唐岩心想，该怎么办就怎么办呗，不能因为这个可能性就不干了。<br><img src="https://img-
blog.csdn.net/20180507190718340?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>唐岩</p>
<p>移动互联网创业之风兴起时，张颖敏锐地注意到，人们黏在手机上的时间成倍增加，决定“豪赌移动互联网”，因为“一个能让手机变得像人体器官一样的行业，可以构成对任何传统行业的颠覆”。</p>
<p>他制定了人海战术，从互联网招了一批没有投资经验的产品经理来做投资。刚刚加入经纬的王华东，在微博上刷到了陌陌的内测版。陌陌正式上线4周后，就冲到了App<br>Store社交类免费榜第三，王华东立刻安排了和唐岩的再次见面。一拍即合的张颖和唐岩，当场签下了投资意向书。</p>
<p>这一年，傅盛创立的可牛影像与雷军的金山合并后，一直没有在市场上找到自己的位置——PC上有360，只能做到第二；手机上有360和腾讯，只能做老三——这是“注定的结果”。为此，傅盛特别痛苦，天天琢磨着怎么突破。</p>
<p>毕业后的papi酱也处于迷茫期，她说自己每天都站在人生的“米字路口”，凡是和专业沾边的工作都尝试了一圈。</p>
<p>她甚至去剧组试过几次戏，但总是被嫌弃，别人比她年轻、比她高、还比她好看……后来，她又尝试过导演，也写过剧本，但最后都不了了之。</p>
<p>最穷的时候，面条青菜就能应付一顿。她说，那时候做得最有追求的事情是定期买彩票。</p>
<p>失意之人又何止于她。</p>
<p>这一年，许单单开了国内首家众筹创业咖啡馆，邀请了一大批企业界、投资界的重要人士加盟，光股东就有100多位。但咖啡馆很难盈利，3W咖啡亏得一塌糊涂。</p>
<p><img src="https://img-
blog.csdn.net/20180507190741844?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>孟雷正处在人生的第一次创业中。他的创业方向是服务高端人群的国际头等舱、公务舱机票预订等服务。虽然公司年利润超两千万，但基于对旅游产业的洞察，孟雷意识到，传统方式在未来会遇到极大的瓶颈。</p>
<p>孙海涛在杭州进行自己第三次创业。那时，他隐约觉得这个项目模式走不通了，<br>“作为CEO，我感觉是带着一帮人在巷子里跟人打架，但是打赢了你也出不去，因为你是在巷子里面。那时候很迷茫，想转型。”</p>
<p>地球的另一边，Airbnb这次在西南偏南迎来了曙光。暴增的音乐节参与人数让房东看到了商机，订不到酒店的人也找到了住处。这一次，Airbnb终于火了。</p>
<p>这一年，机敏的创业者们嗅到了移动互联网未来的方向，但他们并不被理解，依然在通往成功的路上孤独前行。当然，也不是每一个人都有好运降临。更多的人，仍然在焦虑和无助中试着拨开迷雾。就像丘吉尔所言：既然必须穿越地狱，那就走下去吧。</p>
<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>2014年，乌镇举办了首届世界互联网大会，中国成为了世界互联网的一极。</p>
<p>此时，中国智能手机正处于井喷期，每个季度销售量达到9000万台，是美国市场的三倍，80后90后平均每人每天在手机上花去3个小时。</p>
<p>草蛇灰线，伏脉千里。移动互联网的全面爆发，让那些眼光长远的人迎来了收获期。</p>
<p>陌陌就是其中的代表。上线三年的陌陌，在纳斯达克挂牌。两岁的儿子替唐岩敲响了开市钟，成为史上最小的敲钟人。唐岩也成为了《财富》杂志“全球40位40岁以下的商界精英”中的唯一中国上榜者。</p>
<p>但他说，“不是说钱不好，但钱有点平凡。”</p>
<p>傅盛也迎来了他的高光时刻。上市的猎豹，成为中国移动互联网公司出海的样本。</p>
<p>上市时，傅盛把五岁的女儿带去了美国的迪士尼。看着玩耍的女儿，他掉下了眼泪——梦想带领傅盛和猎豹走向了从未抵达的世界。</p>
<p>此时的经纬，累计投资了190家公司。张颖的办公室里有一块黑板，上面密密麻麻地记录着经纬系每家公司融资、并购行进的阶段。他常关上办公室的门，在黑板前审视河山。</p>
<p>“投资圈是个江湖，本该有门有派，可并不是谁都能被称为系。我的理解是没投资过100家，没有系统的布局，没有固执的行业关注，不能称之为系。”张颖说，“我们是哪一派我不好说，但你得承认，经纬有称‘系’的资格了。”</p>
<p>这一年，张颖日后投资的戴威刚刚开始创业。那时，戴威刚从青海支教回来，创业圈的风起云涌让戴威也有些心动。他在宿舍里完成了域名ofo的注册，这个创业项目很快获得了100万的天使投资。</p>
<p>没过多久，钱烧光了，工资发不出来的戴威开始失眠。他跑遍了市面上几十家基金，没有人看好这个项目。在整个资本市场最火热的时候，他一分钱也没融到。</p>
<p>烧完100万，戴威非常内疚也不甘心。他开始思考用户的痛点，最终决定转型做共享自行车。</p>
<p>2015年5月，ofo在微信公号上发布文章《这2000名北大人要干一票大的》，宣布将为北大校园提供超过一万辆自行车，同时呼吁北大师生贡献出自己的单车。文章末尾写道，“100多年来，有很多北大人改变北大，也改变了世界，这次轮到你了！”<br><img src="https://img-
blog.csdn.net/20180507190826885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>戴威</p>
<p>戴威在北大四处推广共享单车时，曾与草根创业者安传东打过一次照面。一年之后，两人境遇大相径庭。</p>
<p>安传东出生于河南安阳的农村。他曾跟随做泥瓦匠的父亲到北京，顶着烈日在天坛搬砖。干完之后，老板企图赖账。大家手拉手上天台要跳楼，这才维权成功。</p>
<p>他第一次认识到现实的残酷，心里想着，我以后一定要留在北京，在这个城市出人头地。</p>
<p>2014年，安传东如愿留在了北京。但他觉得，在这个时代只有创业才能实现人生的翻盘。那时候，他没有经验也没有人脉，在一个孵化器睡了九个月的会议桌，才拉到了第一笔钱。</p>
<p>“每天都不挣钱，每天都往外支出，电费怎么那么贵啊？也是蛮让人心慌的。”安传东每天都生活在恐惧之中，靠写文案挣钱给同事发工资，最苦的时候自己连4毛钱公交车费都拿不出来。</p>
<p>最终，安传东没能成为厮杀的胜者。团队解散，只剩下了他一个人，但他还是不想放弃。“合伙人走了可以再找，高管走了可以再招，没钱了可以再融，但我要是放弃了，公司就真没了。”<br><img src="https://img-
blog.csdn.net/20180507190840809?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>安传东</p>
<p>孟雷开始了他的共享经济创业。他卖掉了之前的公司，创立了一个专门连接境外华人司导和出境游用户的包车游品牌——皇包车旅行。后来，他还挖来了在旅行行业深耕十年的潘飞作为公司的CEO。</p>
<p><img src="https://img-
blog.csdn.net/20180507190912693?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>孟雷（左）潘飞（右）</p>
<p>许单单创办了拉勾网，他希望做一个薪资透明、每一封简历都有回馈的招聘网站。“尊严在当下社会是最值钱的。”许单单觉得，只要有效击中“尊严”这个社会痛点，网站做起来，是毫无悬念的。</p>
<p>这一年，珠海姑娘马薇薇和丈夫离了婚，父亲又查出了癌症。为了逃离阴霾，她坐上了北上的飞机，参加了《奇葩说》，并获得了冠军。马薇薇在节目中金句频出。比如，“这是一个什么都缺，唯独不缺梦想的年代。”她的这番话被视为金玉良言，在网上热传。</p>
<p>这一年，棱镜门主角斯诺登以远程的方式登陆西南偏南。他的发言掀起了公众对数据隐私、数据开放的思考，也促进了科技公司加强隐私保护的意识。</p>
<p>这一年，移动互联网全面爆发，人们看到了前所未有的创业速度——一家公司在三四年里实现了从有收入到有利润再到上市，创业者正以前所未有的速度完成造梦。这种速度，令围观者，甚至创业者本人惊叹，也吸引了越来越多的人加入创业大潮。</p>
<h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>2016年，全球智能机销量近15亿部，庞大数字下是仅2%的增长率，市场迎来停滞。</p>
<p>这年的世界互联网大会上，王兴提出了互联网下半场的概念。“之前中国互联网的发展，在很大程度上靠的是人口红利，因为用户在快速增长，每年卖几亿部智能手机，大家的业务跟着水涨船高。但是现在，这个时代已经过去了，智能手机的年销量已经不增长了，总体网民的增长也大幅趋缓。”</p>
<p>与此同时，中国出现了25461支私募股权投资基金，可投资规模达4.29万亿元。数万亿资金像饿狼一样四处觅食，任何能带来用户流量和现金流的项目都遭到了疯狂的追捧。</p>
<p>这一年，这样的赛道有三个：共享单车、网络直播、内容创业。</p>
<p>2016年，ofo走出校园，日订单量从200迅速攀升至50万单。9月底，滴滴宣布战略投资ofo。戴威和共享单车从无人问津到炙手可热，似乎就是一夜之间。</p>
<p>有投资人说，“如果你人不在北京，基本上就投不进去了”。截至当年底，ofo完成了五轮融资，身后站着几乎所有重量级的投资机构。这样的情况，戴威从来没有遇过，他甚至失眠了两晚。</p>
<p>《胡润百富榜2017》显示，戴威成为首位上榜的90后。他创办的ofo获得了互联网史上最快最炫目的“融资加速度”。共享单车席卷全球，成为了“新四大发明”之一。</p>
<p>另一个赛道里，直播行业凶猛崛起，唐岩加入了直播大军之中。</p>
<p>上市后，陌陌股价始终被低估。那段时间，深夜不眠的唐岩经常看《我是歌手》，琢磨着做个有逼格的版本出来。高管全体反对，但他还是强制执行了。只不过，陌陌最终推出的是全民直播。唐岩抓住了大潮，局势一举扭转。2016年直播营收猛涨，陌陌开始迈向高点。</p>
<p>“你要非说理想败给了现实也可以。但理想和现实，肯定不是一个黑白分明的东西。”唐岩说，“人成熟的过程，本来就是一个不断妥协的过程”。</p>
<p>资本受益于时代浪潮，同时也在助推时代浪潮的前行。内容创业的风口里，papi酱和马薇薇是最大的获益者和代表者。</p>
<p>这一年，papi酱成了“第一网红”，拿到了1200万的投资，站上了网红界的金字塔塔尖。同时，她的首支贴片视频广告拍出了2200万的天价。由此，她达到了个人流量的最高点。</p>
<p>谈及自己的成功时，papi酱一脸庆幸地说，“感谢互联网的诞生，互联网是谁发明的啊！”<br><img src="https://img-
blog.csdn.net/20180507190947424?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>papi酱</p>
<p>马薇薇也凭借奇葩说中积攒的粉丝和流量，创立了米果文化，踩上了风口。好友评价说，“马薇薇是一个最能够闻到钱的味道的人”。</p>
<p>孙海涛看到了投资的高回报，从创业者转向投资者，带领着51信用卡开始进行产业投资布局。<br><img src="https://img-
blog.csdn.net/20180507191002321?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>孙海涛</p>
<p>这一年，锤子亏损4亿元，一度徘徊在破产的边缘。罗永浩说，自从他做手机以来，他的头发掉了一半，胆结石大了一倍，体重增加了20%，但这些跟他获得的无穷无尽的快乐、满足、成就感和难以置信的温暖支持和鼓励相比，根本不值一提。</p>
<p>为了和科技走得更近一些，奥巴马成了首位参加西南偏南的美国总统。他翘掉了里根总统遗孀的葬礼，被不少政治界人士批评，回馈他的是巨星演唱会般的开场。至此，西南偏南真正走向了大众。</p>
<p>这一年，踏着时代的浪尖，很多人赶上了移动互联网的末班车，怀抱着希望，也在甘苦中煎熬。随着互联网下半场的开启，所有人都不得不承认竞争更残酷了。上半场的时候，错了也许还有机会。但现在，如果错了，想要翻身就更为艰难了。</p>
<h1 id="5"><a href="#5" class="headerlink" title="5"></a>5</h1><p>2017年，移动互联网正在经历十字路口，它可能在等着创造新的辉煌也可能在等着低谷降临。创业者和投资人都意识到，当有了超级应用以后，流量的获取变得越来越难，谁懂得高效获取和利用流量，谁就有权力主宰新城邦。</p>
<p>这一年，我们拍摄了一部纪录片《燃点》，试图记录正在发生的创业史。</p>
<p>这一年，为了筹钱，罗永浩和直播平台签订合作，甚至以个人名义借款，以此维持公司的运转。因为他知道，公司活着就意味着一切。</p>
<p>罗永浩将2017年形容为“起死回生”。经历了大半年的生死煎熬，锤子科技终于扭转了颓势——坚果Pro 和坚果 Pro 2<br>接连赢得了好评，销量上也收获了前所未有的佳绩。</p>
<p>“通往牛逼的路上，风景差得让人只想说脏话，但创业者在意的是远方。”罗永浩对创业这件事充满了热爱和任性，不管别人认为这条路适不适合他，他都要走下去。</p>
<p>陌陌收购探探，成为2018年农历新年后的第一场互联网公司收购。但唐岩依然有他新的焦虑。</p>
<p>这一年，经纬迎来了十周年纪念日。经纬系450多家公司，占据了中国移动互联网的半壁江山。即便如此，张颖还是在焦虑：“我们做得那么好了，我们怎么能再错过呢？”</p>
<p>狂飙猛进的共享单车市场进入胶着期，摩拜被王兴的美团收购了，ofo一度被传账上现金仅能支持一个月。唱衰的声浪都压在了戴威的肩上，直到新一轮融资完成，他才松了一口气。</p>
<p>但戴威仍然没有忘记他的初心，“我一直认为应该去做改变世界的事情。这是一个中国原创的，并且为全世界人去提供便捷服务的公司。”这也是ofo的愿景——让世界没有陌生的角落。戴威从不把情怀挂在嘴上，但你能从他的脸上看到，他还是那个愿意相信“美好终将发生”的人。</p>
<p>对傅盛来说，这也是艰难的一年。他问埃隆•马斯克：你做SpaceX、特斯拉，是不是觉得这件事情能赢？马斯克说，“我真的不知道我是不是一定能赢，这件事非常难，但我做这件事并不是因为它容易，就是因为它难。难，才有我做的价值；难，才有机会取得不一样的成就。”傅盛觉得，猎豹今天也处在这样的阶段。</p>
<p><img src="https://img-
blog.csdn.net/20180507191020854?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>傅盛</p>
<p>安传东经历了第三次失败，又一个项目草草结束。过年的时候，他跟父亲说起了在北京的创业经历，说着说着就掉下了眼泪。最近，在投资人的鼓舞下，安传东又开始了新一轮创业。</p>
<p>安传东屡战屡败的模样像极了年轻时跌跌撞撞的我们——我们都有过他那样非常努力的时刻，年轻、充满激情，但没有经验、没有资源、一无所有……一次又一次被命运击打。每个创业者都可以在安传东身上找到自己的第一次：成功了，就是一道风景；失败了，也是痛苦但舍不下的回忆。</p>
<p>金星的第三次创业四平八稳，他抓住了“男性创业，女性整形”的潮流，创立了医美平台新氧。2017年的第一个工作日，成立三年的新氧开始盈利。金星越来越成熟、稳当、有条不紊，他的现在，就像长大了的我们。<br><img src="https://img-
blog.csdn.net/20180507191034956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>金星（左）</p>
<p>医美整形的每一步都面临着伦理的质疑，在对立中探索的金星也面临着一部分创业者的终极命题：如何领航一个不成熟的行业，又能在前行的同时避开暗礁？</p>
<p>行业虽不同，困惑却如出一辙。papi酱和马薇薇作为大众娱乐明星已经成功，但作为创业者，她们还在各自寻找着更清晰的方向。</p>
<p>罗辑思维撤资后，面临质疑的papi酱开始探索从个人IP进化到MCN平台，她做了papitube。</p>
<p>马薇薇经历着同样的瓶颈，严重的失眠症长期困扰着她。</p>
<p><img src="https://img-
blog.csdn.net/20180507191046794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>马薇薇</p>
<p>焦虑也许正是这个时代的候群症。对抗焦虑的最好手段，就是不甘现状和剑及履及的进步。</p>
<h1 id="6"><a href="#6" class="headerlink" title="6"></a>6</h1><p>十年如弹指般流逝，移动互联网浪潮全面席卷中国，以更高的效率和新的消费者互动关系，重构了商业的基本逻辑——信息获取、社交、购物、日常服务以及金融支付等方式都发生了翻天覆地的改变。</p>
<p>《燃点》的主角们也都完成了自己的逆袭，他们身上都有着鲜明的时代烙印，他们的故事，就是一部正在发生的创业史。</p>
<p>在这十年里，中国的经济总量增长了2.5倍，一跃超过日本，居于世界第二；人民币的规模总量增长了3倍，外汇储备增加了1.5倍；网民数量增长了2.5倍，电子商务在社会零售总额中的占比增长了13倍；中产阶层人口数量达到2.2亿，每年出境旅游人口增加了2.7倍；中国的消费者每年买走全球70%的奢侈品，而他们的平均年龄只有39岁。</p>
<p>今年是改革开放的第40个年头。40年前，高考实现了市场经济下最早的人才选拔。40年后，在一个愈加成熟的商业中国，创业者如走上搏击台，实现了以弱胜强的创富神话。</p>
<p>曾经，人们常用Copy to China来形容中国的发展模式，即将美国的创新抄袭到中国，国人大多也有这样的文化不自信。这十年来，人们一次次看到了Copy<br>to Global，Made in China正在变成Created in China，中国的创业者也从跟随者变成了引领者。</p>
<p>我们试图记录下这个时代。我们不负责臧否成败，我们选取的也不是“成功者”或“失败者”，而是那些“强烈的人格”。这些人格包括了罗永浩、唐岩、戴威、金星、张颖、傅盛、papi酱、安传东、马薇薇、孟雷、潘飞、许单单、孙海涛。</p>
<p>他们纵身跃出舒适区，打破旧有常规，推动社会前进，并先于所有人迎接未来。这些创业者改造着一个个产业，也改变着中国。他们站在一起，就是当下中国创业史的最好记录。</p>
<p>原文地址： <a href="https://mp.weixin.qq.com/s?__biz=MzI2OTU3MTQxOA==&amp;mid=2247485301&amp;idx=1&amp;sn=ca187014fc63b4973387d3cc92a1db42&amp;chksm=eadf0340dda88a5615f435f72bad72f6054ec640ddbb70af8aa962976ffb9cda0f073524f3a0&amp;mpshare=1&amp;scene=1&amp;srcid=0413BJnFpmvnP3y8KoLoydb0#rd" target="_blank" rel="noopener"> 这里
</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">127</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">90</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src=""></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
