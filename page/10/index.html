<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="DmrfCoder的个人主页">
<meta property="og:url" content="http://www.mashangxue123.com/page/10/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DmrfCoder的个人主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/page/10/">





  <title>DmrfCoder的个人主页</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/12/结构型模式——组合模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/结构型模式——组合模式/" itemprop="url">结构型模式——组合模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T19:04:04+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>组合模式（Composite<br>Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。<br>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。<br>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以向处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><ul>
<li>您想表示对象的部分-整体层次结构（树形结构）。 </li>
<li>您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。 </li>
</ul>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li>算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作符也可以是操作树、操作符和另一个操作数。 </li>
<li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。 </li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>高层模块调用简单。 </li>
<li>节点自由增加。 </li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>定义时为具体类。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们有一个类 Employee，该类被当作组合模型类。CompositePatternDemo，我们的演示类使用 Employee<br>类来添加部门层次结构，并打印所有员工。</p>
<h2 id="创建-Employee-类，该类带有-Employee-对象的列表"><a href="#创建-Employee-类，该类带有-Employee-对象的列表" class="headerlink" title="创建 Employee 类，该类带有 Employee 对象的列表"></a>创建 Employee 类，该类带有 Employee 对象的列表</h2><p><strong>Employee.java</strong></p>
<pre><code> import java.util.ArrayList;
import java.util.List;

public class Employee {
   private String name;
   private String dept;
   private int salary;
   private List&lt;Employee&gt; subordinates;

   //构造函数
   public Employee(String name,String dept, int sal) {
      this.name = name;
      this.dept = dept;
      this.salary = sal;
      subordinates = new ArrayList&lt;Employee&gt;();
   }

   public void add(Employee e) {
      subordinates.add(e);
   }

   public void remove(Employee e) {
      subordinates.remove(e);
   }

   public List&lt;Employee&gt; getSubordinates(){
     return subordinates;
   }

   public String toString(){
      return (&quot;Employee :[ Name : &quot;+ name 
      +&quot;, dept : &quot;+ dept + &quot;, salary :&quot;
      + salary+&quot; ]&quot;);
   }   
}
</code></pre><h2 id="使用-Employee-类来创建和打印员工的层次结构"><a href="#使用-Employee-类来创建和打印员工的层次结构" class="headerlink" title="使用 Employee 类来创建和打印员工的层次结构"></a>使用 Employee 类来创建和打印员工的层次结构</h2><p><strong>CompositePatternDemo.java</strong></p>
<pre><code> public class CompositePatternDemo {
   public static void main(String[] args) {
      Employee CEO = new Employee(&quot;John&quot;,&quot;CEO&quot;, 30000);

      Employee headSales = new Employee(&quot;Robert&quot;,&quot;Head Sales&quot;, 20000);

      Employee headMarketing = new Employee(&quot;Michel&quot;,&quot;Head Marketing&quot;, 20000);

      Employee clerk1 = new Employee(&quot;Laura&quot;,&quot;Marketing&quot;, 10000);
      Employee clerk2 = new Employee(&quot;Bob&quot;,&quot;Marketing&quot;, 10000);

      Employee salesExecutive1 = new Employee(&quot;Richard&quot;,&quot;Sales&quot;, 10000);
      Employee salesExecutive2 = new Employee(&quot;Rob&quot;,&quot;Sales&quot;, 10000);

      CEO.add(headSales);
      CEO.add(headMarketing);

      headSales.add(salesExecutive1);
      headSales.add(salesExecutive2);

      headMarketing.add(clerk1);
      headMarketing.add(clerk2);

      //打印该组织的所有员工
      System.out.println(CEO); 
      for (Employee headEmployee : CEO.getSubordinates()) {
         System.out.println(headEmployee);
         for (Employee employee : headEmployee.getSubordinates()) {
            System.out.println(employee);
         }
      }        
   }
}
</code></pre><h2 id="验证输出"><a href="#验证输出" class="headerlink" title="验证输出"></a>验证输出</h2><pre><code>Employee :[ Name : John, dept : CEO, salary :30000 ]
Employee :[ Name : Robert, dept : Head Sales, salary :20000 ]
Employee :[ Name : Richard, dept : Sales, salary :10000 ]
Employee :[ Name : Rob, dept : Sales, salary :10000 ]
Employee :[ Name : Michel, dept : Head Marketing, salary :20000 ]
Employee :[ Name : Laura, dept : Marketing, salary :10000 ]
Employee :[ Name : Bob, dept : Marketing, salary :10000 ]
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>组合模式的要点在于组合和结构，通俗来讲就是通过不同的组合来形成一个体系结构，实现要点是list的使用，以上述demo为例，CEO的下属包含headSales和headMarketing，即CEO这个对象的下属list里面只要添加headSales和headMarketing即可，所以如果把CEO理解为一个东西的话它是由headSales和headMarketing组合而成的（如果没有这两者真不知道CEO存在的意义是什么，一自己当自己的CEO？），而headSales又有若干个salesExecutive下属，所以headSales对象的下属list里面应该添加若干个salesExecutive对象，以此类推（headMarketing由若干个clerk组成）。至此，通过不断的组合，我们就可以由salesExecutive和clerk一路不断组合直到CEO，这就是“组合”的含义，同时也体现了很强的层级关系。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/12/结构型模式——过滤器模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/结构型模式——过滤器模式/" itemprop="url">结构型模式——过滤器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T18:42:53+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>过滤器模式（Filter Pattern）或标准模式（Criteria<br>Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们将创建一个 Person 对象、Criteria 接口和实现了该接口的实体类，来过滤 Person<br>对象的列表。CriteriaPatternDemo，我们的演示类使用 Criteria 对象，基于各种标准和它们的结合来过滤 Person 对象的列表。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="创建一个类，在该类上应用标准"><a href="#创建一个类，在该类上应用标准" class="headerlink" title="创建一个类，在该类上应用标准"></a>创建一个类，在该类上应用标准</h3><p><strong>Person.java</strong></p>
<pre><code> public class Person {

   private String name;
   private String gender;
   private String maritalStatus;

   public Person(String name,String gender,String maritalStatus){
      this.name = name;
      this.gender = gender;
      this.maritalStatus = maritalStatus;        
   }

   public String getName() {
      return name;
   }
   public String getGender() {
      return gender;
   }
   public String getMaritalStatus() {
      return maritalStatus;
   }    
}
</code></pre><h3 id="为标准（Criteria）创建一个接口"><a href="#为标准（Criteria）创建一个接口" class="headerlink" title="为标准（Criteria）创建一个接口"></a>为标准（Criteria）创建一个接口</h3><p><strong>Criteria.java</strong></p>
<pre><code>import java.util.List;

 public interface Criteria {
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons);
}
</code></pre><h3 id="创建实现了-Criteria-接口的实体类"><a href="#创建实现了-Criteria-接口的实体类" class="headerlink" title="创建实现了 Criteria 接口的实体类"></a>创建实现了 Criteria 接口的实体类</h3><p><strong>CriteriaMale.java</strong></p>
<pre><code> import java.util.ArrayList;
import java.util.List;

public class CriteriaMale implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; malePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase(&quot;MALE&quot;)){
            malePersons.add(person);
         }
      }
      return malePersons;
   }
}
</code></pre><p><strong>CriteriaFemale.java</strong></p>
<pre><code> import java.util.ArrayList;
import java.util.List;

public class CriteriaFemale implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; femalePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getGender().equalsIgnoreCase(&quot;FEMALE&quot;)){
            femalePersons.add(person);
         }
      }
      return femalePersons;
   }
}
</code></pre><p><strong>CriteriaSingle.java</strong></p>
<pre><code> import java.util.ArrayList;
import java.util.List;

public class CriteriaSingle implements Criteria {

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; singlePersons = new ArrayList&lt;Person&gt;(); 
      for (Person person : persons) {
         if(person.getMaritalStatus().equalsIgnoreCase(&quot;SINGLE&quot;)){
            singlePersons.add(person);
         }
      }
      return singlePersons;
   }
}
</code></pre><p><strong>AndCriteria.java</strong></p>
<pre><code> import java.util.List;

public class AndCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public AndCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; firstCriteriaPersons = criteria.meetCriteria(persons);        
      return otherCriteria.meetCriteria(firstCriteriaPersons);
   }
}
</code></pre><p><strong>OrCriteria.java</strong></p>
<pre><code> import java.util.List;

public class OrCriteria implements Criteria {

   private Criteria criteria;
   private Criteria otherCriteria;

   public OrCriteria(Criteria criteria, Criteria otherCriteria) {
      this.criteria = criteria;
      this.otherCriteria = otherCriteria; 
   }

   @Override
   public List&lt;Person&gt; meetCriteria(List&lt;Person&gt; persons) {
      List&lt;Person&gt; firstCriteriaItems = criteria.meetCriteria(persons);
      List&lt;Person&gt; otherCriteriaItems = otherCriteria.meetCriteria(persons);

      for (Person person : otherCriteriaItems) {
         if(!firstCriteriaItems.contains(person)){
            firstCriteriaItems.add(person);
         }
      }    
      return firstCriteriaItems;
   }
}
</code></pre><h3 id="使用不同的标准（Criteria）和它们的结合来过滤-Person-对象的列表"><a href="#使用不同的标准（Criteria）和它们的结合来过滤-Person-对象的列表" class="headerlink" title="使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表"></a>使用不同的标准（Criteria）和它们的结合来过滤 Person 对象的列表</h3><p><strong>CriteriaPatternDemo.java</strong></p>
<pre><code>import java.util.ArrayList; 
import java.util.List;

 public class CriteriaPatternDemo {
   public static void main(String[] args) {
      List&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

      persons.add(new Person(&quot;Robert&quot;,&quot;Male&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;John&quot;,&quot;Male&quot;, &quot;Married&quot;));
      persons.add(new Person(&quot;Laura&quot;,&quot;Female&quot;, &quot;Married&quot;));
      persons.add(new Person(&quot;Diana&quot;,&quot;Female&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;Mike&quot;,&quot;Male&quot;, &quot;Single&quot;));
      persons.add(new Person(&quot;Bobby&quot;,&quot;Male&quot;, &quot;Single&quot;));

      Criteria male = new CriteriaMale();
      Criteria female = new CriteriaFemale();
      Criteria single = new CriteriaSingle();
      Criteria singleMale = new AndCriteria(single, male);
      Criteria singleOrFemale = new OrCriteria(single, female);

      System.out.println(&quot;Males: &quot;);
      printPersons(male.meetCriteria(persons));

      System.out.println(&quot;\nFemales: &quot;);
      printPersons(female.meetCriteria(persons));

      System.out.println(&quot;\nSingle Males: &quot;);
      printPersons(singleMale.meetCriteria(persons));

      System.out.println(&quot;\nSingle Or Females: &quot;);
      printPersons(singleOrFemale.meetCriteria(persons));
   }

   public static void printPersons(List&lt;Person&gt; persons){
      for (Person person : persons) {
         System.out.println(&quot;Person : [ Name : &quot; + person.getName() 
            +&quot;, Gender : &quot; + person.getGender() 
            +&quot;, Marital Status : &quot; + person.getMaritalStatus()
            +&quot; ]&quot;);
      }
   }      
}
</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>Males: 
Person : [ Name : Robert, Gender : Male, Marital Status : Single ]
Person : [ Name : John, Gender : Male, Marital Status : Married ]
Person : [ Name : Mike, Gender : Male, Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]

Females: 
Person : [ Name : Laura, Gender : Female, Marital Status : Married ]
Person : [ Name : Diana, Gender : Female, Marital Status : Single ]

Single Males: 
Person : [ Name : Robert, Gender : Male, Marital Status : Single ]
Person : [ Name : Mike, Gender : Male, Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]

Single Or Females: 
Person : [ Name : Robert, Gender : Male, Marital Status : Single ]
Person : [ Name : Diana, Gender : Female, Marital Status : Single ]
Person : [ Name : Mike, Gender : Male, Marital Status : Single ]
Person : [ Name : Bobby, Gender : Male, Marital Status : Single ]
Person : [ Name : Laura, Gender : Female, Marital Status : Married ]
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>过滤器模式就是起一个筛选作用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/12/结构型模式——桥接模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/结构型模式——桥接模式/" itemprop="url">结构型模式——桥接模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T17:37:47+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。<br>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>抽象类依赖实现类</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 </li>
<li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。 </li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>抽象和实现的分离 </li>
<li>优秀的扩展能力 </li>
<li>实现细节对客户透明 </li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系 </li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用 </li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展 </li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>对于两个独立变化的维度，使用桥接模式再适合不过了</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们有一个作为桥接实现的 DrawAPI 接口和实现了 DrawAPI 接口的实体类 RedCircle、GreenCircle。Shape<br>是一个抽象类，将使用 DrawAPI 的对象，我们的演示类使用 Shape 类来画出不同颜色的圆:<br><img src="//img-
blog.csdn.net/20180318164223663?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="创建桥接实现接口"><a href="#创建桥接实现接口" class="headerlink" title="创建桥接实现接口"></a>创建桥接实现接口</h2><p><strong>DrawAPI.java</strong></p>
<pre><code> public interface DrawAPI {
   public void drawCircle(int radius, int x, int y);
}
</code></pre><h2 id="创建实现了-DrawAPI-接口的实体桥接实现类"><a href="#创建实现了-DrawAPI-接口的实体桥接实现类" class="headerlink" title="创建实现了 DrawAPI 接口的实体桥接实现类"></a>创建实现了 DrawAPI 接口的实体桥接实现类</h2><p><strong>RedCircle.java</strong></p>
<pre><code> public class RedCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&quot;Drawing Circle[ color: red, radius: &quot;
         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
   }
}
</code></pre><p><strong>GreenCircle.java</strong></p>
<pre><code> public class GreenCircle implements DrawAPI {
   @Override
   public void drawCircle(int radius, int x, int y) {
      System.out.println(&quot;Drawing Circle[ color: green, radius: &quot;
         + radius +&quot;, x: &quot; +x+&quot;, &quot;+ y +&quot;]&quot;);
   }
}
</code></pre><h2 id="使用-DrawAPI-接口创建抽象类-Shape"><a href="#使用-DrawAPI-接口创建抽象类-Shape" class="headerlink" title="使用 DrawAPI 接口创建抽象类 Shape"></a>使用 DrawAPI 接口创建抽象类 Shape</h2><p><strong>Shape.java</strong></p>
<pre><code> public abstract class Shape {
   protected DrawAPI drawAPI;
   protected Shape(DrawAPI drawAPI){
      this.drawAPI = drawAPI;
   }
   public abstract void draw();    
}
</code></pre><h2 id="创建实现了-Shape-接口的实体类"><a href="#创建实现了-Shape-接口的实体类" class="headerlink" title="创建实现了 Shape 接口的实体类"></a>创建实现了 Shape 接口的实体类</h2><p><strong>Circle.java</strong></p>
<pre><code> public class Circle extends Shape {
   private int x, y, radius;

   public Circle(int x, int y, int radius, DrawAPI drawAPI) {
      super(drawAPI);
      this.x = x;  
      this.y = y;  
      this.radius = radius;
   }

   public void draw() {
      drawAPI.drawCircle(radius,x,y);
   }
}
</code></pre><h2 id="使用-Shape-和-DrawAPI-类画出不同颜色的圆"><a href="#使用-Shape-和-DrawAPI-类画出不同颜色的圆" class="headerlink" title="使用 Shape 和 DrawAPI 类画出不同颜色的圆"></a>使用 Shape 和 DrawAPI 类画出不同颜色的圆</h2><p><strong>BridgePatternDemo.java</strong></p>
<pre><code> public class BridgePatternDemo {
   public static void main(String[] args) {
      Shape redCircle = new Circle(100,100, 10, new RedCircle());
      Shape greenCircle = new Circle(100,100, 10, new GreenCircle());

      redCircle.draw();
      greenCircle.draw();
   }
}
</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>Drawing Circle[ color: red, radius: 10, x: 100, 100]
Drawing Circle[  color: green, radius: 10, x: 100, 100]
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当一个抽象类有多个实现时，通常用集成来协调他们。抽象类定义对该抽象的接口，而具体子类则用不同方式加以实现。但是此方法的缺点是将子类的抽象部分和实现部分固定在了一起，使得难以对抽象部分和实现部分进行修改、扩充和重用。<br>实现抽象化和实现化之间的解耦，具体到上述demo，抽象化指的是 draw redCircle和draw<br>greenCircle，如果不使用桥接模式，一般的实现方法是根据用户指令的不同（以参数的形式体现），实现不同的draw方法，而使用桥接模式，Circle类不用关心具体如何根据用户传入参数的不同实现不同的draw方法（即实现化部分），Circle类只需要根据用户传入接口的不同调用draw方法即可，具体的实现全都交给了DrawAPI（GreenCircle、ReadCircle）来做，即将draw这个功能的抽象化放在Circle类，实现化放在DrawAPI（GreenCircle、ReadCircle），从而实现了抽象化和实例化的分离。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/12/结构型模式——适配器模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/12/结构型模式——适配器模式/" itemprop="url">结构型模式——适配器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-12T16:32:48+08:00">
                2018-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。你将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><ul>
<li>系统需要使用现有的类，而此类的接口不符合系统的需要 </li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口 </li>
<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。） </li>
</ul>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>继承或依赖（推荐）</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V </li>
<li>在 LINUX 上运行 WINDOWS 程序 </li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>可以让任何两个没有关联的类一起运行 </li>
<li>提高了类的复用 </li>
<li>增加了类的透明度 </li>
<li>灵活性好。 </li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构 </li>
<li>.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。 </li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题(即在改装现存代码时可能会用到)。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>我们有一个 MediaPlayer 接口和一个实现了 MediaPlayer 接口的实体类 AudioPlayer。默认情况下，AudioPlayer<br>可以播放 mp3 格式的音频文件。<br>我们还有另一个接口 AdvancedMediaPlayer 和实现了 AdvancedMediaPlayer 接口的实体类。该类可以播放 vlc 和 mp4<br>格式的文件。<br>我们想要让 AudioPlayer 播放其他格式的音频文件。为了实现这个功能，我们需要创建一个实现了 MediaPlayer 接口的适配器类<br>MediaAdapter，并使用 AdvancedMediaPlayer 对象来播放所需的格式。<br>AudioPlayer 使用适配器类 MediaAdapter 传递所需的音频类型，不需要知道能播放所需格式音频的实际类:<br><img src="//img-
blog.csdn.net/20180318162533969?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写代码片"></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="为媒体播放器和更高级的媒体播放器创建接口"><a href="#为媒体播放器和更高级的媒体播放器创建接口" class="headerlink" title="为媒体播放器和更高级的媒体播放器创建接口"></a>为媒体播放器和更高级的媒体播放器创建接口</h3><p><strong>MediaPlayer.java</strong></p>
<pre><code> public interface MediaPlayer {
   public void play(String audioType, String fileName);
}
</code></pre><p><strong>AdvancedMediaPlayer.java</strong></p>
<pre><code> public interface AdvancedMediaPlayer {    
   public void playVlc(String fileName);
   public void playMp4(String fileName);
}
</code></pre><h3 id="创建实现了-AdvancedMediaPlayer-接口的实体类"><a href="#创建实现了-AdvancedMediaPlayer-接口的实体类" class="headerlink" title="创建实现了 AdvancedMediaPlayer 接口的实体类"></a>创建实现了 AdvancedMediaPlayer 接口的实体类</h3><p><strong>VlcPlayer.java</strong></p>
<pre><code> public class VlcPlayer implements AdvancedMediaPlayer{
   @Override
   public void playVlc(String fileName) {
      System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName);        
   }

   @Override
   public void playMp4(String fileName) {
      //什么也不做
   }
}
</code></pre><p><strong>Mp4Player.java</strong></p>
<pre><code> public class Mp4Player implements AdvancedMediaPlayer{

   @Override
   public void playVlc(String fileName) {
      //什么也不做
   }

   @Override
   public void playMp4(String fileName) {
      System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName);        
   }
}
</code></pre><h3 id="创建实现了-MediaPlayer-接口的适配器类"><a href="#创建实现了-MediaPlayer-接口的适配器类" class="headerlink" title="创建实现了 MediaPlayer 接口的适配器类"></a>创建实现了 MediaPlayer 接口的适配器类</h3><p><strong>MediaAdapter.java</strong></p>
<pre><code> public class MediaAdapter implements MediaPlayer {

   AdvancedMediaPlayer advancedMusicPlayer;

   public MediaAdapter(String audioType){
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;) ){
         advancedMusicPlayer = new VlcPlayer();            
      } else if (audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         advancedMusicPlayer = new Mp4Player();
      }    
   }

   @Override
   public void play(String audioType, String fileName) {
      if(audioType.equalsIgnoreCase(&quot;vlc&quot;)){
         advancedMusicPlayer.playVlc(fileName);
      }else if(audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         advancedMusicPlayer.playMp4(fileName);
      }
   }
}
</code></pre><h3 id="创建实现了-MediaPlayer-接口的实体类"><a href="#创建实现了-MediaPlayer-接口的实体类" class="headerlink" title="创建实现了 MediaPlayer 接口的实体类"></a>创建实现了 MediaPlayer 接口的实体类</h3><p><strong>AudioPlayer.java</strong></p>
<pre><code> public class AudioPlayer implements MediaPlayer {
   MediaAdapter mediaAdapter; 

   @Override
   public void play(String audioType, String fileName) {        

      //播放 mp3 音乐文件的内置支持
      if(audioType.equalsIgnoreCase(&quot;mp3&quot;)){
         System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName);            
      } 
      //mediaAdapter 提供了播放其他文件格式的支持
      else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) 
         || audioType.equalsIgnoreCase(&quot;mp4&quot;)){
         mediaAdapter = new MediaAdapter(audioType);
         mediaAdapter.play(audioType, fileName);
      }
      else{
         System.out.println(&quot;Invalid media. &quot;+
            audioType + &quot; format not supported&quot;);
      }
   }   
}
</code></pre><h3 id="使用-AudioPlayer-来播放不同类型的音频格式"><a href="#使用-AudioPlayer-来播放不同类型的音频格式" class="headerlink" title="使用 AudioPlayer 来播放不同类型的音频格式"></a>使用 AudioPlayer 来播放不同类型的音频格式</h3><p><strong>AdapterPatternDemo.java</strong></p>
<pre><code> public class AdapterPatternDemo {
   public static void main(String[] args) {
      AudioPlayer audioPlayer = new AudioPlayer();

      audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;);
      audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;);
      audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;);
      audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;);
   }
}
</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>Playing mp3 file. Name: beyond the horizon.mp3
Playing mp4 file. Name: alone.mp4
Playing vlc file. Name: far far away.vlc
Invalid media. avi format not supported
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能。<br>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。<br>注意，要点是要在原来类的基础上使原本不兼容的功能变得兼容。<br>Adapter类一般是用来实现与原有类不兼容的功能，比如demo中的MediaAdapter实现了MediaPlayer没有的特殊功能，用户只要调用AudioPlayer中的play方法，AudioPlayer会自动根据音频的类型选择不同的play方式，当音频类型不符合传统player的能力时AudioPlayer会使用adapter去调用之前不兼容的方法（功能），这样就实现了所谓的适配。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/11/AudioRecord参数解释/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/11/AudioRecord参数解释/" itemprop="url">AudioRecord参数解释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-11T11:31:21+08:00">
                2018-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>public AudioRecord (int audioSource, int sampleRateInHz, int channelConfig,<br>int audioFormat, int bufferSizeInBytes)</p>
<h1 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h1><h2 id="audioSource-音频源"><a href="#audioSource-音频源" class="headerlink" title="audioSource 音频源"></a>audioSource 音频源</h2><p>指的是从哪里采集音频。这里我们当然是从麦克风采集音频，所以此参数的值为MIC</p>
<h2 id="sampleRateInHz-采样率"><a href="#sampleRateInHz-采样率" class="headerlink" title="sampleRateInHz 采样率"></a>sampleRateInHz 采样率</h2><p>音频的采样频率，每秒钟能够采样的次数，采样率越高，音质越高。给出的实例是<br>44100、22050、11025但不限于这几个参数。例如要采集低质量的音频就可以使用4000、<br>8000等低采样率。</p>
<h2 id="channelConfig-声道设置"><a href="#channelConfig-声道设置" class="headerlink" title="channelConfig 声道设置"></a>channelConfig 声道设置</h2><p>android支持双声道立体声和单声道。MONO单声道，STEREO立体声</p>
<h2 id="audioFormat-编码制式和采样大小"><a href="#audioFormat-编码制式和采样大小" class="headerlink" title="audioFormat 编码制式和采样大小"></a>audioFormat 编码制式和采样大小</h2><p>采集来的数据当然使用PCM编码(脉冲代码调制编码，即PCM编码。<br>PCM通过抽样、量化、编码三个步骤将连续变化的模拟信号转换为数字编码。)<br>android支持的采样大小16bit 或者8bit。当然采样大小越大，那么信息量越多，音质也越高，<br>现在主流的采样大小都是16bit，在低质量的语音传输的时候8bit足够了。</p>
<h2 id="bufferSizeInBytes"><a href="#bufferSizeInBytes" class="headerlink" title="bufferSizeInBytes"></a>bufferSizeInBytes</h2><p>采集数据需要的缓冲区的大小，如果不知道最小需要的大小可以在getMinBufferSize()查看。</p>
<p>采集到的数据保存在一个byteBuffer中，可以使用流将其读出。亦可保存成为文件的形式</p>
<h1 id="public-int-read-short-audioData-int-offsetInShorts-int-sizeInShorts"><a href="#public-int-read-short-audioData-int-offsetInShorts-int-sizeInShorts" class="headerlink" title="public int read (short[] audioData, int offsetInShorts, int sizeInShorts)"></a>public int read (short[] audioData, int offsetInShorts, int sizeInShorts)</h1><p>从音频硬件录制缓冲区读取数据</p>
<h2 id="audioData"><a href="#audioData" class="headerlink" title="audioData"></a>audioData</h2><p>写入的音频录制数据。</p>
<h2 id="offsetInShorts"><a href="#offsetInShorts" class="headerlink" title="offsetInShorts"></a>offsetInShorts</h2><p>目标数组 audioData 的起始偏移量。</p>
<h2 id="sizeInShorts"><a href="#sizeInShorts" class="headerlink" title="sizeInShorts"></a>sizeInShorts</h2><p>请求读取的数据大小。</p>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>返回short型数据，表示读取到的数据，如果对象属性没有初始化，则返回ERROR_INVALID_OPERATION，<br>如果参数不能解析成有效的数据或索引，则返回ERROR_BAD_VALUE。 返回数值不会超过sizeInShorts。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/创建型模式——原型模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/创建型模式——原型模式/" itemprop="url">创建型模式——原型模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T11:44:49+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>原型模式（Prototype Pattern）是用于 <strong>创建重复的对象</strong><br>，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式是实现了一个原型接口， <strong>该接口用于创建当前对象的克隆</strong><br>。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>在运行期建立和删除原型。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><ul>
<li>当一个系统应该独立于它的产品创建，构成和表示时 </li>
<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载 </li>
<li>为了避免创建一个与产品类层次平行的工厂类层次时 </li>
<li>当一个类的实例只能有几个不同状态组合中的一种时 </li>
<li>建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些 </li>
</ul>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><ul>
<li>实现克隆操作，在 JAVA 继承 Cloneable，重写 clone()。 </li>
<li>原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。 </li>
</ul>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li>细胞分裂 </li>
<li>JAVA 中的 Object clone() 方法。 </li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>性能提高 </li>
<li>逃避构造函数的约束。 </li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候 </li>
<li>必须实现 Cloneable 接口。 </li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>资源优化场景 </li>
<li>类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等 </li>
<li>性能和安全要求的场景 </li>
<li>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式 </li>
<li>一个对象多个修改者的场景 </li>
<li>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用 </li>
<li>在实际项目中，原型模式很少单独出现， <strong>一般是和工厂方法模式一起出现</strong> ，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。 </li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现<br>Serializable 读取二进制流。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们将创建一个抽象类 Shape 和扩展了 Shape 类的实体类。下一步是定义类 ShapeCache，该类把 shape 对象存储在一个<br>Hashtable 中，并在请求的时候返回它们的克隆。</p>
<h2 id="创建一个实现了-Clonable-接口的抽象类。"><a href="#创建一个实现了-Clonable-接口的抽象类。" class="headerlink" title="创建一个实现了 Clonable 接口的抽象类。"></a>创建一个实现了 Clonable 接口的抽象类。</h2><p>Shape.java</p>
<pre><code> public abstract class Shape implements Cloneable {

   private String id;
   protected String type;

   abstract void draw();

   public String getType(){
      return type;
   }

   public String getId() {
      return id;
   }

   public void setId(String id) {
      this.id = id;
   }

   public Object clone() {
      Object clone = null;
      try {
         clone = super.clone();
      } catch (CloneNotSupportedException e) {
         e.printStackTrace();
      }
      return clone;
   }
}
</code></pre><h2 id="创建扩展了上面抽象类的实体类。"><a href="#创建扩展了上面抽象类的实体类。" class="headerlink" title="创建扩展了上面抽象类的实体类。"></a>创建扩展了上面抽象类的实体类。</h2><p>Rectangle.java</p>
<pre><code>public class Rectangle extends Shape {

   public Rectangle(){
     type = &quot;Rectangle&quot;;
   }

   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Square.java</p>
<pre><code>public class Square extends Shape {

   public Square(){
     type = &quot;Square&quot;;
   }

   @Override
   public void draw() {
      System.out.println(&quot;Inside Square-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Circle.java</p>
<pre><code>public class Circle extends Shape {

   public Circle(){
     type = &quot;Circle&quot;;
   }

   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle-&gt;draw() method.&quot;);
   }
}
</code></pre><h2 id="创建一个类，从数据库获取实体类，并把它们存储在一个-Hashtable-中"><a href="#创建一个类，从数据库获取实体类，并把它们存储在一个-Hashtable-中" class="headerlink" title="创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中"></a>创建一个类，从数据库获取实体类，并把它们存储在一个 Hashtable 中</h2><p>ShapeCache.java</p>
<pre><code>import java.util.Hashtable;

public class ShapeCache {

   private static Hashtable&lt;String, Shape&gt; shapeMap 
      = new Hashtable&lt;String, Shape&gt;();

   public static Shape getShape(String shapeId) {
      Shape cachedShape = shapeMap.get(shapeId);
      return (Shape) cachedShape.clone();
   }

   // 对每种形状都运行数据库查询，并创建该形状
   // shapeMap.put(shapeKey, shape);
   // 例如，我们要添加三种形状
   public static void loadCache() {
      Circle circle = new Circle();
      circle.setId(&quot;1&quot;);
      shapeMap.put(circle.getId(),circle);

      Square square = new Square();
      square.setId(&quot;2&quot;);
      shapeMap.put(square.getId(),square);

      Rectangle rectangle = new Rectangle();
      rectangle.setId(&quot;3&quot;);
      shapeMap.put(rectangle.getId(),rectangle);
   }
}
</code></pre><h2 id="PrototypePatternDemo-使用-ShapeCache-类来获取存储在-Hashtable-中的形状的克隆"><a href="#PrototypePatternDemo-使用-ShapeCache-类来获取存储在-Hashtable-中的形状的克隆" class="headerlink" title="PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆"></a>PrototypePatternDemo 使用 ShapeCache 类来获取存储在 Hashtable 中的形状的克隆</h2><p>PrototypePatternDemo.java</p>
<pre><code>public class PrototypePatternDemo {
   public static void main(String[] args) {
      ShapeCache.loadCache();

      Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;);
      System.out.println(&quot;Shape : &quot; + clonedShape.getType());        

      Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;);
      System.out.println(&quot;Shape : &quot; + clonedShape2.getType());        

      Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;);
      System.out.println(&quot;Shape : &quot; + clonedShape3.getType());        
   }
}
</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>Shape : Circle
Shape : Square
Shape : Rectangle
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原型模式实现的功能就是对象的拷贝，只不过这种拷贝的功能是在类中定义好的，即在定义类的时候就定义好了一个clone的接口，当这个类对应的对象在某一时刻需要拷贝出另一个对象时，只需调用这个对象的clone方法即可返回一个本对象的克隆体，那么为什么不直接实例化一个新的对象而要采用这种克隆的机制呢？想象一下如果一个类的某些属性的值需要从数据库中查询，这样每实例化一个新类就需要做查询的耗时操作，这时候如果直接用一个已有的对象去clone出一个新的对象就可以避免诸如数据库查询之类的耗时操作，提高了软件的执行效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/创建型模式——建造者模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/创建型模式——建造者模式/" itemprop="url">创建型模式——建造者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T11:30:47+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>建造者模式（Builder<br>Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>一些基本部件不会变，而其组合经常变化的时候。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>将变与不变分离开。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>建造者：创建和提供实例<br>导演：管理建造出来的实例的依赖关系。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li><p>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。   </p>
<ul>
<li>JAVA 中的 StringBuilder。 </li>
</ul>
</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>建造者独立，易扩展 </li>
<li>便于控制细节风险。 </li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>产品必须有共同点，范围有限制 </li>
<li>如内部变化复杂，会有很多的建造类。 </li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>需要生成的对象具有复杂的内部结构 </li>
<li>需要生成的对象内部属性本身相互依赖。 </li>
</ul>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们假设在一个快餐店的商业案例中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg<br>Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold<br>drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。<br>我们将创建一个表示食物条目（比如汉堡和冷饮）的 Item 接口和实现 Item 接口的实体类，以及一个表示食物包装的 Packing 接口和实现<br>Packing 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。<br>然后我们创建一个 Meal 类，带有 Item 的 ArrayList 和一个通过结合 Item 来创建不同类型的 Meal 对象的<br>MealBuilder。BuilderPatternDemo，我们的演示类使用 MealBuilder 来创建一个 Meal:<br><img src="//img-
blog.csdn.net/20180318160630347?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="创建一个表示食物条目和食物包装的接口"><a href="#创建一个表示食物条目和食物包装的接口" class="headerlink" title="创建一个表示食物条目和食物包装的接口"></a>创建一个表示食物条目和食物包装的接口</h2><p>Item.java</p>
<pre><code>public interface Item { //食物条目（比如汉堡和冷饮）
   public String name();
   public Packing packing();
   public float price();    
}
</code></pre><p>Packing.java</p>
<pre><code>public interface Packing {
   public String pack();
}
</code></pre><h2 id="创建实现-Packing-接口的实体类。"><a href="#创建实现-Packing-接口的实体类。" class="headerlink" title="创建实现 Packing 接口的实体类。"></a>创建实现 Packing 接口的实体类。</h2><p>Wrapper.java</p>
<pre><code>public class Wrapper implements Packing {

   @Override
   public String pack() {
      return &quot;Wrapper&quot;;
   }
}
</code></pre><p>Bottle.java</p>
<pre><code>public class Bottle implements Packing {

   @Override
   public String pack() {
      return &quot;Bottle&quot;;
   }
}
</code></pre><h2 id="创建实现-Item-接口的抽象类，该类提供了默认的功能"><a href="#创建实现-Item-接口的抽象类，该类提供了默认的功能" class="headerlink" title="创建实现 Item 接口的抽象类，该类提供了默认的功能"></a>创建实现 Item 接口的抽象类，该类提供了默认的功能</h2><p>Burger.java</p>
<pre><code>public abstract class Burger implements Item {

   @Override
   public Packing packing() {
      return new Wrapper();
   }

   @Override
   public abstract float price();
}
</code></pre><p>ColdDrink.java</p>
<pre><code>public abstract class ColdDrink implements Item {

    @Override
    public Packing packing() {
       return new Bottle();
    }

    @Override
    public abstract float price();
}
</code></pre><h2 id="创建扩展了-Burger-和-ColdDrink-的实体类。"><a href="#创建扩展了-Burger-和-ColdDrink-的实体类。" class="headerlink" title="创建扩展了 Burger 和 ColdDrink 的实体类。"></a>创建扩展了 Burger 和 ColdDrink 的实体类。</h2><p>VegBurger.java</p>
<pre><code>public class VegBurger extends Burger {

   @Override
   public float price() {
      return 25.0f;
   }

   @Override
   public String name() {
      return &quot;Veg Burger&quot;;
   }
}
</code></pre><p>ChickenBurger.java</p>
<pre><code>public class ChickenBurger extends Burger {

   @Override
   public float price() {
      return 50.5f;
   }

   @Override
   public String name() {
      return &quot;Chicken Burger&quot;;
   }
}
</code></pre><p>Coke.java</p>
<pre><code>public class Coke extends ColdDrink {

   @Override
   public float price() {
      return 30.0f;
   }

   @Override
   public String name() {
      return &quot;Coke&quot;;
   }
}
</code></pre><p>Pepsi.java</p>
<pre><code>public class Pepsi extends ColdDrink {

   @Override
   public float price() {
      return 35.0f;
   }

   @Override
   public String name() {
      return &quot;Pepsi&quot;;
   }
}
</code></pre><h2 id="创建一个-Meal-类，带有上面定义的-Item-对象"><a href="#创建一个-Meal-类，带有上面定义的-Item-对象" class="headerlink" title="创建一个 Meal 类，带有上面定义的 Item 对象"></a>创建一个 Meal 类，带有上面定义的 Item 对象</h2><p>Meal.java</p>
<pre><code>import java.util.ArrayList;
import java.util.List;

public class Meal {
   private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;();    

   public void addItem(Item item){
      items.add(item);
   }

   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }

   public void showItems(){
      for (Item item : items) {
         System.out.print(&quot;Item : &quot;+item.name());
         System.out.print(&quot;, Packing : &quot;+item.packing().pack());
         System.out.println(&quot;, Price : &quot;+item.price());
      }        
   }    
}
</code></pre><h2 id="创建一个-MealBuilder-类，实际的-builder-类负责创建-Meal-对象"><a href="#创建一个-MealBuilder-类，实际的-builder-类负责创建-Meal-对象" class="headerlink" title="创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象"></a>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象</h2><p>MealBuilder.java</p>
<pre><code>public class MealBuilder {

   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   

   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
</code></pre><h2 id="BuiderPatternDemo-使用-MealBuider-来演示建造者模式（Builder-Pattern）"><a href="#BuiderPatternDemo-使用-MealBuider-来演示建造者模式（Builder-Pattern）" class="headerlink" title="BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）"></a>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）</h2><p>BuilderPatternDemo.java</p>
<pre><code>public class BuilderPatternDemo {
   public static void main(String[] args) {
      MealBuilder mealBuilder = new MealBuilder();

      Meal vegMeal = mealBuilder.prepareVegMeal();
      System.out.println(&quot;Veg Meal&quot;);
      vegMeal.showItems();
      System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost());

      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
      System.out.println(&quot;\n\nNon-Veg Meal&quot;);
      nonVegMeal.showItems();
      System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost());
   }
}
</code></pre><h2 id="输出。"><a href="#输出。" class="headerlink" title="输出。"></a>输出。</h2><pre><code>Veg Meal
Item : Veg Burger, Packing : Wrapper, Price : 25.0
Item : Coke, Packing : Bottle, Price : 30.0
Total Cost: 55.0


Non-Veg Meal
Item : Chicken Burger, Packing : Wrapper, Price : 50.5
Item : Pepsi, Packing : Bottle, Price : 35.0
Total Cost: 85.5
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>建造者模式与工厂方法模式有类似的地方，但是建造者模式更加关注零件装配的顺序而且生成的对象内部属性本身具有相互依赖性，比如Demo中的食物和对应的容器具有很强的相互依赖性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/创建型模式——单例模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/创建型模式——单例模式/" itemprop="url">创建型模式——单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T11:15:19+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>单例类只能有一个实例。 </li>
<li>单例类必须自己创建自己的唯一实例。 </li>
<li>单例类必须给所有其他对象提供这一实例。 </li>
</ul>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>一个全局使用的类频繁地创建与销毁。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>当您想控制实例数目，节省系统资源的时候。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>构造函数是私有的。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li>一个党只能有一个主席 </li>
<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行 </li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存） </li>
<li>避免对资源的多重占用（比如写文件操作） </li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>要求生产唯一序列号 </li>
<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来 </li>
<li>创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 </li>
</ul>
<h1 id="注意事项-这个注意事项放在这么显眼的位置就是为了说明它的重要性"><a href="#注意事项-这个注意事项放在这么显眼的位置就是为了说明它的重要性" class="headerlink" title="注意事项(这个注意事项放在这么显眼的位置就是为了说明它的重要性)"></a>注意事项(这个注意事项放在这么显眼的位置就是为了说明它的重要性)</h1><p><strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance<br>被多次实例化。</strong></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。<br>SingleObject 类提供了一个静态方法，供外界获取它的静态实例。</p>
<h2 id="创建一个-Singleton-类"><a href="#创建一个-Singleton-类" class="headerlink" title="创建一个 Singleton 类"></a>创建一个 Singleton 类</h2><p>SingleObject.java</p>
<pre><code> public class SingleObject {

   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();

   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}

   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }

   public void showMessage(){
      System.out.println(&quot;Hello World!&quot;);
   }
}
</code></pre><h2 id="从-singleton-类获取唯一的对象"><a href="#从-singleton-类获取唯一的对象" class="headerlink" title="从 singleton 类获取唯一的对象"></a>从 singleton 类获取唯一的对象</h2><p>SingletonPatternDemo.java</p>
<pre><code>public class SingletonPatternDemo {
   public static void main(String[] args) {

      //不合法的构造函数
      //编译时错误：构造函数 SingleObject() 是不可见的
      //SingleObject object = new SingleObject();

      //获取唯一可用的对象
      SingleObject object = SingleObject.getInstance();

      //显示消息
      object.showMessage();
   }
}
</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>Hello World!
</code></pre><h1 id="单例模式的几种实现方式"><a href="#单例模式的几种实现方式" class="headerlink" title="单例模式的几种实现方式"></a>单例模式的几种实现方式</h1><p>单例模式的实现有多种方式，如下所示：</p>
<h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p>是否 Lazy 初始化：是<br>是否多线程安全：否<br>实现难度：易<br>描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。<br>这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。<br>代码实例：</p>
<pre><code>public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  

    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}  
</code></pre><p>接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。</p>
<h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：易<br>描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但 <strong>加锁会影响效率</strong> 。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。<br>代码实例：</p>
<pre><code> public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}
</code></pre><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易<br>描述：这种方式比较常用，但容易产生垃圾对象。<br>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。<br>它基于 classloder 机制避免了多线程的同步问题，不过，instance<br>在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法，<br>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。<br>代码实例：</p>
<pre><code>public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}
</code></pre><h2 id="双检锁-双重校验锁（DCL，即-double-checked-locking）"><a href="#双检锁-双重校验锁（DCL，即-double-checked-locking）" class="headerlink" title="双检锁/双重校验锁（DCL，即 double-checked locking）"></a>双检锁/双重校验锁（DCL，即 double-checked locking）</h2><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：较复杂<br>描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。<br>getInstance() 的性能对应用程序很关键。<br>代码实例：</p>
<pre><code>public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}  
</code></pre><h3 id="volatile和synchronized关键字的区别"><a href="#volatile和synchronized关键字的区别" class="headerlink" title="volatile和synchronized关键字的区别"></a>volatile和synchronized关键字的区别</h3><p><a href="http://blog.csdn.net/qq_36982160/article/details/79506026" target="_blank" rel="noopener"> Java中volatile和synchronized关键字的区别
</a></p>
<h2 id="登记式-静态内部类"><a href="#登记式-静态内部类" class="headerlink" title="登记式/静态内部类"></a>登记式/静态内部类</h2><p>是否 Lazy 初始化：是<br>是否多线程安全：是<br>实现难度：一般<br>描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要<br>Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton<br>类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance<br>方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance<br>很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton<br>类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。<br>代码实例：</p>
<pre><code>public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}   
</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>JDK 版本：JDK1.5 起<br>是否 Lazy 初始化：否<br>是否多线程安全：是<br>实现难度：易<br>描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch<br>提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入<br>enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。<br>代码实例：</p>
<pre><code>public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}  
</code></pre><p>关于java中的enum，详见 <a href="https://www.jianshu.com/p/46dbd930f6a2" target="_blank" rel="noopener"> 这里 </a></p>
<h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><p>一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5<br>种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实单例模式通俗来讲就是让一个类在整个程序中只有一个对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/java中volatile和synchronized的区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/java中volatile和synchronized的区别/" itemprop="url">java中volatile和synchronized的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T11:05:17+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java中volatile和synchronized关键字都是伴随着多线程经常使用的关键字，很多然搞不清楚二者的区别，这篇文章记录下来笔者的一点认识，若有不正确的地方欢迎大家在评论区指出。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 </li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别 </li>
<li><strong>volatile仅能实现变量的修改可见性，不能保证原子性</strong> ；而synchronized则可以保证变量的修改可见性和原子性 </li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 </li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化 </li>
</ul>
<p>加粗字体部分的原因如下：<br>线程A修改了变量还没结束时,另外的线程B可以看到已修改的值,而且可以修改这个变量,而不用等待A释放锁,因为Volatile 变量没上锁。</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>用在多线程，同步变量。<br>线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。volatile就是用来避免这种情况的。volatile告诉jvm，<br>它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A)</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>synchronized关键字很好理解，就是保证所修饰的变量、方法、和类同时只能被一个xx调用（这里没想好修饰词），而volatile是为了保证变量可以同时被多个线程调用，而且没有上锁，即上面提到的线程A修改了变量还没结束时,另外的线程B可以看到已修改的值，这种机制有利有弊，希望大家使用的时候一定要慎重。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/03/10/创建型模式——抽象工厂模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/10/创建型模式——抽象工厂模式/" itemprop="url">创建型模式——抽象工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-10T10:40:27+08:00">
                2018-03-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>抽象工厂模式（Abstract Factory<br>Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<h2 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h2><p>主要解决接口选择的问题。</p>
<h2 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h2><p>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>在一个产品族里面，定义多个产品。</p>
<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><p>在一个工厂里聚合多个同类产品。</p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用<br>OO<br>的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>QQ 换皮肤，一整套一起换 </li>
<li>生成不同操作系统的程序。 </li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>产品族难扩展，产品等级易扩展。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们将创建 Shape 和 Color 接口和实现这些接口的实体类。下一步是创建抽象工厂类 AbstractFactory。接着定义工厂类<br>ShapeFactory 和 ColorFactory，这两个工厂类都是扩展了 AbstractFactory。然后创建一个工厂创造器/生成器类 :<br><img src="//img-
blog.csdn.net/20180318154032560?watermark/2/text/Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们的演示类使用 FactoryProducer 来获取 AbstractFactory 对象。它将向 AbstractFactory 传递形状信息<br>Shape（CIRCLE / RECTANGLE / SQUARE），以便获取它所需对象的类型。同时它还向 AbstractFactory 传递颜色信息<br>Color（RED / GREEN / BLUE），以便获取它所需对象的类型。</p>
<h3 id="为形状创建一个接口"><a href="#为形状创建一个接口" class="headerlink" title="为形状创建一个接口"></a>为形状创建一个接口</h3><p>Shape.java</p>
<pre><code>public interface Shape {
   void draw();
}
</code></pre><h3 id="创建实现形状接口的实体类"><a href="#创建实现形状接口的实体类" class="headerlink" title="创建实现形状接口的实体类"></a>创建实现形状接口的实体类</h3><p>Rectangle.java</p>
<pre><code>public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Rectangle-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Square.java</p>
<pre><code>public class Square implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Square-&gt;draw() method.&quot;);
   }
}
</code></pre><p>Circle.java</p>
<pre><code>public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Inside Circle-&gt;draw() method.&quot;);
   }
}
</code></pre><h3 id="为颜色创建一个接口。"><a href="#为颜色创建一个接口。" class="headerlink" title="为颜色创建一个接口。"></a>为颜色创建一个接口。</h3><p>Color.java</p>
<pre><code>public interface Color {
   void fill();
}
</code></pre><h3 id="创建实现颜色接口的实体类"><a href="#创建实现颜色接口的实体类" class="headerlink" title="创建实现颜色接口的实体类"></a>创建实现颜色接口的实体类</h3><p>Red.java</p>
<pre><code>public class Red implements Color {

   @Override
   public void fill() {
      System.out.println(&quot;Inside Red-&gt;fill() method.&quot;);
   }
}
</code></pre><p>Green.java</p>
<pre><code>public class Green implements Color {

   @Override
   public void fill() {
      System.out.println(&quot;Inside Green-&gt;fill() method.&quot;);
   }
}
</code></pre><p>Blue.java</p>
<pre><code>public class Blue implements Color {

   @Override
   public void fill() {
      System.out.println(&quot;Inside Blue-&gt;fill() method.&quot;);
   }
}
</code></pre><h3 id="为-Color-和-Shape-对象创建抽象类来获取工厂"><a href="#为-Color-和-Shape-对象创建抽象类来获取工厂" class="headerlink" title="为 Color 和 Shape 对象创建抽象类来获取工厂"></a>为 Color 和 Shape 对象创建抽象类来获取工厂</h3><p>AbstractFactory.java</p>
<pre><code>public abstract class AbstractFactory {
   abstract Color getColor(String color);
   abstract Shape getShape(String shape) ;
}
</code></pre><h4 id="abstract复习"><a href="#abstract复习" class="headerlink" title="abstract复习"></a>abstract复习</h4><p>abstract修饰类，会使这个类成为一个抽象类，这个类将不能生成对象实例，但可以做为对象变量声明的类型（见下面代码），也就是编译时类型。抽象类就相当于一类的半成品，需要子类继承并覆盖其中的抽象方法。</p>
<h2 id="创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象"><a href="#创建扩展了-AbstractFactory-的工厂类，基于给定的信息生成实体类的对象" class="headerlink" title="创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象"></a>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象</h2><p>ShapeFactory.java</p>
<pre><code>public class ShapeFactory extends AbstractFactory {

   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)){
         return new Square();
      }
      return null;
   }

   @Override
   Color getColor(String color) {
      return null;
   }
}
</code></pre><p>ColorFactory.java</p>
<pre><code>public class ColorFactory extends AbstractFactory {

   @Override
   public Shape getShape(String shapeType){
      return null;
   }

   @Override
   Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase(&quot;RED&quot;)){
         return new Red();
      } else if(color.equalsIgnoreCase(&quot;GREEN&quot;)){
         return new Green();
      } else if(color.equalsIgnoreCase(&quot;BLUE&quot;)){
         return new Blue();
      }
      return null;
   }
}
</code></pre><h3 id="创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂"><a href="#创建一个工厂创造器-生成器类，通过传递形状或颜色信息来获取工厂" class="headerlink" title="创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂"></a>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂</h3><p>FactoryProducer.java</p>
<pre><code>public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase(&quot;SHAPE&quot;)){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase(&quot;COLOR&quot;)){
         return new ColorFactory();
      }
      return null;
   }
}
</code></pre><h3 id="使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象"><a href="#使用-FactoryProducer-来获取-AbstractFactory，通过传递类型信息来获取实体类的对象" class="headerlink" title="使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象"></a>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象</h3><p>AbstractFactoryPatternDemo.java</p>
<pre><code>public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {

      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;);

      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;);

      //调用 Circle 的 draw 方法
      shape1.draw();

      //获取形状为 Rectangle 的对象
      Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;);

      //调用 Rectangle 的 draw 方法
      shape2.draw();

      //获取形状为 Square 的对象
      Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;);

      //调用 Square 的 draw 方法
      shape3.draw();

      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;);

      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor(&quot;RED&quot;);

      //调用 Red 的 fill 方法
      color1.fill();

      //获取颜色为 Green 的对象
      Color color2 = colorFactory.getColor(&quot;Green&quot;);

      //调用 Green 的 fill 方法
      color2.fill();

      //获取颜色为 Blue 的对象
      Color color3 = colorFactory.getColor(&quot;BLUE&quot;);

      //调用 Blue 的 fill 方法
      color3.fill();
   }
}
</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>Inside Circle-&gt;draw() method.
Inside Rectangle-&gt;draw() method.
Inside Square-&gt;draw() method.
Inside Red-&gt;fill() method.
Inside Green-&gt;fill() method.
Inside Blue-&gt;fill() method.
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对比工厂方法模式，因为一个工厂只能生产一个产品，比如 <a href="http://blog.csdn.net/qq_36982160/article/details/79505390" target="_blank" rel="noopener"> 博客
</a><br>中一个ShapeFactory只能根据不同情况实例化不同的Shape，那么当我们需要一整套的产品（比如形状和颜色形成了一套产品）时使用工厂方法显然就不能解决了，所以就需要抽象工厂模式，抽象工厂模式实际上是工厂的工厂，即其作用的目的是为了实例化不同的工厂，用户再通过不同的工厂实例化不同场景下成套的产品。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">127</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">90</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src=""></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
