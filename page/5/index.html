<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="DmrfCoder的个人主页">
<meta property="og:url" content="http://www.mashangxue123.com/page/5/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DmrfCoder的个人主页">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/page/5/">





  <title>DmrfCoder的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/06/10/《最强大脑》/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/10/《最强大脑》/" itemprop="url">《最强大脑》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-10T16:24:30+08:00">
                2018-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h1><p>苏珊娜•埃尔库拉诺-<br>乌泽尔，神经学家，美国范德堡大学心理学与生物科学系副教授，TED大会演讲人。苏珊娜从经常被大众忽略的神经元数量入手，以一种全新的理论解释了为什么人类比其他物种更聪明。</p>
<h1 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h1><p>本书是一本探讨人类大脑进化的新锐研究作品。它开创了崭新的研究方法，同时以简明易懂的语言为读者阐明了 <strong>影响智力水平的因素</strong> 。更重要的是，本书针对<br><strong>人类大脑为什么更聪明</strong> 这个问题提出了与以往研究截然不同的全新理论。</p>
<h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><p>大脑皮层的 <strong>神经元数量</strong><br>决定了动物的智力水平，人类大脑皮层中的神经元数量远高于其他物种，所以人类比其他物种更聪明。由于神经元数量越多，大脑的重量越大，对应的身体重量也越大。因此在进化过程中，可用卡路里量的有限性强迫大型类人猿在<br><strong>身体重量和脑子重量之间做出选择</strong><br>。人类因为掌握了烹饪技术而使在短时间内摄入大量卡路里以支持大脑运转成为可能。其他物种则不得不牺牲神经元数量，将摄入的卡路里用于维持身体运转。<br><img src="https://img-
blog.csdn.net/20180610161649183?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>图片来源：《得到》</p>
<h2 id="神经元缩放规则"><a href="#神经元缩放规则" class="headerlink" title="神经元缩放规则"></a>神经元缩放规则</h2><p>简单来说，就是每种动物的大脑在进化过程中，都要遵循一定的规则。这种规则规定了神经元数量和大脑体积之间的关系。有的动物进化程度比较高，在相同体积的情况下，能拥有更多的神经元。有的动物进化程度比较低，在相同体积的情况下，神经元数量比较少。需要注意的是，所有动物<br><strong>大脑的重量和体积呈正相关的关系</strong><br>，体积越大，重量也越大。所以在研究的过程中，有的科学家把体积当作参数，有的科学家把重量当作参数，但他们得出的结论是大致相同的。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>比如以老鼠为代表的啮齿类，它们就属于进化程度比较低的，大脑体积不大，拥有的神经元数量也很少。人类作为一种极其聪明的物种，拥有高达1000亿个神经元。如果我们不幸地遵循了老鼠的神经元缩放规则，为了保持1000亿个神经元，我们的大脑重量就得超过60斤，对应的体重将高达80吨！</p>
<h2 id="人类的大脑遵循类灵长动物的进化规则"><a href="#人类的大脑遵循类灵长动物的进化规则" class="headerlink" title="人类的大脑遵循类灵长动物的进化规则"></a>人类的大脑遵循类灵长动物的进化规则</h2><p>人类的大脑之所以展现出异于其他物种的高级能力，是因为作为灵长类动物的一员，人类的大脑严格遵循了灵长类动物的神经元规则，<br><strong>在更小的大脑皮层和小脑里塞进了更多的神经元</strong><br>，在智力水平上把其他物种远远甩在身后。但是人脑也有其自身的特殊性，比如：相对于同等体型的非灵长类动物，人类的脑子足足比大了7倍；人脑每天消耗的能量占人体全部耗能的25%；大猩猩脑子的体积只有人类大脑体积的1/3，在人类面前实在是不值一提。</p>
<h2 id="“脑之汤”的实验方法"><a href="#“脑之汤”的实验方法" class="headerlink" title="“脑之汤”的实验方法"></a>“脑之汤”的实验方法</h2><p>在“脑之汤”这种方法出现之前，对神经元计数的难点在于大脑内的细胞并不是均衡分布的。通过把固体的大脑变成细胞核在其中自由浮动的、具有均衡性的汤，苏珊娜只要取一小部分汤出来，数清楚里面有多少细胞核，也就知道了大脑中有多少细胞。大脑中除了重要的神经元，还有一些其他类型的细胞。苏珊娜的下一步是将一种只能把神经元染色的抗体加入脑之汤，再数一数被染色的细胞核有多少，从而计算出神经元占大脑所有细胞的比例，以及神经元的真实数量。</p>
<h2 id="决定动物聪明程度的是神经元数量而不是脑容量"><a href="#决定动物聪明程度的是神经元数量而不是脑容量" class="headerlink" title="决定动物聪明程度的是神经元数量而不是脑容量"></a>决定动物聪明程度的是神经元数量而不是脑容量</h2><p>在科学领域，聪明程度通过“认知能力”的高低来体现。认知能力只与一个东西有关系，那就是大脑皮层中的神经元数量。其他动物的脑子虽然大，但人类大脑皮层中的神经元数量远比其他动物要多，所以人类比其他物种更聪明。</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>苏珊娜选择了重量巨大的大象的脑子与人脑进行比较，试图找出到底是全脑重量还是大脑皮层神经元数量影响了大象和人类的认知水平。<br>人类显然要比大象聪明，我们会说话、会写字、还能把大象拉到实验室里研究一番。但是人类的全脑重量只是大象全脑重量的三分之一，所以首先可以排除全脑重量对认知能力的影响。我们再来看大脑皮层神经元数量。整个大象脑子总共有2570亿神经元，但是其中98%的神经元都存在于大象的小脑。在大脑皮层神经元数量这个最关键的数据上，大象只有56亿，无法与人类的160亿神经元相提并论。<br>这些实验数据有力地证明了这个结论： <strong>大脑重量并不重要，大脑皮层的神经元数量才是决定人类聪明与否的关键</strong> 。</p>
<h2 id="烹饪在人类进化的过程中的作用"><a href="#烹饪在人类进化的过程中的作用" class="headerlink" title="烹饪在人类进化的过程中的作用"></a>烹饪在人类进化的过程中的作用</h2><p>在进化早期，大脑的地位并不太重要。因为觅食能力相对低下，人类和其他动物一样，摄取能量的绝大部分被用于维持身体机能运转。大脑消耗能量的多少跟其拥有的神经元数量密切相关，神经元数量越多，人越聪明，大脑耗能越大。<br><strong>分配给大脑的能量变少了，我们就自然而然地更笨了</strong> 。<br>人类掌握烹饪技巧之后，在同样的时间里、耗费同样的体力，能够获得更多的能量。在进化的过程中， <strong>更多的能量意味着人类有机会把多出的能量分配给大脑</strong><br>。久而久之，大脑就有机会拥有更多的神经元，变得更聪明，聪明到学会耕种、学会畜牧，开始农业文明。从这个角度看，如果没有某位祖先在某天突然掌握了烹饪技巧，我们的大脑还会和其他近亲一样，只能沦为身体的附庸，起不到决定性作用。所以我们在潜意识里把烹饪视为极其重要的技能，进而影响了我们对其他人的判断。</p>
<h1 id="金句"><a href="#金句" class="headerlink" title="金句"></a>金句</h1><ul>
<li><p>人类的优势在于我们是唯一研究自己和其他事物，并且在研究的过程中产生知识，完好无损地传播开来的物种；我们能改变自己，用戴眼镜、植入和手术等方式弥补自己的缺陷，从而改变自然选择的规律；我们彻底改变自己所在的环境，使我们能在任何地方居住；我们使用工具制造工具，使工具变得更强大，能解决更多更困难的问题；我们不断寻找更复杂的问题的解决方案，这让我们自己的能力也随之增长；我们创造描述知识的方法，让后人学习知识时不再需要直接的演示—这些都使我们变得特别。虽然所有需要的认知能力都不是人类独有的，我们应用这些认知能力的复杂性和灵活性显然是其他任何物种难以望其项背的。 </p>
</li>
<li><p>我进行了一项名为“你了解你的大脑吗”的调查，其中一个问题是“我们仅使用了大脑的10%”，60%接受过大学教育的里约本地人的答案为“是”，我对此感到非常震惊。我在流行科学杂志甚至宣传片中都看到过这个易使人上当的描述，但是从没预料到它在公众的意识中如此根深蒂固——而且这个说法还是虚构的。我们在任何时候都需要使用整个脑子，我们学习和进步，成就伟大的事业，甚至在睡觉时都使用了100%的脑子，只是使用的方式不同。 </p>
</li>
<li><p>我们已经到达这个位置，我们中只有极少的人主宰了现在的技术。谁知道怎么融化和加工金属？更不用说用它来从头制造一辆汽车、一部手机或者一台电脑。能自称科学家甚至不等于我知道怎么制作一支简单的铅笔。当今技术中的很多不再掌握于一个个体。我们夸口从古希腊以来走了很长的路—但是我们不再同时是建筑学、生物学和理学专家。这就是为什么科学（知识）和技术（工艺）必须被小心地栽培、记录和传授给下一代。拥有令人瞩目的大脑皮层神经元数量从而能达到令人瞩目的成就是不够的：我们站立于前人的肩膀之上，并且现在我们这一物种的成就作为一个整体远远超过任何一个个体。人类很久以来就超越了个人。它自强化地匹配了我们大脑皮层中惊人数量的神经元促成的技术发明和文化传播，后者又将我们的性能成形为能力，并让我们成为人——无论情况好还是坏 </p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/06/08/《见识》/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/《见识》/" itemprop="url">《见识》</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-08T17:09:03+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>最近大概读了一下吴军老师的《见识》，觉得写的很不错，分享一些content给大家，书中精髓就是吴军老师讲的几个误区：简单重复，习惯性失败，林黛玉式的困境，狗熊掰棒子。</p>
<h1 id="简单重复"><a href="#简单重复" class="headerlink" title="简单重复"></a>简单重复</h1><p>有些人的10000小时都是在从事低层次的重复，上文中我提到的伪工作者就是这种人。再举个具体的例子，如果在中学学习数学，不断重复做容易的题，考试成绩永远上不去，当然不会有中学生这么做。但是，在工作中很多人却犯这个错误。比如现在互联网比较热门，一些人学了一点点编程技巧，也能挣到还不错的工资，于是就守着这点技能每天在低水平地重复。我在《智能时代》这本书里提过一个观点：在未来的智能时代，真正受益于技术进步的个人可能不超过人口的2%。坦率地讲，仅仅会写几行Javascript（直译式脚本语言）的人不属于我说的2%的行列，这些人恰恰在未来是要被计算机淘汰的。</p>
<h1 id="习惯性失败"><a href="#习惯性失败" class="headerlink" title="习惯性失败"></a>习惯性失败</h1><p>这一类人和前面讲的正相反。他们好高骛远，不注重学习，懒得总结教训；同时脸皮还很薄，也不好意思请教。他们迷信失败是成功之母的说法，然而简单地重复失败是永远走不出失败的怪圈的。因此这些人常常是时间花了很多，甚至不止10000小时，但是不见效果。在很多公司里都能见到这种人，一个人在下面捣鼓东西，就是找不到解决问题的方法。</p>
<h1 id="林黛玉式的困境"><a href="#林黛玉式的困境" class="headerlink" title="林黛玉式的困境"></a>林黛玉式的困境</h1><p>林黛玉其实是我非常喜欢的一个人物，我喜欢她实际上是因为她很有内涵和才气，想问题想得很深，但这也是她致命的弱点，她的才华越高，在自己的世界里越精进，对外界就越排斥（当然外界也排斥她）。我们知道，一个概念内涵越宽，外延就会越窄。你如果泛泛地说“桌子”这个概念，它包括非常多的家具，但是如果你说“法国洛可可宫廷式的核桃木贴面桌子”，世界上可能就没有几件了。林黛玉就是这样，她越是精进，越到后来贾府里只有贾宝玉能够懂她。我们很多人做事都是这样，越是在自己的一亩三分地上耕耘，对外界的所知就越少，而自己的适应性也就越差。有两类科学家，一类是掌握了一个方法，研究什么都是一流的，他们越往后走路越宽，比如爱因斯坦、费米和鲍林（两次获得诺贝尔奖的化学家）；另一类是路越走越窄，比如发明晶体管的夏克利（也因此获得了诺贝尔奖），他对自己研究的晶体管越来越熟悉，就对其他技术越来越不愿意接受，最后无法和工业界和学术界的同行交流。你会发现生活中有大量这样的人。</p>
<h1 id="狗熊掰棒子"><a href="#狗熊掰棒子" class="headerlink" title="狗熊掰棒子"></a>狗熊掰棒子</h1><p>10000小时的努力需要一个积累的效应，第二次的努力要最大限度地复用第一次努力的结果，而不是每一次都从头开始。希腊科学体系和东方工匠式的知识体系有很大的差别。前者有一个完整的体系，任何发明发现都是可以叠加的，你给几何学贡献了一个新的定理，几何学就扩大一圈。而后者不成体系，是零碎的知识点（甚至只是经验点），每一个新的改进都是孤立的，因此很多后来就失传了，以后的人又要从头开始。我们知道今天几乎任何一所三甲医院的主治医师，水平一定比50年前所谓的名医高很多。但是，今天没有哪个中医敢讲自己比500年前的名医水平高。这就是因为前者有积累效应，而后者没有。很多人读书也是狗熊掰棒子式的，做了一堆题，相互关系没有搞清楚，学到的都是零散的知识点，换一道题就不会做了，因此时间花得不少，成绩却上不去。在工作中也是如此。</p>
<p>对于每个人的情况可能不一样，从我自身来讲，能让我快速走出误区的办法是即使听到不中听的话，也要试着找出其中的合理之处，相当于换位思考，对于与我们意见不符的，我们可能会立即进行反驳，然后两个人闹得不愉快。所以我们要习惯回过头来三思。当某个人和讲一件事，你可能会觉得他完全是胡说八道，但是，一定要想第二遍，是否我错了，他对了。这一遍思考，一定不能假设自己是对的；如果又想了第二遍，还是觉得自己对，对方错，要想第三遍，是否我的境界不够，不能够理解他。为什么要想第三遍呢，因为任何一个想要精进的人，都要和比自己强的人多来往，第三种情况就很可能发生，因此这时候不妨进一步交流，深入了解对方那么说的原因。</p>
<p>其实我们厌恶与见识短浅的人交谈，并非是因为他们自身见识短浅，而是因为，他们用自己浅陋粗鄙的观念，肆无忌惮地评判他人，言语之间毫无半分谦逊与尊重。努力做一个见识渊博的人。时刻告诫自己。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最近有人说IT行业入门门槛越来越低，很多人到培训机构魔鬼训练3个月就可以挂牌上岗而且写的一手漂亮的代码。在这种情况下科班出身的程序员怎么才能不被干死呢?答案就是《见识》…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/26/罗永浩万字求职信/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/26/罗永浩万字求职信/" itemprop="url">罗永浩万字求职信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-26T22:45:09+08:00">
                2018-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂谈/" itemprop="url" rel="index">
                    <span itemprop="name">杂谈</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>俞校长您好：  </p>
<p>我先对照一下新东方最新的招聘要求：  </p>
<p>1、有很强的英语水平，英语发音标准  </p>
<p>英语水平还好，发音非常标准，我得承认比王强老师的发音差一点。很多发音恐怖的人（宋昊、陈圣元之流）也可以是新东方的品牌教师，我不知道为什么要要求这一条，尽管我没这方面的问题。  </p>
<p>2、大学本科或以上学历，英语专业者优先  </p>
<p>真不喜欢这么势利的条件，这本来应该是××之流的学校的要求。  </p>
<p>3、有过考TOEFL、GRE的经验  </p>
<p>GRE考过两次。  </p>
<p>4、有教学经验者，尤其是教过以上科目者优先  </p>
<p>教过后来被国家明令禁止的传销课，半年。  </p>
<p>5、口齿伶俐，中文表达能力强，普通话标准  </p>
<p>岂止伶俐，简直凌厉，普通话十分标准，除了对卷舌音不太在意（如果在意，平舌音也会发错，所以两害相衡取其轻）。  </p>
<p>6、具备较强的幽默感，上课能生动活泼  </p>
<p>我会让他们开心。  </p>
<p>7、具备较强的人生和科学知识，上课能旁征博引  </p>
<p>除了陈圣元，我在新东方上过课的老师（张旭、王毅峰、王昆嵩）都和文盲差不多，当然他们还小。说到底，陈圣元的全部知识也只是在于让人看不出他没有知识而已。  </p>
<p>8、具备现代思想和鼓动能力，能引导学员为前途奋斗  </p>
<p>新东方的学员是最合作，最容易被鼓动的，因为他们来上课的最大目的就是接受鼓动，这个没有问题。  </p>
<p>9、年龄在40岁以下  </p>
<p>28岁。  </p>
<p>下面是我的简历或是自述：  </p>
<p>罗永浩，男，1972年生于吉林省和龙县龙门公社。  </p>
<p>在吉林省延吉市读初中时，因为生性狷介，很早就放弃了一些当时我讨厌的主课，比如代数、化学、英文，后来只好靠走关系才进了当地最好的一所高中，这也是我刚正不阿的三十来年里比较罕见的一个污点。因为我和我国教育制度格格不入又不肯妥协，1989年高中二年级的时候就主动退学了。  </p>
<p>有时候我想其实我远比那些浑浑噩噩地从小学读到硕士博士的人更渴望高等教育，我们都知道钱钟书进清华的时候数学是零分（后来经证实其实是15分），卢冀野入东南大学的时候也是数学零分，臧克家去山东国立青岛大学的时候也是差不多的情况。今天的大学校长们有这样的胸襟吗？当然，发现自己文章写的不如钱钟书是多年后的事情了，还好终于发现了。  </p>
<p>退学之后基本上我一直都是自我教育（当然我的自我教育远早于退学之前），主要是借助书籍。因为家境还勉勉强强，我得以相对从容地读了几年书，“独与天地精神往来“。  </p>
<p>基于“知识分子要活得有尊严，就得有点钱”这样的认识（其实主要是因为书价越来越贵），我从1990年至1994年先后筛过沙子，摆过旧书摊，代理过批发市场招商，走私过汽车，做过期货，还以短期旅游身份去韩国销售过中国壮阳药及其他补品。令人难堪的是做过的所有这些都没有让我“有点钱“，实际上，和共同挣扎过的大部分朋友们比起来，我还要庆幸我至少没有赔钱。  </p>
<p>我渐渐意识到我也许不适合经商，对一个以知识分子自许的人来说，这并不是很难接受的事情，除非这同时意味着我将注定贫穷。  </p>
<p>1994年夏天，我找了个天津中韩合资企业的工作，并被派去韩国学习不锈钢金属点焊技术，1995年夏天回国的时候，很不幸我姐姐也转到了这家天津的公司并担任了副总经理，为了避嫌我只好另谋出路。  </p>
<p>1995年8月至1996年初，经一位做传销公司（上海雅婷）的老同学力邀，我讲了半年左右的传销课，深受广大学员爱戴。遗憾的是国家对这种有争议的商业形式采取的不是整顿而是取缔的政策，所以看到形势不对，我们就在强制命令下达之前主动结束了生意。  </p>
<p>因为那时候我爱上了西方音乐（古典以外的所有形式），大概收有上千张英文唱片，为了听懂他们在唱些什么，我在讲传销课的同时，开始学习一度深恶痛绝的英文。我在一个本地的三流私立英语学校上了三个月的基础英语课，后来因为他们巧立名目，拒付曾经答应给我的奖金（我去法院起诉过，又被法院硬立名目拒绝受理），我只好又自学了。  </p>
<p>实在不知道困在一个小地方可以做些什么，所以1996年夏天我到天津安顿下来（那时候我很喜欢北京，但是北京房价太丧心病狂了），靠给东北的朋友发些电脑散件，以及后来零星翻译一些机械设备的英文技术文章维生，因为生性懒散不觉蹉跎至今。  </p>
<p>我要感谢那本莫名其妙的预言书“诸世纪”，尽管我不是一个迷信的人，但是去年五一我看到那段著名的预言“1999年7月，恐怖的大王将从天而降……”的时候还是有些犹豫，我认真地考虑自己可能即将结束的生命里有什么未了的心愿，结果发现只有减肥。  </p>
<p>从我有记忆以来我就是个痛苦的胖子，因为胖，我甚至不得不隐藏我性格里比较敏感忧郁的一面，因为胖子通常被大众潜意识里不由分说地认为应该嘻嘻哈哈，应该性情开朗，应该徐小平。他们对一个矫矫不群的胖子的性格，能够容忍的上限是严肃，再出格一点就不行了，比如忧郁。  </p>
<p>虽然他们从来不能如此准确地说出这种想法，但是如果看到一个忧郁的胖子，他们就会直觉哪里不对了，他们的这种直觉的本质是，“你是个胖子，你凭什么忧郁呢？你还想怎么样？你已经是个胖子了。”所以很难见到一个肥胖的并且影响广泛的诗人，因为公众不能接受，任凭他的诗歌惨绿无比。  </p>
<p>当然胖子的痛苦永远不值得同情（除非是因为病理或基因导致），因为他们胖通常是因为缺乏坚强的意志（也许除了丘吉尔）。我就是个典型，我的肥胖完全是因为厌恶运动造成的，我有过十几次失败的减肥经历，我试过节食、锻炼、气功和几乎所有流行过的药物，包括在西方严禁非处方使用的芬弗拉明，我总怀疑我不如小时候开朗，是因为误用芬弗拉明造成的，它减肥的药理竟然是通过使人情绪低落从而降低食欲，事实上，它根本就不是研制用来减肥的，它本是用来使轻度狂躁型精神病患者稳定情绪的药。我是中国落后的药检制度的严重受害者。  </p>
<p>过了去年的五一节之后，我制定了严格的计划：每天只吃蔬菜、豆腐、全麦面包、鱼肉、橙汁、脱脂牛奶和善存，每天用一个小时跑10公里，也就是标准跑道的25圈。我不得不骄傲的是，我只用了58天就减掉了48斤体重，去掉休息的星期天，几乎是一天一斤。然后我心情平静地迎接了什么事情都没发生的7月。  </p>
<p>这件事过后我发现其实我还是很有毅力的一个人。但是我不知道我的毅力应该用来做什么，末日虽然没有来，但是新世纪来了，30岁也快来了，这真是一件让人坐立不安的事情。  </p>
<p>后来我一度想移民加拿大，所以一边找资料看，一边到天津大学夜间开办的口语学习班上课，一个班20多个人，一个外国教师（更多的时候是外国留学生）和我们天南地北地胡聊，除了政治。我一共上了四期这样的班，口语就差不多了，当然还是停留在比较普通的交流水平上，至少我看英文电影时还是需要看字幕，尽管在天津的四年间我看过大概600部英文电影。  </p>
<p>过了元旦，一个小朋友在和我吃饭的时候突然问我，为什么不去新东方教书，你应该很适合去新东方教书。我说我倒是喜欢讲课，但是一个民办教师有什么前途呢？他说如果年薪百万左右的工作不算前途，那他就没什么可说的了。我得说我很吃惊。  </p>
<p>不管怎么样，我仔细地把我能找到的关于新东方的材料都看了一遍，我觉得这个工作很适合我，尤其是看到杨继老师在网页上说“做一个自由而又敬业的人是我的梦想，新东方是实现它的好地方”的时候。在我尽管懒散无为却又是勤于思考的三十来年里，好像还是第一次看到一个很适合我，并且我也有兴趣去做的工作。杨继还转述席勒的话“忠于你年轻时的梦想”。我没看过席勒的东西，光知道有两个能写字儿的席勒，不知道是哪一个说的这话，但是我宁愿把它当成是新东方的精神。  </p>
<p>我听说教托福和教GRE薪水差不多，但是GRE的学习要苦得多。  </p>
<p>我想了想还是选择了GRE，毕竟托福是专门给非英语国家的学生考的，教书的满足感上逊色很多。  </p>
<p>旧历新年的时候，因为不确定是不是需要大学文凭才行，我试着写了一封应聘信给俞老师，提到我只有高中文凭，结果得到的答复是欢迎来面试，除了感激我还能说什么呢？我是说即便没有文凭不行，我还是会来新东方做教师的，但是可能不得不伪造证件，作为一个比大多数人都更有原则、以知识分子自诩的人，如果可能，我还是希望不搞这些虚假的东西，俞校长的开明，使得我不必去做大违我的本性和原则的事情，得以保持了人格的完整，这是我时常感念的。  </p>
<p>过了春节处理了一些杂事，很快就到了6月份，我买了本“红宝书”就上山了。鹫峰山上的学习气氛和恶劣条件我都非常喜欢，应该是因为生活有了明确目标的关系吧。但是我很快发现，讲课教师的水平和他们的报酬，以及新东方的声誉比起来还是很不理想的。我看到身边大多数的同学对所有的老师评价都很好，听到那些愚蠢的笑话、对ETS肤浅的分析导致的轻浮谩骂和充满种族歧视、宗教歧视的言论的时候，大多数人都笑得很开心。  </p>
<p>这最终再次有力地证实了我一直怀有的一个看法：任何一个相对优秀的群体里面都是笨蛋居多。（励志名言<br><a href="http://www.lz13.cn）无论台下是300名来听传销的社会闲散人员，还是300名来听GRE的大学毕业生，对于一个讲课的人来说并没有多少区别，这也是他们在台上信口开河、吹牛放炮的信心来源。" target="_blank" rel="noopener">www.lz13.cn）无论台下是300名来听传销的社会闲散人员，还是300名来听GRE的大学毕业生，对于一个讲课的人来说并没有多少区别，这也是他们在台上信口开河、吹牛放炮的信心来源。</a>  </p>
<p>当然这里大多数同学专业都很出色，都很勤奋刻苦，积极上进，性格上也远比我更具备成功的素质，我只是说他们缺少情趣，他们聪明（至少他们都敢考GRE的数学，这是我想都不敢想的），但是没有灵气，人品也未必差，只是缺乏独立思考能力。  </p>
<p>我只喜欢陈圣元一个人的课，所以后来也就只去上他一个人的课，其他的时候一个人在宿舍背单词。陈圣元除了胡扯闲聊比较有水准之外，治学态度曾经也让我觉得很好，说起charter这个单词的时候，他说为了找到那个填空句子里面表达的意思，查遍了所有的词典都找不到满意的解释，最后花了一千多块钱买了一本巨大沉重的韦氏词典（显然是指Merriam<br>Webster’s Third New International Dictionary<br>Unabridged），才终于在该词典所列的关于charter的25条释义中的最后一条里找到了答案。  </p>
<p>说起市面上粗制滥造的填空参考书的时候，他很不以为然，“我以三年的教学经验也精心编写了一本，那些作者对题目绝对没有我钻研得深，他们就会胡编乱造，然后急忙出版抓紧骗钱，我这本可以说是这方面的集大成者，现在正在印刷当中，很快就可以和大家见面”。  </p>
<p>由于在山上的时候，单词还没怎么背，题目都没做过，所以他这些态度和表现曾经让我很景仰。发现不对头是下山之后开始的，我录了他的全部课堂录音，我听着录音大量做题的时候，才发现他的分析讲解漏洞百出，尽管他批评过去的新东方老师，都是拿了正确答案再进行分析讲解，可是他的工作显然也是一样，这样才能解释为什么他总是能用错误的分析推理，给你一个正确的答案。  </p>
<p>另外我发现所有的三流词典，包括英汉词典，都在charter的第一个释义上就解释了，他声称在韦氏第三版未删节新国际词典的25条释义的最后一条中找到的答案，“由君主或立法机关发给城市或大学，规定其特权及宗旨的特许状”，所以我也买了本十多斤重的韦氏第三版回来，发现只有13条释义，而且在第2条里就解释了这个问题。  </p>
<p>现在他的那本填空教程就在我手边，仅在No.4的52道题中，我就找到了18处错误，如果说翻译的错误对学生不重要，那么解题分析的错误也有10处之多。这也最终使得我改了主意，决定做填空老师，本来我想做词汇老师，那样可以海阔天空地胡扯。  </p>
<p>我以这样的条件敢来新东方应聘，除了脸皮厚这个最显而易见的表面原因之外，主要还是教填空课的自信。第二次考试之后我一直做填空的备课，最消耗时间的是把NO.4到1994年的全部填空题翻译成中文，400多个句子的翻译，居然用了我整整一个月的时间，基本上是一个小时翻译三个句子，当然快的时候两分钟一个，慢的时候几个小时翻不好一句。  </p>
<p>翻译这些句子是我本来的备课计划之外的工作，最终使我不得不做这个工作的原因是，钱坤强和陈圣元那两本“惨不忍睹”的教材。钱坤强的那本就不必说了，此人中文都有问题，尽管我坚信他的英文要远比我的水平高（也许应该说熟练），但是理论上一个人如果母语都掌握不好（这意味着他对语言本身不敏感），那么他肯定掌握不好任何其他语言，即便他能熟练运用，也不适合做语言方面的工作，比如文字翻译。他那本超级填空教程在新东方地下室卖了两年都没正式出版，一定程度上说明了这本书的水准。  </p>
<p>至于我非常喜欢的陈圣元，他在那本书的前言中说道：“翻译时尽量体现原文的结构，以便考生能对照原文体会原文句子结构的特征，从而体会结构与答案选项设计之间的关系……这样做会使得句子略显得欧化而不自然……不会去套用貌似华丽实则似是而非的成语。”  </p>
<p>作为一个考试学习用的教材，他声称的翻译原则和宗旨是很好的，但是很遗憾，我看到的绝不仅仅是一个欧化或是不自然的问题。首先“体现原文结构”应该表现为翻译成中文之后，原文中的各个句子成分最大限度地在译文中充当同样的成分，而不是把所有的成分不变动位置地翻译成对应的中文单词，这样的做法和那些《金山快译》之类的拙劣软件的翻译结果有什么区别呢？  </p>
<p>实际上《金山快译》这一类翻译软件的译文虽然狗屁不通，但是我们即使看不到原文，通过猜测也能大致明白它想说些什么，这就如同没学过日文的中国人看日文电器说明书里面夹杂的汉字，也能隐约猜出大意一样。陈圣元的译文本质上就是这样的一种东西，当然程度上有些区别。  </p>
<p>其实欧化并不可怕，尤其是在一本学习用的教材中，即使是在文学中，一些恶性的欧化今天也成了现代白话文的组成部分。陈圣元的译文根本不是欧化的问题，他的译文和钱坤强的一样，最恐怖也让人难以置信的是，作为所谓的译文，如果脱离了原文的对照，没有一个中国人知道这些句子在说什么，我是说这些句子字面上在说什么都没人看得懂，而不是因为句意晦涩难解而使人看不懂它想表达的内涵。  </p>
<p>另外，看得懂的很多句子又翻错了，即便看不懂句子的意思真的不影响正确答案的选择，但是作为一本教学参考书，如果参考译文都翻错了，还怎么让学生信服呢？除非是以一种变态的方式，比如“陈老师的译文都翻错了，可是他的GRE考分那么高，可见看不懂句子对答题反而有帮助”这一种。  </p>
<p>我的译文体现了这样几个原则，首先由于不是文学翻译，我注意了最大限度地使用原文的结构，使译文中的句子成分尽量充当原文中的对应成分。为了这种对应，有时候会有些比较不符合中文习惯的句子结构，比如一些在英文中可以置后的定语从句，按照中文的语法放到了修饰对象的前面之后，句子显得臃肿不堪，另外还可能导致断句困难。  </p>
<p>针对这样的问题，我在这类句子中大量地使用了括号和破折号，很多时候，如果只读括号外边的内容，读到的就是这个句子完整的主干，那些使句子结构变得复杂的修饰成分都在括号里边，但是如果假定这些括号不存在，把它们连起来读，也是一个通顺完整毫无语病的句子，这样和原文对照阅读时，对应的成分和原句的主干结构清晰可辨。  </p>
<p>（注：由于阅读的需要，我删去了罗永浩大量的修正例证。我请一位英语相当不错的博士看过这些例证，他说，水平相当高。）  </p>
<p>在解题思路上我修正了陈圣元的书中所有不严谨的地方，难以置信的是这些不严谨的错误，在他的书中竟有三成之多。我的草稿还有很多优点，虽然这些优点是我完成的，但是我不想为了向别人解释“我做的工作牛就牛在……”这样的东西浪费太多的时间，所以不再分析了。  </p>
<p>如果我们都接受“不存在完美的东西”这样一个假设，那么我想说的是，我的这本填空教材是离完美最近的那一个。希望我的坦率不会倒了您的胃口，当然我知道新东方的开明气度才会这样讲话。  </p>
<p>如果新东方出版参考书的惟一标准是书的质量，而不权衡其他方面的因素，那么陈圣元的那本书的寿命，不会也不应该超过一年。需要做一个效果未必理想的声明是，我并非有意攻击陈圣元，他在课上说起，新东方的同仁们的一个优点是互相不会拆台，也许私下并无深交但是不会互相诋毁，这对事业或是人生的成功起到了相对积极的作用。  </p>
<p>这种观点虽然不合我的本性，但是我也知道如果大家都是书生意气，新东方也没有今天。所以我接受了他的这个看法，基于这一点，我也不想对他做更多的攻击，很大程度上我对他的看法现在都坦率地说了出来，是因为他已经离开了，不存在和睦相处的问题。何况，他出色的幽默感和极佳的亲和力都是我很佩服的，毕竟他是新东方我见过的最喜欢的老师（如果不是惟一喜欢的）。对于他的工作和治学态度，我更多的是感到遗憾。  </p>
<p>当然我知道会有一些年轻教师不屑地说，教教GRE，算个屁治学？那好吧。  </p>
<p>我想我多半看起来像是个怪物，高中毕业，不敢考数学，居然要来做教师。但是我到新东方应聘不是来做教师的，我是来做优秀教师的，所以不适合以常理判断。即使新东方的声誉和报酬使得它从来都不缺教师，我也知道优秀的教师永远都是不嫌多的，如果新东方从来都不缺优秀教师，那么我也知道更优秀的教师从来都是新东方迫切需要的。  </p>
<p>龚自珍劝天公“不拘一格降人才”，如果“不拘一格”的结果是降下了各方面发展严重失衡的，虽然远不是全面但又是十分优秀的畸形人才，谁来劝新东方“不拘一格用人才”呢？想想王强老师的经历，所以我也来试试说服您，我们都知道那个美国老头，虽然觉得他很荒唐，但是他还是给了王强老师一个机会去见他，一个机会去说服他，所以我想我需要的也就是这么个机会而已。给我个机会去面试或是试讲吧，我会是新东方最好的老师，最差的情况下也会是“之一”。  </p>
<p>如果几年以后你来新东方看到一个人，咦，面熟，就是想不起来是谁，好像是罗永浩的弟弟，注意，我没有弟弟。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/22/Algorithm summary/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/Algorithm summary/" itemprop="url">Algorithm summary</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-22T22:49:00+08:00">
                2018-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2018.5.24日更新：<br>去掉原文中的目录，修正了目前我发现的错别字（其实也没几个，但是本着严谨的态度我还是决定修改过来），增添了部分代码注释（发现自己写的代码现在竟然看不懂，只能强行加注释了～）</p>
<h1 id="一：算法分析基本概念"><a href="#一：算法分析基本概念" class="headerlink" title="一：算法分析基本概念"></a>一：算法分析基本概念</h1><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><h3 id="Linearsearch"><a href="#Linearsearch" class="headerlink" title="Linearsearch"></a>Linearsearch</h3><pre><code>/*
 * 输入：n个元素的数组A[1...n]、x
 * 输出：如果x=A[j]&amp;&amp;1&lt;=j&lt;=n，则输出j，否则输出0
 */

int Linearsearch(int *A,int x, int n){
    int j=0;
    while (j&lt;n&amp;&amp;x!=A[j]){
        j++;
    }

    if(x==A[j])return j;
    return 0;
}
</code></pre><h3 id="Binarysearch"><a href="#Binarysearch" class="headerlink" title="Binarysearch"></a>Binarysearch</h3><pre><code>/*
 * 输入：n个元素的升序数组A[1...n]、x
 * 输出：如果x=A[j]&amp;&amp;1&lt;=j&lt;=n，则输出j，否则输出0
 */

int Binarysearch(int *A, int x, int n) {
    int low = 1, high = n, j = 0;
    while (low &lt;= high &amp;&amp; j == 0) {
        int mid = (int) ((low + high) / 2);
        if (x == A[mid])j = mid;
        else if (x &lt; A[mid])high = mid - 1;
        else low = mid + 1;
    }

    return j;
}
</code></pre><p>要注意二分搜索的输入一定是一个 <strong>升序</strong><br>的数组，实质就是一个二叉搜索树（所以也把二分搜索的执行描述为决策树），对于一个大小为n的排序数组，算法Binarysearch执行比较的最大次数为int（logn）+1（如果输入数组不是递增排好序的，则可在nlogn内对其进行排序后再进行二分搜索）。</p>
<h2 id="合并两个已排序的表"><a href="#合并两个已排序的表" class="headerlink" title="合并两个已排序的表"></a>合并两个已排序的表</h2><pre><code>/*
 * 输入：数组A[1...m]和它的三个索引p，q，r，1&lt;=p&lt;=q&lt;r&lt;=m，p、q、r满足A[p...q]、A[q+1...r]分别按照升序排列
 * 输出：合并两个子数组A[p...q]和A[q+1...r]的数组A[p...r]
 */

void Merge(int *A, int p, int q, int r) {
    int B[r + 1];//B[p...r]是辅助数组
    int s = p, t = q + 1, k = p;//s指向A[p...q]子数组，t指向A[q+1...r]子数组，k指向B数组
    while (s &lt;= q &amp;&amp; t &lt;= r) {
        if (A[s] &lt;= A[t]) {
            B[k] = A[s];
            s++;
        } else {
            B[k] = A[t];
            t++;
        }

        k++;
    }

    if (s = q + 1) {//说明s指向的数组已经遍历完了
        for (int i = t; i &lt;= r; ++i) {
            B[k++] = A[i];
        }
    } else {
        for (int i = s; i &lt;= r; ++i) {
            B[k++] = A[i];
        }
    }

    for (int j = p; j &lt;= r; ++j) {
        A[j] = B[j];

    }
}
</code></pre><p>设Merge算法要合并两个大小分别为n1和n2的数组（n1</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code>/*
 * 输入：n个元素的数组A[1...n]
 * 输出：按非降序排列的数组A[1...n]
 */

void SelectionSort(int *A, int n) {

    for (int i = 0; i &lt; n; ++i) {

        for (int j = i + 1; j &lt;= n; ++j) {
            if (A[i] &gt; A[j]) {
                int t = A[i];
                A[i] = A[i];
                A[i] = t;
            }
        }
    }

}
</code></pre><p>算法SelectionSort所需的元素比较次数为n(n-1)/2（n-1+n-2+n-3+…+2+1=n(n-1)/2），因为每次交换需要3次赋值，所以元素的赋值次数介于0到3(n-1)之间。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先将第二个数与第一个数进行对比，如果第二个数比第一个数小，则将第二个数插入到第一个数之前，这样保证前两个数是有序的；<br>接下来将第三个数与前两个数对比，比较的思路是先将第三个数存下来（记为x），然后将第三个数与第二个数比较，如果第二个数比第三个数大，则直接将第二个数向后移动一位，如果第二个数不比第三个数大，则说明此时前三个数都是有序的，因为之前前两个数是有序的，比较到最后，将x放到第三个数比较的终止位置即可。以此类推，将后面的i个数分别其前面的i-1个数进行对比，并将其插入到第一个比其大的数前面，最后即可完成排序。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/*
 * 输入：n个元素的数组A[1...n]
 * 输出：按非降序排列的数组A[1...n]
 */

void InsertionSort(int *A, int n) {
    for (int i = 2; i &lt;= n; ++i) {
        int x = A[i];
        int j = i - 1;
        while (j &gt; 0 &amp;&amp; A[j] &gt; x) {
            A[j + 1] = A[j];
            j--;
        }
        A[j + 1] = x;
    }
}
</code></pre><p>执行算法SelectionSort的元素比较次数在n-1到n(n-1)/2之间，元素赋值次数等于元素比较次数加上n-1.</p>
<h2 id="自底向上合并排序"><a href="#自底向上合并排序" class="headerlink" title="自底向上合并排序"></a>自底向上合并排序</h2><pre><code>/*
 * 输入：n个元素的数组A[1...n]
 * 输出：按非降序排列的数组A[1...n]
 */


void Merge(int *A, int p, int q, int r);

void BottomUpSort(int *A, int n) {
    int t = 1;
    while (t &lt; n) {
        int s = t, t = 2 * s, i = 0;
        while (i + t &lt;= n) {
            Merge(A, i + 1, i + s, i + t);
            i = i + t;
        }
        if (i + s &lt; n) {
            Merge(A, i + 1, i + s, n);
        }
    }
}
</code></pre><p>用算法BottomUpSort对n个元素的数组进行排序，当n为2的幂时，元素比较次数在(nlogn)/2到nlogn-n+1之间。执行该算法的元素赋值次数为2nlogn。</p>
<h2 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h2><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>前文提到算法InsertionSort执行的运算次数至多为cn^2，其中c为某个适当选择的正常数。这时我们说算法InsertionSort的运行时间是O(n^2)，说明当排序元素的个数等于或超过某个阈值n0时，对于某个常量c，运行时间是cn^2，<br><strong>O符号描述的是一个上界但不一定是算法的实际执行时间</strong><br>，比如当排序一个已经排序好的数组时InsertionSort的运行时间就不是O(n^2)而是O(n)了。</p>
<h3 id="Ω"><a href="#Ω" class="headerlink" title="Ω"></a>Ω</h3><p>相比于O，Ω描述的是算法执行的 <strong>下界</strong><br>，比如算法InsertionSort的运算时间至少是cn，则称算法InsertionSort的运行时间是Ω（n），即无论何时，当被排序的元素个数等于或超过某一个阈值n0时，对于某个常数c，算法的运行时间至少是cn。</p>
<h3 id="Senta"><a href="#Senta" class="headerlink" title="Senta"></a>Senta</h3><p>Senta描述的是一个确切界限，如果对于任意大小等于或超过某一阈值n0的输入，如果运行时间在c1g(n)和c2g(n)之间，则称算法的运行时间是Senta(g(n))。</p>
<h3 id="复杂性类与-o-符号"><a href="#复杂性类与-o-符号" class="headerlink" title="复杂性类与 o 符号"></a>复杂性类与 o 符号</h3><h4 id="o符号"><a href="#o符号" class="headerlink" title="o符号"></a>o符号</h4><p>O 符号给出的上界可以是“紧”的,也可以是非“紧”的。<br>2<em> n^ 2 =O ( n^ 2 ) 是渐近性紧边界<br>2 </em>n = O ( n^ 2 ) 不是渐近性紧边界</p>
<p>o 符号就用来表示 <strong>不是渐近性紧边界</strong> 的上界<br>举例: 2 n = o ( n ) , 2 ^n ！= o ( n )</p>
<p>直观上来说,在小 o 符号中, f ( n ) =o ( g ( n )) ,当 n 趋向于无穷大时, f (n ) 函数相当于 g (n )<br>就变得不再重要了<br>即lim- &gt;+oof(n)/g(n)=0</p>
<h4 id="w符号"><a href="#w符号" class="headerlink" title="w符号"></a>w符号</h4><p>用类比法来讲,小 w符号相对于大 Ω符号的关系正如 o 符号相对于 O 符号的关系。<br>我们用小 w 符号来表示一个 <strong>渐近性非紧密的下界</strong> 。<br>比如：</p>
<blockquote>
<p>(n^2)/2=w(n )<br> (n^2)/2!=w(n^2)</p>
</blockquote>
<p>lim- &gt;+oof(n)/g(n)=oo</p>
<h2 id="空间复杂性"><a href="#空间复杂性" class="headerlink" title="空间复杂性"></a>空间复杂性</h2><p>我们把算法使用的空间 定义 、为:为了求解问题的实例而执行的计算步骤所需要的内存空间,它<br><strong>不包括分配用来存储输入的空间（为了区分那些在整个计算过程中占用了少于输入空间的算法）</strong> 。</p>
<p>算法的 <strong>空间复杂性不可能超过运行时间的复杂性</strong> ,因为每写入一个内存单元都至少需要一定的时间。所以,如果用 T (n ) 和 S (n )<br>分别代表算法的时间复杂性和空<br>间复杂性,有: S ( n ) = O ( T ( n )) 。</p>
<h2 id="最优算法"><a href="#最优算法" class="headerlink" title="最优算法"></a>最优算法</h2><p>如果可以证明任何一个求解问题 T的算法必定是Ω ( f ( n )) ,那么我们把在 O ( f ( n )) 时间内求解问题T的任何算法都称为问题<br>T的最优算法。</p>
<h3 id="如何估计算法的运行时间"><a href="#如何估计算法的运行时间" class="headerlink" title="如何估计算法的运行时间"></a>如何估计算法的运行时间</h3><ul>
<li>计算迭代次数 </li>
<li>计算基本运算的频度 </li>
</ul>
<blockquote>
</blockquote>
<p>一般来说,在分析一个算法运行时间时,可以找出这样一个元运算,它的频率至少和任何其他运算的频度一样大,称这样的运算为基本运算。我们还可以放宽这个定义,把那些频度和运行时间成正比的运算包括进来。</p>
<ul>
<li>使用递推关系 </li>
</ul>
<blockquote>
</blockquote>
<p>如果一个算法本身是递归算法,那么计算这个算法运行时间的函数通常也是递归的,即是指,这个函数的定义中引用了函数自身。即便一个算法本身是非递归的,我们有时也可以用递归式来计算它的运行时间。</p>
<p>lim- &gt;+oof(n)/g(n)!=oo f(n)=O(g(n))<br>lim-&gt;+oof(n)/g(n)!=0 f(n)=Ω(g(n))<br>lim-&gt;+oof(n)/g(n)==c f(n)=Senta(g(n))</p>
<h1 id="二：堆和不相交集数据结构"><a href="#二：堆和不相交集数据结构" class="headerlink" title="二：堆和不相交集数据结构"></a>二：堆和不相交集数据结构</h1><p>在很多情况下我们需要使用一种具有 <strong>插入元素</strong> 和 <strong>查找最大值元素</strong> 的数据结构，这种数据结构叫做 <strong>优先队列</strong><br>，如果采用普通队列，那么寻找最大元素需要搜索整个队列，开销比较大；如果使用排序数组，插入运算就需要移动很多的元素，开销也会比较大。这时候 <strong>堆</strong><br>就是一种 <strong>有效的实现优先队列的数据结构</strong> 。</p>
<p>堆的特点：</p>
<ul>
<li>父节点大于等于子节点（但是两个子节点之间的大小关系没有要求），这样可以做到 <strong>沿着每条从根节点到叶子节点的路径，元素的键值都是以非升序排列的</strong> 。 </li>
<li>堆是一个 <strong>几乎完全的二叉树</strong> ，所以具有和完全二叉树一样的特点，即一般是存储在一个数组A[n]中，A[i]的左子节点在A[2i]中，右子节点在A[2i+1]中（当他们存在的时候）,A[i]的父亲节点在A[i/2]中（如果存在，i/2向下取整）。 </li>
</ul>
<p>堆需要支持的几种运算：</p>
<pre><code>* delete-max[H] 从一个非空的堆H中删除最大元素并将数据项返回 
* insert[H,x] 将x插入到对H中 
* delete[H,i] 从堆中删除第i项（注意不是删除i） 
* makeheap[A] 将A转换成一个堆 
</code></pre><h2 id="堆上的运算"><a href="#堆上的运算" class="headerlink" title="堆上的运算"></a>堆上的运算</h2><h3 id="两个辅助运算"><a href="#两个辅助运算" class="headerlink" title="两个辅助运算"></a>两个辅助运算</h3><h4 id="SIFT-UP"><a href="#SIFT-UP" class="headerlink" title="SIFT-UP"></a>SIFT-UP</h4><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><p>当某个节点（H[i]）的值大于他的父亲节点的值时，需要通过SITF-UP将这个节点 <strong>沿着从H[i]到H[1]这条唯一的路径</strong><br>上移到合适的位置以形成一个合格的堆。</p>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><p>将H[i]与其父亲节点H[i/2]比较，如果H[i]大于H[i/2]，则将H[i]与H[i/2]互换，直到H[i]没有父节点或者H[i]不大于H[i/2]。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><pre><code> int SiftUp(int *H, int i) {

    while (true) {
        if (i == 1) {
            break;//说明当前i是根节点
        }
        if (H[i] &gt; H[(int) i / 2]) {//如果当前节点比父亲节点大
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
            i = i / 2;
        } else {
            break;
        }
    }
    return 0;
}
</code></pre><h4 id="SIFT-DOWN"><a href="#SIFT-DOWN" class="headerlink" title="SIFT-DOWN"></a>SIFT-DOWN</h4><h5 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h5><p>当某个节点（H[i]，i&lt;=(int)n/2即 <strong>非叶子节点</strong><br>）的值小于它的两个子节点H[2i]和H[2i+1]（如果存在的话）的最大值时，需要将SIFT-DOWN将渗到合适的位置。</p>
<h5 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h5><p>将H[i]与其两个子节点中值最大的元素比较，如果小于最大的那个节点，则将H[i]与其最大的那个子节点互换。</p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><pre><code> int SiftDown(int *H, int i, int n) {
    while (true) {
        i = 2 * i;
        if (i &gt; n) {
            break;
        }

        if (i + 1 &lt;= n) {
            if (H[i + 1] &gt; H[i]) {//比较两个子节点哪个最大
                i++;
            }
        }

        if (H[i] &gt; H[(int) i / 2]) {
            int t;
            t = H[i];
            H[i] = H[(int) i / 2];
            H[(int) i / 2] = t;
        }
    }
}
</code></pre><h3 id="插入（insert）"><a href="#插入（insert）" class="headerlink" title="插入（insert）"></a>插入（insert）</h3><h5 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h5><p>将元素x插入到已有的堆H中</p>
<h5 id="实现思路-2"><a href="#实现思路-2" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先将堆的大小增加1（n++），然后将x放在H[n]中，然后根据需要将H[n]中的元素x进行上移操作，直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析"><a href="#算法时间复杂度分析" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以将一个元素插入大小为n的堆中所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><pre><code> void insert(int *H,int x,int &amp;n){
    n++;
    //这里默认H开的空间够用
    H[n]=x;
    SiftUp(H, n);//将x根据需要上移
}
</code></pre><h3 id="删除（delete）"><a href="#删除（delete）" class="headerlink" title="删除（delete）"></a>删除（delete）</h3><h5 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h5><p>将堆H中的元素x删除</p>
<h5 id="实现思路-3"><a href="#实现思路-3" class="headerlink" title="实现思路"></a>实现思路</h5><p>用堆中的最后一个元素H[n]替换需要删除的元素H[i]，然后堆的大小减一（n–），然后根据需要对H[i]进行上移或者下渗直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析-1"><a href="#算法时间复杂度分析-1" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><pre><code> void Delete(int *H, int i, int &amp;n) {

    if (i == n) {//如果需要删除的是最后一个元素
        n--;
        return;
    }

    H[i] = H[n];
    n--;

    if (H[i] &gt; H[(int) i / 2]) {//如果当前节点比父亲节点大则需要上移
        SiftUp(H, i);
    } else {//否则进行下渗
        SiftDown(H, i, n);
    }
}
</code></pre><h3 id="删除最大值（deletemax）"><a href="#删除最大值（deletemax）" class="headerlink" title="删除最大值（deletemax）"></a>删除最大值（deletemax）</h3><h5 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h5><p>将堆H中的最大元素x删除并返回最大值。</p>
<h5 id="实现思路-4"><a href="#实现思路-4" class="headerlink" title="实现思路"></a>实现思路</h5><p>用堆中的最后一个元素H[n]替换需要删除的元素H[1]，然后堆的大小减一（n–），然后根据需要对H[1]进行上移或者下渗直到最后形成一个合格的堆。</p>
<h5 id="算法时间复杂度分析-2"><a href="#算法时间复杂度分析-2" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>一个大小为n的二叉堆其高度应该为（int）logn，所以从一个大小为n的堆中将一个元素删除所需的时间复杂度为 <strong>O（logn）</strong></p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><pre><code> int DeleteMax(int *H,int &amp;n){
    int x=H[1];
    Delete(H, 1, n);
    return x;
}
</code></pre><h3 id="创建堆（makeheap）"><a href="#创建堆（makeheap）" class="headerlink" title="创建堆（makeheap）"></a>创建堆（makeheap）</h3><h5 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h5><p>给出一个有n个元素的数组H[1….n]，创建一个包含这些元素的堆。</p>
<h5 id="实现思路-5"><a href="#实现思路-5" class="headerlink" title="实现思路"></a>实现思路</h5><p>类似于分治，首先，H的叶子节点（即最下面的一层单个元素）可以认为是若干个小堆，然后我们从倒数第二层开始，将倒数第二层和倒数第一层的元素进行适当调整，使得调整之后整个二叉完全树的最后两层是若干个子堆，按照这个思路，依次向上走，最终走到第1层的时候就可以保证整个完全二叉树是一个符合要求的堆。</p>
<p>需要注意的是对于一个完全二叉树， <strong>倒数第二层的最后一个元素的下标为int(n/2)</strong> ，（因为倒数第二层的最后一个节点的下标x应该满足x*2=n）.</p>
<h5 id="算法时间复杂度分析-3"><a href="#算法时间复杂度分析-3" class="headerlink" title="算法时间复杂度分析"></a>算法时间复杂度分析</h5><p>senta(n)</p>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><pre><code> void makeheap(int *H,int n){
    for (int i = n/2; i &gt;=1 ; --i) {//从倒数第二层到第一层
        SiftDown(H,i,n);
    }
}
</code></pre><h3 id="堆排序（heapsort）"><a href="#堆排序（heapsort）" class="headerlink" title="堆排序（heapsort）"></a>堆排序（heapsort）</h3><h5 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h5><p>利用堆对数组H[n]进行排序。</p>
<h5 id="实现思路-6"><a href="#实现思路-6" class="headerlink" title="实现思路"></a>实现思路</h5><p>首先将数组H[n]调整成为一个（大顶）堆，这时可以保证H[1]是数组中的最大元素，然后将H[1]与H[n]互换位置，然后再调整1——n-1为一个大顶堆，然后将H[1]与H[n-1]互换，以此类推，最后就可以保证H为一个非升序的数组。</p>
<h5 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h5><p>空间复杂度：因为本算法是在数组H原有的空间基础上进行排序的，所以空间复杂度是Senta（1）。<br>时间复杂度：</p>
<ul>
<li>建堆 senta(n) </li>
<li>执行n-1次siftdown nlog(n)<br>所以总的时间复杂度是nlog（n）</li>
</ul>
<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><pre><code>void HeapSort(int *H,int n){
    makeheap(H,n);
    int t;
    for (int i = n; i &gt;=2 ; --i) {
        t=H[i];
        H[i]=H[1];
        H[1]=t;
        SiftDown(H,1,i-1);
    }
}
</code></pre><h1 id="三：归纳法"><a href="#三：归纳法" class="headerlink" title="三：归纳法"></a>三：归纳法</h1><p>只调用一次的递归叫做尾递归</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>基数排序需要经历d次，d为所要排序数列中位数最多的数的位数，其过程是首先根据数列中数的个位的数值将所有数入0~9这10个队列，然后从0~9将元素依次出队，然后再根据十位元素的数值再次入队，然后出队，以此类推重复d次，最终即可完成排序。</p>
<h3 id="时间空间复杂度及稳定性"><a href="#时间空间复杂度及稳定性" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h3><ul>
<li>T(n)=O(d*n) d为排序数中最大数的位数 </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre><code>void radixSort(vector&lt;int&gt; v) {

    int d = GetMaxBit(v);

    int *count = new int[10];
    queue&lt;int&gt; q[10];

    int radix = 1;
    for (int i = 0; i &lt; d; ++i) {
        for (int j = 0; j &lt; v.size(); ++j) {
            int t;
            t = (v[j] / radix) % 10;
            q[t].push(v[j]);
        }

        int p = 0;
        for (int k = 0; k &lt; 10; ++k) {
            while (!q[k].empty()) {
                v[p++] = q[k].front();
                q[k].pop();
            }
        }
        radix *= 10;
    }
    show(v);

}
</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>对于任何的基数都可以归纳出算法，而不仅仅是以10做基数。比如可以把二进制的每四位作为一个数字，也就是用16作为基数，表的数目将和基数相等但是要保证从低位开始将数分配到表中。</p>
<h2 id="整数幂"><a href="#整数幂" class="headerlink" title="整数幂"></a>整数幂</h2><h3 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>很多时候我们需要求实数x的n次方即x^n，按照常规做法一般会对x进行n次自乘以得到x^n，但是这是非常低效的，因为它需要senta（n）次乘法，按照输入的大小来说它是指数级的。</p>
<h3 id="归纳法思路"><a href="#归纳法思路" class="headerlink" title="归纳法思路"></a>归纳法思路</h3><p>一个比较高效的归纳算法是令m=int(n/2)，假设已经知道如何计算x^m,那么根据x^m次方来计算x^n次方就有两种情况：</p>
<ul>
<li>n为偶数 则x^n=（x^m）^2 </li>
<li>n为奇数 则x^n=x(x^m)^2 </li>
</ul>
<h3 id="归纳法实现代码（Exprec）"><a href="#归纳法实现代码（Exprec）" class="headerlink" title="归纳法实现代码（Exprec）"></a>归纳法实现代码（Exprec）</h3><pre><code>int power(int x,int n){
    if (n==0){
        return 1;
    }

    int m=n/2;
    int y;
    y=power(x,n/2);
    y=y*y;
    if (n%2!=0){//如果n是奇数
        y=y*x;
    }

    return y;
}
</code></pre><h3 id="迭代法实现思路"><a href="#迭代法实现思路" class="headerlink" title="迭代法实现思路"></a>迭代法实现思路</h3><p>上述归纳法实现求x^n的关键部分在于采用递归不断判断n/2的奇偶性，所以我们可以采用迭代的办法，因为一个数除以2的k次方后的奇偶性由其化为二进制数的第k低位决定的（因为除法除以2就相当于二进制的左移操作），所以我们可以将n化为二进制数字d_k,d_(k-1)……d_0，从y=1开始，从左到右扫描二进制数字，如果当前二进制数字为0，则对应递归情况下的偶数情况即应该y=y^2，否则即为y=y(y^m)^2</p>
<h3 id="迭代法实现代码（Exp）"><a href="#迭代法实现代码（Exp）" class="headerlink" title="迭代法实现代码（Exp）"></a>迭代法实现代码（Exp）</h3><pre><code>int Exp(int x,int n){
    int d[10];//假设n化为2进制数字后存在d数组里面
    int y=1;
    for (int i = len(d); i &gt;=0 ; --i) {
        y=y*y;
        if(d[i]==1){
            y=y*x;
        }
    }
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>假设每次乘法的时间是常数，那么这两种方法所需的运行时间都是 <strong>senta(lohn)</strong> ，他们对于输入大小来说都是 <strong>线性</strong> 的。</p>
<h2 id="多项式求值（Horner规则）"><a href="#多项式求值（Horner规则）" class="headerlink" title="多项式求值（Horner规则）"></a>多项式求值（Horner规则）</h2><h3 id="场景介绍-1"><a href="#场景介绍-1" class="headerlink" title="场景介绍"></a>场景介绍</h3><p>假设有n+2个数a_0,a_1,……,a_n和x序列，要对多项式 <strong>P_n(x)=a_n<em>x^n+a_(n-1)</em>x^(n-1)+…+a_1*x</strong><br>求值，传统的办法是分别对每一个子项求值，然后再对整个式子求值，但是这种方法很低效，因为它需要n+（n-1）+（n-2）+…..+1=n(n+1)/2次乘法。</p>
<h3 id="归纳法解决思路"><a href="#归纳法解决思路" class="headerlink" title="归纳法解决思路"></a>归纳法解决思路</h3><p>首先我们发现原式可进行如下化简（这么丑的字不是我写的…）：<br><img src="https://img-
blog.csdn.net/20180429163357184?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>化简之后我们可以发现如果我们假设已知P_(n-1)(x)，那么P_n(x)=x*P_(n-1)(x)+a_0,所以就有了算法HORNER。</p>
<h3 id="HORNER算法代码实现"><a href="#HORNER算法代码实现" class="headerlink" title="HORNER算法代码实现"></a>HORNER算法代码实现</h3><pre><code>int Horner(int *A,int n,int x){//数组A的长度为n+2，从A[0]到A[n+1]代表了a_0到a_(n+1)

    int p=A[n+1];//p=a_(n+1)
    for (int i = 1; i &lt;=n ; ++i) {
        p=p*x+A[n+1-i];//p=p*x+a_(n-i)
    }

}
</code></pre><h2 id="寻找多数元素"><a href="#寻找多数元素" class="headerlink" title="寻找多数元素"></a>寻找多数元素</h2><h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>令A[1…n]是一个整数序列，如果该序列中的某一个数x在该序列中出现的次数多余int(n/2)，则称x为该序列的 <strong>多数元素</strong> 。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>蛮力法 将每个元素与其他因素进行比较，并且对每一个元素计数，如果某个元素的计数大于int(n/2)，就可以断言它是多数元素。但是这种方法的比较次数是n(n-1)/2=senta(n^2)，代价过于昂贵。 </li>
<li>利用排序 先将原序列进行排序，在最坏情况下，排序这一步需要Ω(nlogn)次比较。 </li>
<li>寻找中间元素 因为多数元素排序后一定是中间元素，可以找到该序列的中间元素后扫描整个序列该中间元素的出现次数来验证该元素是否为多数元素，由于中间元素可以在senta(n)时间内找到，这个方法要花费senta(n)时间。 </li>
<li>MAJORITY算法 首先我们需要知道，去掉一个序列中的两个不同的数后该序列原来的多数元素现在依然是新序列的多数元素，所以我们……我们能怎么样呢，这不好描述啊，还是看代码吧…… </li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>int majority(int *A, int n) {
    int c = candidate(A, 1, n);
    int count = 0;
    for (int i = 1; i &lt;= n; ++i) {
        if (A[i] == c) {
            count++;
        }
    }
    if (count &gt; (int) n / 2) {
        return c;
    } else {
        return NULL;
    }
}

int candidate(int *A, int m, int n) {//寻找A[m...n]中的多数元素
    int j = m;
    int c = A[m];
    int count = 1;
    while (j &lt; n &amp;&amp; count &gt; 0) {
        j++;
        if (A[j] == c) {
            count++;
        } else {
            count--;
        }
    }
    if (j == n) {
        return c;
    } else {
        return candidate(A, j + 1, n);
    }
}
</code></pre><h1 id="四：分治法"><a href="#四：分治法" class="headerlink" title="四：分治法"></a>四：分治法</h1><h2 id="什么是分治"><a href="#什么是分治" class="headerlink" title="什么是分治"></a>什么是分治</h2><p>一个分治算法把问题实例划分为若干个子问题（一般是两个），并分别使用递归解决每个子实例，然后把这些子实例的解组合起来，得到原问题的解。</p>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>考虑这样一个问题：我们需要在序列Ａ[1….n]中找到该序列的最大值元素和最小值元素，一种直接的算法是扫描一遍Ａ序列，用两个标志位max和min分别表示最大值和最小值元素，然后扫描时根据每个元素与当前最大最小值的比较情况动态调整最大最小值直至最后找到最大最小值，代码如下：</p>
<pre><code>void MaxMin(int *A,int n){
    int max,min;
    min=max=A[0];
    for (int i = 1; i &lt;n ; ++i) {
        if(A[i]&gt;max)max=A[i];
        if(A[i]&lt;min)min=A[i];
    }

    cout&lt;&lt;max&lt;&lt;min&lt;&lt;endl;
}
</code></pre><p>显然，此种方法的元素比较次数是２ｎ－２，但是利用分治策略就可以将元素比较次数减少到(３ｎ)/2-2，具体做法：将数组分割成两半，Ａ[1…n/2]和Ａ[n/2+1…n]，在每一半中分别找到最大值和最小值，并返回这两个最小值中的最小值、这两个最大值中的最大值作为最终的最小、最大值。对应伪代码如下：</p>
<pre><code>(max min) MaxMin2(int *A,int low,int high){
    if (high-low==1){
        if (A[low]&lt;A[high])return (A[low],A[high]);
        else return (A[high],A[low]);
    } else{
        int mid=(high+low)/2;
        (x1,y1)=MaxMin2(A,low,mid);
        (x2,y2)=MaxMin2(A,mid+1,high);
        x=min(x1,x2);
        y=max(y1,y2);

        return (x,y);
    }
}
</code></pre><p>按照上述算法，设Ａ[1…n]有ｎ个元素，ｎ为２的幂，则仅用３ｎ/2-2次元素比较就可以在数组Ａ中找出最大值和最小值。</p>
<h2 id="二分搜索-1"><a href="#二分搜索-1" class="headerlink" title="二分搜索"></a>二分搜索</h2><h3 id="分治（递归）实现"><a href="#分治（递归）实现" class="headerlink" title="分治（递归）实现"></a>分治（递归）实现</h3><p>原理比较简单，给出代码：</p>
<pre><code>int binarysearch(int *A, int low, int high, int x) {//A是已经排序过的数组,A[1....n]

    if (low &gt; high)return 0;
    int mid = (high + low) / 2;
    if (x == A[mid])return mid;
    if (x &lt; A[mid])return binarysearch(A, low, mid, x - 1);
    else return binarysearch(A, mid + 1, high, x);


}
</code></pre><p>算法BINARYSEARCHREC在ｎ个元素组成的数组中搜索某个元素所执行的比较次数不超过((int)logn)+1，时间复杂度是Ｏ(logn)。</p>
<h3 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h3><pre><code>int binarysearch(int *A, int n, int x) {//A是已经排序过的数组,A[1....n]

    int low, high, j;
    low =1;
    high = n;
    j = 0;//j表示ｘ的下标
    while (low &lt;= high &amp;&amp; j == 0) {
        int mid = (high + low) / 2;
        if (x == A[mid])  j = mid;
        else if (x &lt; A[mid])high = mid - 1;
        else low = mid + 1;
    }
    return j;
}
</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>递归和迭代实现二分搜索算法的元素比较次数都在int(logn)+１内，但是迭代算法只需要senta(１)的空间，而递归算法由于递归深度为Ｏ(logn)，每个递归层次需要senta(1)的空间，所以总的需要的空间总量是Ｏ(logn)。</p>
<h2 id="归并（合并）排序"><a href="#归并（合并）排序" class="headerlink" title="归并（合并）排序"></a>归并（合并）排序</h2><p>这里需要区分迭代式合并排序和递归式合并排序的区别：</p>
<ul>
<li><p>迭代式 自底向上<br><img src="/home/dmrf/图片/merge2.jpg" alt=""></p>
</li>
<li><p>递归式 自顶向下<br><img src="/home/dmrf/图片/merge1.jpg" alt=""></p>
</li>
</ul>
<h3 id="迭代式"><a href="#迭代式" class="headerlink" title="迭代式"></a>迭代式</h3><p>主要思路是将所要排序数列看做若干个有序的小数列，因为将两个有序数列合并之后所得数列还是有序数列，所以经过不断合并，最后可将数列排为有序。</p>
<h4 id="时间空间复杂度及稳定性-1"><a href="#时间空间复杂度及稳定性-1" class="headerlink" title="时间空间复杂度及稳定性"></a>时间空间复杂度及稳定性</h4><ul>
<li>T(n)=O(nlog2– &gt;n) </li>
<li>S(n)=O(n) </li>
<li>稳定 </li>
</ul>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><pre><code>void MSort(vector&lt;int&gt; v) {


    vector&lt;int&gt; h;
    h = v;

    int start, seg;


    for (seg = 1; seg &lt; v.size(); seg *= 2) {
        int k = 0;
        for (start = 0; start &lt; v.size(); start = start + seg * 2) {
            int end;
            end = start + seg;
            int low = start;
            while (low &lt; start + seg &amp;&amp; end &lt; start + seg + seg &amp;&amp; low &lt; v.size() &amp;&amp; end &lt; v.size()) {
                if (v[low] &lt;= v[end]) {
                    h[k++] = v[low];
                    low++;
                } else {
                    h[k++] = v[end];
                    end++;
                }
            }

            while (low &lt; start + seg &amp;&amp; low &lt; v.size()) {
                h[k++] = v[low++];
            }
            while (end &lt; start + seg + seg &amp;&amp; end &lt; v.size()) {
                h[k++] = v[end++];
            }

        }

        v = h;
    }
    show(v);

}
</code></pre><h3 id="递归式"><a href="#递归式" class="headerlink" title="递归式"></a>递归式</h3><p>主要思路是将待排序序列分成两个小部分，然后再对两个小部分运行相同的排序方法进行递归排序，最后将两个小部分合并起来。</p>
<h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><p>MergeSort（A,1,n）;</p>
<pre><code>void MergeSort(int *A, int low, int high) {
    if (low &lt; high) {
        int mid = (high + low) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, high, mid + 1);
        Merge(A, low, mid, high);
    }
}

void Merge(int *A, int low, int mid, int high) {
    int n = high - low;
    int B[high - low];
    int b = mid;
    int i;
    for (i = 0; i &lt; n &amp;&amp; low &lt; mid &amp;&amp; b &lt; high; ++i) {
        if (A[low] &lt; A[b]) {
            B[i] = A[low++];
        } else {
            B[i] = A[b++];
        }
    }

    for (int j = low; j &lt; mid; ++j) {
        B[i] = A[j];
    }
    for (int k = b; k &lt; high; ++k) {
        B[i] = A[k];
    }

    for (int l = low; l &lt;high ; ++l) {
        A[l]=B[i];
    }
}
</code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>算法MergeSort对一个n个元素的数组排序所需的时间是senta(nlogn)，空间是senta(n).</p>
<h2 id="寻找中项和第k小元素"><a href="#寻找中项和第k小元素" class="headerlink" title="寻找中项和第k小元素"></a>寻找中项和第k小元素</h2><h3 id="场景描述-1"><a href="#场景描述-1" class="headerlink" title="场景描述"></a>场景描述</h3><p>寻找序列A[1…n]中的第k小元素。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>传统的方法是直接将A[1…n]进行排序，然后取排序后的序列的第k个即为第k小元素，但是这种方法需要Ω(nlogn)的时间，因为任何基于比较的排序过程在最坏情况下必须花费这么多时间，所以我们选择一种新的算法：<br>我们要在n个元素中找到第k小元素的实质是寻找第k小元素在A中的位置，所以我们可以将A划分成三个子序列A1 A2<br>A3，其中A2为单个元素的序列，A1中的所有元素小于A2，A3中的所有元素大于A2，此时就有以下几种情况：</p>
<ul>
<li>如果A1的长度大于k则A序列中第K小元素一定在A1中，我们只需寻找A1中的第k小元素即可 </li>
<li>如果A1的长度等于k-1，则A2中的那个单元素就是我们要找的第k小元素 </li>
<li>如果A1的长度小于k-1，则我们需要在A3序列中找到第k-len(A1)-1小元素 </li>
</ul>
<p>这样，我们就可以采用分治的思想将原来的n个元素中寻找第k小元素不断缩小范围最终找到目标元素，具体算法步骤描述如下：</p>
<h4 id="SELECT-算法描述"><a href="#SELECT-算法描述" class="headerlink" title="SELECT 算法描述"></a>SELECT 算法描述</h4><ol>
<li>如果数组元素个数小于 44,则直接将数组排序并返回第 k小元素(采用直接的方法来解决问题,因为当总元素个数小于44*5=220的时候用直接的方法解决问题更快)。 </li>
<li>把 n 个元素以每组 5 个元素划分为 int( n/5) 组,如果 n 不是 5的倍数则抛弃剩余元素。 </li>
<li>对每组进行排序,之后取出每组的中间项(第 3 个元素)。 </li>
<li>递归调用 SELECT 算法,得到这些中间项序列中的中项元素 mm </li>
<li><p>根据 mm,将原数组 A 划分为三个子数组: </p>
<ul>
<li>A1={小于 mm 的元素}; </li>
<li>A2={等于 mm 的元素}; </li>
<li>A3={大于 mm 的元素}; </li>
</ul>
</li>
<li><p>根据 k 的大小,判断第 k 小元素会出现在 A1,A2,A3 中的<br>哪一个数组里,之后,或者返回第 k 小元素(mm,在 A2<br>中),或者在 A1 或 A3 上递归。</p>
<ul>
<li>k </li>
</ul>
</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>void sort(int *A, int low, int high) {
    for (int i = low; i &lt; high; ++i) {
        for (int j = i + 1; j &lt; high; ++j) {
            if (A[i] &gt; A[j]) {
                int t = A[i];
                A[i] = A[j];
                A[j] = t;
            }
        }
    }
}

int Select(int *A, int low, int high, int k) {
    int p = high - low + 1;
    if (p &lt; 44) {
        sort(A, low, high);
        return A[k];

    }
    int q = p / 5;
    int M[q];

    for (int i = 0; i &lt; q; ++i) {
        sort(A, i * 5, (i + 1) * 5);//将A分成q组，每组5个元素，如果5不整除p，则排除剩余元素
        M[i] = A[i * 5 + 3];//M为q个子序列中的中项（中项集合）
    }

    int mm = M[q / 2];//mm为中项集合的中项
    int *A1, a1 = 0;
    int *A2, a2 = 0;
    int *A3, a3 = 0;
    //这里节省空间没有new（其实是懒...）
    for (int j = low; j &lt; high; ++j) {
        if (A[j] &lt; mm)A1[a1++] = A[j];
        if (A[j] = mm)A2[a2++] = A[j];
        if (A[j] &gt; mm)A3[a3++] = A[j];
    }
    if (a1 &gt;= k)return Select(A1, 1, a1, k);
    if (a1 + a2 == k)return mm;
    if (a1 + a2 &lt; k)return Select(A3, 1, a3, k - a1 - a2);


}
</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>在一个由n个元素组成的线序集合中提取第k小元素，所需的时间是senta(n)(T(n)&lt;=20cn,c是排序43个元素所需的时间)，特别地，n个元素元素的中值可以在senta(n)时间找出。<br>需要注意的是，虽然此算法所需的时间是senta(n)但是其中的倍数常量（20c）还是太大，我们会在随讲机算法的时候提出一个具有较小倍数常量的算法。</p>
<h2 id="快速排序（QuickSort）"><a href="#快速排序（QuickSort）" class="headerlink" title="快速排序（QuickSort）"></a>快速排序（QuickSort）</h2><p>快速排序（QuickSort）是一种具有senta(nlogn)时间复杂度的排序算法，相比MergeSort，QuickSort不需要辅助的存储空间，这是它的优势。</p>
<h3 id="划分算法（Split）"><a href="#划分算法（Split）" class="headerlink" title="划分算法（Split）"></a>划分算法（Split）</h3><p>在进行快速排序算法的实现之前我们需要先实现划分算法，它是快速排序算法的基础。</p>
<h4 id="什么是划分算法"><a href="#什么是划分算法" class="headerlink" title="什么是划分算法"></a>什么是划分算法</h4><p>设A[low…high]是一个包含n个数的序列，设x=a[low],我们希望对A中的元素进行位置调整后实现当i&lt; new index of x时A[i]&lt;<br>x,当i&gt; new index of x时A[i]&gt;x。</p>
<h4 id="实现思路-7"><a href="#实现思路-7" class="headerlink" title="实现思路"></a>实现思路</h4><p>对一个指定序列A[low…high]，从A[low+1]开始向后扫描元素，如果当前元素a&lt;=A[low]，则将a与第A[i]的元素互换位置，其中i是从low开始的，每进行一次元素的互换之前i++，最后，当A中元素扫描完毕时所有小于等于A[low]的元素都在i之前的位置（包括A[i]），所以此时只需将A[low]和A[i]的元素互换位置即可满足划分的定义，此时的i对应的就是元素A[low]的新位置.</p>
<h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>int Split(int *A, int low, int high) {//输入一个序列，返回A[low]对应元素的新位置
    int i = low;
    int x = A[low];
    for (int j = low + 1; j &lt;= high; ++j) {
        if (A[j] &lt;= x) {
            i++;
            if (i != j) {
                int t = A[i];
                A[i] = A[j];
                A[j] = t;
            }
        }
    }

    int t;
    t = A[low];
    A[low] = A[i];
    A[i] = t;

    return i;
}
</code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为算法split的元素比较次数恰好是n-1，所以它的时间复杂性为senta(n).</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>算法QuickSort的主要思路是利用Split算法将A[low…high]中的A[low]排列到其正确的位置A[w]，然后对子数组A[low…w-1]和子数组A[w+1…high]递归地进行排序从而产生整个排序数组。</p>
<h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>void QuickSort(int *A, int low, int high) {
    if (low &lt; high) {
        int w = Split(A, low, high);//w为A[low]的新位置
        QuickSort(A, low, w - 1);
        QuickSort(A, w + 1, high);
    }
}
</code></pre><h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>算法QuickSort对n个元素的数组进行排序时执行的平均比较次数是senta(nlogn)</p>
<h1 id="五：动态规划"><a href="#五：动态规划" class="headerlink" title="五：动态规划"></a>五：动态规划</h1><h2 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。动态规划是一种被广泛用于求解组合最优化问题的算法。</p>
<h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>算法思想与分治法类似，也是 <strong>将待求解的问题分解为若干个子问题</strong> （阶段），按顺序求解子阶段，<br><strong>前一子问题的解，为后一子问题的求解提供了有用的信息</strong><br>。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。<br>由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p>
<h4 id="与分治法的差别"><a href="#与分治法的差别" class="headerlink" title="与分治法的差别"></a>与分治法的差别</h4><p>适合于用动态规划法求解的问题，经分解后得到的子问题往往 <strong>不是互相独立</strong> 的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<h4 id="适用的情况"><a href="#适用的情况" class="headerlink" title="适用的情况"></a>适用的情况</h4><p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<ul>
<li><p>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。 </p>
</li>
<li><p>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。 </p>
</li>
<li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（ <strong>该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势</strong> ） </p>
</li>
</ul>
<h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定两个长度为n和m的字符串A和B，确定A和B中最长公共子序列的长度。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul>
<li><p>传统算法 一种传统的方式是使用蛮力搜索的方法，列举A所有的2^n个子序列对于每一个子序列子在senta(m)时间内来确定它是否也是B的子序列。该算法的时间复杂性是senta(m2^n)，是指数复杂性的。 </p>
</li>
<li><p>动态规划算法 寻找一个求最长公共子序列的递推公式，令A=a_1a_2a_3….a_n和B=b_1b_2b_3…b_m，令L[i,j]表示a_1a_2_3…a_i和b_1b_2b_3…b_j的最长公共子序列的长度，则就有当i和j都大于0的时候，如果a_i=b_j，则L[i,j]=L[i-1,j-1]+1，反之，如果a_i!=b_j，则L[i,j]=max(L[i-1,j],L[i,j-1])所以就有以下递推公式： </p>
</li>
</ul>
<pre><code>L [i,j]=0 i==0||j==0

L[i,j]=L[i-1,j-1]+1 i,j&gt;0&amp;&amp;a_i==b_j

L[i,j]=max(L[i-1,j],L[i,j-1]) i,j&gt;0&amp;&amp;a_i=b_j
</code></pre><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><p>输入A和B字符串，返回二者的最长子序列长度</p>
<pre><code>int Lcs(char *A, int n, char *B, int m) {//A[0...n] B[0...m]
    int L[n + 1][m + 1];
    for (int i = 0; i &lt;= n; ++i) {
        L[i][0] = 0;
    }
    for (int j = 0; j &lt;= m; ++j) {
        L[0][j] = 0;
    }

    for (int k = 1; k &lt;= n; ++k) {
        for (int i = 1; i &lt;= m; ++i) {
            if (A[k] == B[i])L[k][i] = L[k - 1][i - 1] + 1;
            else L[k][i] = L[k][i - 1] &gt; L[k - 1][i] ? L[k][i - 1] : L[k - 1][i];
        }
    }

    return L[n][m];
}
</code></pre><p>注意，以上算法需要的空间复杂度是senta(mn)，但是因为计算表中每一项的计算仅仅需要其上一行和上一列的元素，所以对算法进行改进可以使得空间复杂度降为senta(min(m,n))<br>（准确来说是需要2min(m,n)的空间，仅仅将前一行和当前行存储下来即可）。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>最长公共子序列问题的最优解能够在senta(mn)时间和senta(min(m,n))空间内计算得到。</p>
<h2 id="矩阵链相乘"><a href="#矩阵链相乘" class="headerlink" title="矩阵链相乘"></a>矩阵链相乘</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个n个矩阵的序列⟨A1,A2,A3…An⟩,我们要计算他们的乘积：A1A2A3…AnA1A2A3…An，由于矩阵乘法满足结合律，加括号不会影响结果，但是不同的加括号方法，算法复杂度有很大的差别：<br>考虑矩阵链⟨A1,A2,A3⟩，三个矩阵规模分别为10×100、100×5、5×50：</p>
<ul>
<li>按((A1A2)A3)方式，需要做10∗100∗5=5000次，再与A3相乘，又需要10∗5∗50=2500，共需要7500次运算； </li>
<li>按(A1（A2A3）)方式计算，共需要100∗5∗50+10∗100∗50=75000次标量乘法 </li>
</ul>
<p>以上两种不同的加括号方式具有10倍的差别，可见一个好的加括号方式，对计算效率有很大影响。</p>
<h3 id="解决思路-1"><a href="#解决思路-1" class="headerlink" title="解决思路"></a>解决思路</h3><p>使用一个长度为n+1的一维数组p来记录每个矩阵的规模，其中n为矩阵下标，i的范围1~n，例如对于矩阵Ai而言，它的规模应该是p[i-1]×p[i]。由于i是从1到n取值，所以数组p的下标是从0到n。</p>
<p>用于存储最少乘法执行次数和最佳分段方式的结构是两个二维数组m和s，都是从1~n取值。m[i][j]记录矩阵链&lt; Ai,Ai+1,…,Aj&gt;的<br><strong>最少乘法执行次数</strong> ，而s[i][j]则记录 最优质m[i][j]的分割点k。</p>
<p>需要注意的一点是当i=j时，m[i][j]=m[i][i]=0，因为一个矩阵不需要任何乘法。</p>
<p>假设矩阵链从Ai到Aj，有j-i+1个矩阵，我们从k处分开，将矩阵链分为Ai~Ak和Ak+1到Aj两块，那么我们可以比较容易的给出m[i][j]从k处分隔的公式：</p>
<pre><code>m[i][j]=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]；
</code></pre><p>在一组确定的i和j值的情况下，要使m[i][j]的值最小，我们只要在所有的k取值中（i &lt;=k&lt; j)，寻找一个让m[i][j]最小的值即可。</p>
<p>假设L为矩阵链的长度，那么L=j-i+1。当L=1时，只有一个矩阵，不需要计算。那么我们可以从L=2到n进行循环，对每个合理的i和j值的组合，遍历所有k值对应的m[i][j]值，将最小的一个记录下来，存储到m[i][j]中，并将对应的k存储到s[i][j]中，就得到了我们想要的结果。</p>
<h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre><code>/*
 * 输入：ms[1...n+1],ms[i]表示第i个矩阵的行数，ms[i+1]表示第i个矩阵的列数
 * 输出：n个矩阵的数量乘法的最小次数
 */

int dp[1024][1024] = { 0 };

struct Matrix {
    int row;
    int column;
};

int matrixChainCost(Matrix *ms, int n) {
    for (int scale = 2; scale &lt;= n; scale++) {
        for (int i = 0; i &lt;= n - scale; i++) {
            int j = i + scale - 1;
            dp[i][j] = INT_MAX;
            for (int k = i; k &lt; j; k++) {
                dp[i][j] = std::min(dp[i][j], dp[i][k] + dp[k+1][j] + (ms[i].row*ms[k].column*ms[j].column));
            }
        }
    }
    return dp[0][n - 1];
}
</code></pre><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：senta(n^3) </li>
<li>空间复杂度：senta(n^2) </li>
</ul>
<h2 id="所有点对的最短路径问题"><a href="#所有点对的最短路径问题" class="headerlink" title="所有点对的最短路径问题"></a>所有点对的最短路径问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>设G是一个有向图，其中每条边(i, j)都有一个非负的长度L[i, j]，若点i 到点j 没有边相连，则设L[i, j] = ∞.<br>找出每个顶点到其他所有顶点的最短路径所对应的长度。<br>例如：<br><img src="https://img-
blog.csdn.net/20180508082542596?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>则 L： 0 2 9</p>
<p>8 0 6</p>
<p>1 ∞ 0</p>
<h3 id="解决思路（Floyd算法）"><a href="#解决思路（Floyd算法）" class="headerlink" title="解决思路（Floyd算法）"></a>解决思路（Floyd算法）</h3><p>Floyd算法（所有点对最短路径）就是每对可以联通的顶点之间总存在一个借助于其他顶点作为媒介而达到路径最短的最短路径值（这个值通过不断增添的媒介顶点而得到更新，也可能不更新——通过媒介的路径并不比其原路径更短），所有的值存储于邻接矩阵中，这是典型的动态规划思想。</p>
<p>值得注意的是，Floyd算法本次的状态的获取 <strong>只用到了上个阶段的状态</strong> ，而没有用到其他阶段的状态，这就为 <strong>压缩空间</strong> 奠定了条件。</p>
<p>Floyd算法能够成功的关键之一就是D0(初始矩阵，即权重矩阵)的初始化，凡是不相连接的边必须其dij必须等于正无穷且dii=0(矩阵对角线上的元素！)</p>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code> /*
 * 输入：n×n维矩阵l[1...n,1...n]，对于有向图G=({1,2,...n},E)中的边(i,j)的长度为l[i,j]
 * 输出：矩阵D，使得D[i,j]等于i到j的距离
 * l矩阵需要满足：l[i,i]=0，对于m--&gt;n没有直接连接的有向边（因为是有向图，只考虑单边），应有l[m,n]=INT.MAX（即无穷）
 *
 */

void Floyd(int **l,int n){
    int **d= reinterpret_cast&lt;int **&gt;(new int[n + 1][n + 1]);
    for (int i = 1; i &lt;=n ; ++i) {
        for (int j = 1; j &lt;=n ; ++j) {
            d[i][j]=l[i][j];
        }
    }

    for (int k = 1; k &lt;=n ; ++k) {
        for (int i = 1; i &lt;=n ; ++i) {
            for (int j = 1; j &lt;=n ; ++j) {
                d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
            }

        }
    }

}
</code></pre><h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>算法的运行时间是senta(n^3)<br>算法的空间复杂性是senta(n^2)</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>设U={u1,u2,u3…un}是一个准备放入容量为C的背包中的n项物品的集合。我们要做的是从U中拿出若干物品装入背包C，要求这些物品的总体积不超过C，但是要求装入背包的物品总价值最大。</p>
<h3 id="解决思路-2"><a href="#解决思路-2" class="headerlink" title="解决思路"></a>解决思路</h3><p>有 n 种物品，物品 i 的体积为 v[i], 价值为 p[i]. 假定所有物品的体积和价格都大于 0, 以及背包的体积为 V.<br>mp[x][y] 表示体积不超过 y 且可选前 x 种物品的情况下的最大总价值<br>那么原问题可表示为 mp[n][V]。<br>递归关系：</p>
<table>
<thead>
<tr>
<th>递归式</th>
<th>解释  </th>
</tr>
</thead>
<tbody>
<tr>
<td>mp[0][y] = 0</td>
<td>表示体积不超过 y 且可选前 0 种物品的情况下的最大总价值，没有物品可选，所以总价值为 0  </td>
</tr>
<tr>
<td>mp[x][0] = 0</td>
<td>表示体积不超过 0 且可选前 x 种物品的情况下的最大总价值，没有物品可选，所以总价值为 0  </td>
</tr>
<tr>
<td>当 v[x] &gt; y 时，mp[x][y] = mp[x-1][y]</td>
<td>因为 x 这件物品的体积已经超过所能允许的最大体积了，所以肯定不能放这件物品，</td>
</tr>
</tbody>
</table>
<p>那么只能在前 x-1 件物品里选了<br>当 v[x] &lt;= y 时，mp[x][y] = max{ mp[x-1][y] , p[x] +<br>mp[x-1][y-v[x]]（选中A，则其余y-v[x]应在前x-1件物品中选） }  |  x<br>这件物品可能放入背包也可能不放入背包，所以取前两者的最大值就好了， 这样就将前两种情况都包括进来了  </p>
<h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre><code>/*
 * 输入：物品集合U={u1,u2,u3...un}，体积为s1,s2,s3...sn，价值为v1,v2,v3...vn，容量为C的背包
 * 输出：满足条件的最大价值
 *
 */
int Knapsack(int *s,int *v,int C,int n){
    int V[n+1][C+1];//V[i][j]表示从前i项找出的装入体积为j背包的最大值
    for (int i = 0; i &lt;=n ; ++i) {
        V[i][0]=0;
    }
    for (int j = 0; j &lt;=C ; ++j) {
        V[0][j]=0;
    }

    for (int k = 1; k &lt;=n ; ++k) {
        for (int i = 1; i &lt;=C ; ++i) {
            if(s[k]&lt;=i){
                V[k][i]=max(V[k-1][i],V[k-1][i-s[k]]+v[k]);
            }
        }
    }

    return V[n][C];
}
</code></pre><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>背包问题的最优解可以在senta(nC)时间内和senta(C)空间内解得。<br>注意，上述算法的时间复杂性对输入不是多项式的，但是它的运行时间关于输入值是多项式的（时间复杂性+其他耗费时间），故认为它是伪多项式时间算法。</p>
<h1 id="六：贪心算法"><a href="#六：贪心算法" class="headerlink" title="六：贪心算法"></a>六：贪心算法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说， <strong>不从整体最优上加以考虑</strong> ，他所做出的仅是在某种意义上的<br><strong>局部最优解</strong> 。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备 <strong>无后效性</strong><br>，即 <strong>某个状态以后的过程不会影响以前的状态，只与当前状态有关</strong> 。<br>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个有向图G=(V,E),s为V中一点,以s为起点,要确定从s出发到V中每一个其他顶点的距离(距离的定义是最短路径对应的长度).</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li><p>初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则  &lt; u,v &gt;正常有权值，若u不是v的出边邻接点，则 &lt; u,v &gt; 权值为∞ </p>
</li>
<li><p>从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度） </p>
</li>
<li><p>以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权 </p>
</li>
<li><p>重复步骤b和c直到所有顶点都包含在S中 </p>
</li>
</ul>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><pre><code>const int  MAXINT = 32767;
const int MAXNUM = 10;
int dist[MAXNUM];//表示距离
int prev[MAXNUM];//记录每个顶点的前驱顶点(因为最短路径的唯一性,所以每个点的前驱元素都是唯一的)

int A[MAXUNM][MAXNUM];

void Dijkstra(int v0)
{
  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中
      int n=MAXNUM;
  　　for(int i=1; i&lt;=n; ++i)//初始化dist[]、prev[]
 　　 {
      　　dist[i] = A[v0][i];
      　　S[i] = false;                                // 初始都未用过该点
      　　if(dist[i] == MAXINT)   //如果该点与源点之间无边 
            　　prev[i] = -1;
 　　     else 
            　　prev[i] = v0;
   　　}
   　 dist[v0] = 0;
   　 S[v0] = true; 　　
 　　 for(int i=2; i&lt;=n; i++)
 　　 {
       　　int mindist = MAXINT;
       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值
      　　 for(int j=1; j&lt;=n; ++j)
      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)//如果j点没有被用过而且dist[j]小于mindist
      　　    {
         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码 
         　 　      mindist = dist[j];
       　　   }
       　　S[u] = true; //将u置为已用
       　　for(int j=1; j&lt;=n; j++)//更新u加入已用集合后的未用顶点集合中点到已用集合中点的距离
       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)
       　　    {
           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径  
           　    　{
                   　　dist[j] = dist[u] + A[u][j];    //更新dist 
                   　　prev[j] = u;                    //记录前驱顶点 
            　　    }
        　    　}
   　　}
}
</code></pre><h4 id="算法复杂度-1"><a href="#算法复杂度-1" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p>算法的时间复杂度是senta(n^2)</p>
<h3 id="稠图的线性时间算法"><a href="#稠图的线性时间算法" class="headerlink" title="稠图的线性时间算法"></a>稠图的线性时间算法</h3><p>稠(臭)图不想看，也许不考…</p>
<h2 id="最小耗费生成树"><a href="#最小耗费生成树" class="headerlink" title="最小耗费生成树"></a>最小耗费生成树</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>设G =<br>(V,E)是无向连通带权图，即一个网络。E中的每一条边（v,w）的权为c[v][w]。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树上各边权的总和称为生成树的耗费。在G的所有生成树中，耗费最小的生成树称为G的最小生成树。<br>最小生成树最常见的题就是求解n个城市之间的修路方案问题.</p>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h5 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h5><p>给定无向连通带权图G = (V,E),V = {1,2,…,n}。Kruskal算法构造G的最小生成树的基本思想是：</p>
<ul>
<li><p>将G的n个顶点看成n个孤立的连通分支,将所有的边按权从小大排序。 </p>
</li>
<li><p>从第一条边开始，依边权递增的顺序检查每一条边。并按照下述方法连接两个不同的连通分支：当查看到第k条边(v,w)时，如果端点v和w分别是当前两个不同的连通分支T1和T2的端点时，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看第k+1条边；如果端点v和w在当前的同一个连通分支中，就直接再查看k+1条边。这个过程一个进行到只剩下一个连通分支时为止。 </p>
</li>
</ul>
<p>此时，已构成G的一棵最小生成树。</p>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;

#define maxn 110    //最多点个数
int n, m;   //点个数，边数
int parent[maxn];   //父亲节点，当值为-1时表示根节点
int ans;    //存放最小生成树权值
struct eage     //边的结构体，u、v为两端点，w为边权值
{
    int u, v, w;
}EG[5010];

bool cmp(eage a, eage b)    //排序调用
{
    return a.w &lt; b.w;
}

int Find(int x)     //寻找根节点，判断是否在同一棵树中的依据
{
    if(parent[x] == -1) return x;
    return Find(parent[x]);
}

void Kruskal()      //Kruskal算法，parent能够还原一棵生成树，或者森林
{
    memset(parent, -1, sizeof(parent));
    sort(EG+1, EG+m+1, cmp);    //按权值将边从小到大排序
    ans = 0;
    for(int i = 1; i &lt;= m; i++)     //按权值从小到大选择边
    {
        int t1 = Find(EG[i].u), t2 = Find(EG[i].v);
        if(t1 != t2)    //若不在同一棵树种则选择该边，合并两棵树
        {
            ans += EG[i].w;
            parent[t1] = t2;
        }
    }
}
</code></pre><h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>当图的边数为e时，Kruskal算法所需的时间是O(eloge).</p>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>设G = (V,E)是连通带权图，V = {1,2,…,n}。构造G的最小生成树,Prim算法的基本思想是：首先置S =<br>{1}，然后，只要S是V的真子集，就进行如下的贪心选择：选取满足条件i ∈S,j ∈V –<br>S,且c[i][j]最小的边，将顶点j添加到S中。这个过程一直进行到S = V时为止。在这个过程中选取到的所有边恰好构成G的一棵最小生成树。</p>
<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>/* Prim算法生成最小生成树  */
void MiniSpanTree_Prim(MGraph MG)
{
    int min, i, j, k;
    int adjvex[MAXVEX];/* 保存相关顶点的父亲节点 */
    int lowcost[MAXVEX];/* 保存相关顶点间边的权值 */
    lowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */
    /* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */
    adjvex[0] = 0;/* 初始化第一个顶点下标为0 */
    cout &lt;&lt; &quot;最小生成树的边为：&quot; &lt;&lt; endl;
    for (i = 1; i &lt; MG.numVertexes; i++)
    {
        lowcost[i] = MG.arc[0][i];/* 将v0顶点与之有边的权值存入数组 */
        adjvex[i] = 0;/* 初始化都为v0的下标 */
    }

    for (i = 1; i &lt; MG.numVertexes; i++)
    {
        min = INFINITY; /* 初始化最小权值为∞， */

        j = 1;
        k = 0;

        while (j &lt; MG.numVertexes)/* 循环全部顶点 */
        {
            if (lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min)/* 如果权值不为0且权值小于min */
            {
                min = lowcost[j];/* 则让当前权值成为最小值 */
                k = j;/* 将当前最小值的下标存入k */
            }

            j++;
        }

        cout &lt;&lt; &quot;(&quot; &lt;&lt; adjvex[k] &lt;&lt; &quot;, &quot; &lt;&lt; k &lt;&lt; &quot;)&quot; &lt;&lt; &quot;  &quot;; /* 打印当前顶点边中权值最小的边 */
        lowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */

        for (j = 1; j &lt; MG.numVertexes; j++)/* 循环所有顶点 */
        {
            /* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */
            if (lowcost[j] != 0 &amp;&amp; MG.arc[k][j] &lt; lowcost[j])
            {
                lowcost[j] = MG.arc[k][j];/* 将较小的权值存入lowcost相应位置 */
                adjvex[j] = k;/* 将k设为下标j的父亲节点 */
            }
        }
    }
    cout &lt;&lt; endl;
}
</code></pre><h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>此算法的时间复杂度为O(n^2)</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>（这个写的我也看不懂了…应该是当时笔误，具体想表达什么意思猜猜吧）<br>当e = Ω(n^2)时，Kruskal算法比Prim算法差；<br>但当e = o(n^2)时，Kruskal算法比Prim算法好得多。</p>
<h1 id="七：NP完全问题"><a href="#七：NP完全问题" class="headerlink" title="七：NP完全问题"></a>七：NP完全问题</h1><p>如果一个算法的最差时间效率属于 O ( p ( n )) ,其中 p (n ) 是问题输入规模 n 的一个多项式函数,我们说该算法能<br><strong>够在多项式的时间内对问题求解</strong> 。<br>我们把可以在多项式时间内求解的问题称为 <strong>易解的</strong> ,而不能在多项式时间内求解的问题则称为 <strong>难解的</strong> 。</p>
<h2 id="P和NP问题"><a href="#P和NP问题" class="headerlink" title="P和NP问题"></a>P和NP问题</h2><p>非正式地说，我们可以把那些 <strong>能够在多项式时间内求解</strong> 的问题当作计算机科学家所说的 <em><em> P 集合</em></em> 。<br>正式点，只有那些 <strong>能够回答是或否</strong> 的问题（又称判定问题）才属于 P。</p>
<h3 id="P-类问题"><a href="#P-类问题" class="headerlink" title="P 类问题"></a>P 类问题</h3><p>P 类问题是一类能够用 <strong>确定性算法在多项式时间内求解</strong> 的 <strong>判定问题</strong> 。<br>这种问题类型也称为 <strong>多项式类型</strong> 。</p>
<p>绝大多数判定问题的一个公共特性是:</p>
<blockquote>
<p>虽然在计算上对问题求解可能是困难的,但在计算上 <strong>判定一个待定解是否解决了该问题</strong> 却是简单的,并且,这种判定可以在多项式时间内完成。</p>
</blockquote>
<p>一个不确定算法是一个两阶段的过程,它把一个判定问题的实例 l 作为它的输入,并进行下面的操作:</p>
<ul>
<li>猜测(非确定)阶段:   </li>
</ul>
<blockquote>
<p>生成一个任意串 S,把它当作给定实例 l 的一个候选解,但 S也可能是完全不着边际的。</p>
</blockquote>
<ul>
<li>验证(确定)阶段:<br>确定算法把 l 和 S 都作为它的输入,如果 S 的确是 l 的一个解的话,就输出“是”;<br>如果 S 不是 l 的一个解,该算法要么返回“否”,要么就根本停不下来。</li>
</ul>
<p>如果一个不确定算法在验证阶段的时间效率是多项式级的,我们说它是 <strong>不确定多项式类型</strong> 的算法。 <strong>NP 类问题</strong>(Non-deterministic<br>Polynomial)是一类可以用不确定多项式算法求解的判定问题。我们把这种问题类型称为不确定多项式类。 我们说一个判定问题 D 1<br>可以多项式地化简为一个判定问题 D 2 ,条件是存在一个函数 t 能够把 D 1 的实例转化为D 2 的实例,使得:</p>
<ul>
<li>t 把 D 1 的所有真实例映射为 D 2 的真实例,把 D 1 的所有假实例映射为 D 2 的假实例。 </li>
<li>t 可以用一个多项式算法计算。 </li>
</ul>
<p>我们说一个判定问题 D 是 NP 完全问题,条件是:</p>
<ul>
<li>它属于 NP 类型。 </li>
<li>NP 中的任何问题都能够在多项式时间内化简为 D。 </li>
</ul>
<p>NP 完全问题:</p>
<blockquote>
<p>合取范式的可满足性问题<br> 哈密顿回路问题<br> 旅行商问题</p>
</blockquote>
<p>NP 完全问题的定义意味着,如果我们得到了一个 NP 完全问题的多项式确定算法,就说明所有的 NP 问题都能够用一个确定算法在多项式的时间内解出,因此,P<br>= NP.换句话说,得到了一个 NP<br>完全问题的多项式确定性算法可以表明,对于所有类型的判定问题来说,检验待定解和在多项式时间内求解在复杂性上没有本质的差别。<br>这种推论使得大多数计算机科学家相信 P ≠ NP但是,到目前为止,还没有人能从数学上证明这一猜想。</p>
<h1 id="八：回溯算法"><a href="#八：回溯算法" class="headerlink" title="八：回溯算法"></a>八：回溯算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>回溯算法是一种组织搜索的一般技术，它常常可以避免搜索所有的可能性，适用于求解那些有潜在的大量解但是有限个数的解已经检查过的问题。</p>
<h2 id="3着色问题"><a href="#3着色问题" class="headerlink" title="3着色问题"></a>3着色问题</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出一个无向图G=(V,E)，需要用三种颜色之一为V中的每个顶点着色，要求没有两个相邻的顶点有相同的颜色。</p>
<h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>我们称没有两个邻接顶点有同样颜色的着色方案为合法的，反之成为非法的。如果不考虑合法性的要求，给出n个顶点的无向图，将其用三种颜色着色，共有n^3种不同的方法，因为每一个顶点都有三种不同的着色方案，这就构成了一颗三叉树，如图：<br><img src="https://img-
blog.csdn.net/20180505141608137?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>在该三叉树中，从根到叶子节点的每一条路径代表一种着色方法（合法的和不合法的），我们需要做的就是选出一条合法的从根到叶子的路径即可。所以我们从根节点开始向叶子节点走，这时有两种情况：</p>
<ul>
<li><p>从根到当前节点的路径对应一个合法的着色： </p>
<ul>
<li>当前路径长度等于n：过程终止（除非希望找到不止一种着色方案） </li>
<li>当前路径长度小于n：生成当前节点的一个子节点，并将生成的当前节点的子节点标记为新的当前节点 </li>
</ul>
</li>
<li>从根到当前节点的路径对应一个非法的着色：回溯到当前节点的父节点即将当前节点的父节点标记为新的当前节点 </li>
</ul>
<h3 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h3><p>使用数组c[1…n]代表图的顶点集合，判断合法性只需判断与当前有联系的点中是否存在与之涂色相同的点即可，此处为节省时间省略该部分代码的实现。</p>
<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><pre><code> void ColorItre(int *c) {//c[1...n]
    for (int i = 1; i &lt;= n; ++i) {
        c[i] = 0;
    }
    bool flag = false;
    int k = 1;
    while (k &gt;= 1) {
        while (c[k] &lt;= 2) {//从0-2对应三种涂色（实际上是 下面加一之后的1-3对应三种不同颜色）
            c[k] = c[k] + 1;
            if (c[k]为合法的){
                if (k == n) {//如果k已经是最后一个点
                    flag = true;
                    break;
                } else {
                    k++;
                }

            }
        }

        if (flag) {
            break;
        }

        //如果第二个循环跳出执行到这里，则说明当前节点k试遍了三种颜色仍然没有找到合法的着色，则将k--进行回溯，注意要将c[k]置为初始值0
        c[k] = 0;
        k--;
    }

    if (flag) {
        cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl;
    }

}
</code></pre><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><pre><code>void ColorRec(int *c) {//c[1...n]
    for (int i = 1; i &lt;= n; ++i) {
        c[i] = 0;
    }

    bool flag = false;
    flag = graphcolor(c, 1);
    if (flag) {
        cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl;
    }
}

bool graphcolor(int *c, int i) {
    for (int color = 1; color &lt;= 3; ++color) {
        c[i] = color;
        if (c[i]是合法的){
            if (i &lt; n) {
                graphcolor(c, i + 1);
            } else {
                return true;
            }
        }
    }
    //如果执行到这里说明当前节点不存在合法着色，需要回溯，返回false即可激活前一次递归（即让前一层for循环的color加一），以此达到回溯的目的
    return false;
}
</code></pre><h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>这两种实现方式在最坏情况下生成了O(3^n)个节点，对于每个生成的节点，判断当前节点的合法性（合法、部分、二者都不是）需要O(n)的工作来检查，因此，最坏情况下的运行时间是O(n3^n)。</p>
<h3 id="回溯法的特点"><a href="#回溯法的特点" class="headerlink" title="回溯法的特点"></a>回溯法的特点</h3><ul>
<li>节点是使用深度优先搜索算法生成的 </li>
<li>不需要存储整棵搜索树，只需存储根到当前活动节点的路径 </li>
</ul>
<h2 id="8皇后问题"><a href="#8皇后问题" class="headerlink" title="8皇后问题"></a>8皇后问题</h2><p>代码见 <a href="https://blog.csdn.net/qq_36982160/article/details/78585680" target="_blank" rel="noopener"> 两种不同方式解决八皇后问题
</a> ，此处主要介绍算法思路。</p>
<h3 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h3><p>八皇后问题是一个以国际象棋为背景的问题：如何能够在 8×8<br>的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当<br>n = 1 或 n ≥ 4 时问题有解。</p>
<h3 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h3><p>代码和着色问题代码几乎一样，这里不做过多介绍，给出参考代码：</p>
<pre><code>void eight_Queens() {
    int c[9];
    for (int i = 1; i &lt;= 8; ++i) {
        c[i] = 0;
    }

    bool flag = false;
    int k = 1;
    while (k &gt;= 1) {
        while (c[k] &lt;= 7) {
            c[k]++;
            if (c[k]为合法着色){
                if (k == 8) {
                    flag = true;
                    break;
                } else {
                    k++;
                }
            }
        }
        if (flag) {
            break;
        }
        c[k] = 0;
        k--;
    }

    if (flag) {
        cout &lt;&lt; &quot;success&quot; &lt;&lt; endl;
    } else {
        cout &lt;&lt; &quot;no solution&quot; &lt;&lt; endl;
    }
}
</code></pre><h3 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>回溯法在最坏情况下需要O（n^2）的运行时间。<br>但是需要注意，虽然蛮力搜索法的最坏情况也需要<br>O（n^2）的时间，但是根据经验回溯法的有效性远远超过蛮力法。(鬼知道这是谁的经验，反正只要知道考试用蛮力法肯定会xx)</p>
<h2 id="一般回溯方法"><a href="#一般回溯方法" class="headerlink" title="一般回溯方法"></a>一般回溯方法</h2><h3 id="什么是一般回溯法"><a href="#什么是一般回溯法" class="headerlink" title="什么是一般回溯法"></a>什么是一般回溯法</h3><p>在回溯法中，解向量中每个xi都属于一个有限的线序集Xi，因此，算法最初从空向量开始，然后选择X1中最小的元素作为x1，如果（x1）是一个部分解，算法从X2中找出最小的元素作为x2继续，如果（x1，x2）是一个部分解，则从X3中找出最小元素作为x3，否则跳过x2寻找下一个。一般地，假如算法已经找到部分解（x1,x2,x3…,xj），在判断v=（x1,x2,x3…,xj,x_j+1）时有以下情况：</p>
<ul>
<li>v是最终解：记录下当前v作为一组解，如果只想求得一组解则算法结束，否则继续寻找其他解 </li>
<li>v是一组部分解：从X_j+2中寻找新的最小元素继续向前走 </li>
<li><p>v既不是最终解也不是部分解：   </p>
<ul>
<li>X_j+1中还有其他元素可供选择：在X_j+1中寻找下一个元素 </li>
<li>X_j+1中没有其他元素可供选择：将x_j置为X_j中的下一个元素回溯，如果X_j中仍然没有其他元素可供选择，则照此方法继续向前回溯。 </li>
</ul>
</li>
</ul>
<h2 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>分支限界法（branch and bound method）是求解 <strong>纯整数规划</strong> 或 <strong>混合整数规划</strong> 问题的经典方法，在上世纪六十年代由Land<br>Doig和Dakin等人提出。这种方法灵活且便于用计算机求解，目前已经成功运用于求解生产进度问题、旅行推销员问题、工厂选址问题、背包问题及分配问题等。算法基本思想如下：</p>
<ul>
<li>按宽度优先策略遍历解空间树； </li>
<li>在遍历过程中，对处理的每个结点vi，根据界限函数，估计沿该结点向下搜索所可能达到的完全解的目标函数的可能取值范围—界限bound(vi)=[downi, upi]； </li>
<li>从中选择使目标函数取的极值(最大、最小)的结点优先进行宽度优先搜索，从而不断调整搜索方向，尽快找到问题解。 </li>
</ul>
<p>各结点的界限函数bound(vi)=[downi,<br>upi]是解决问题的关键，通常依据具体问题而定。常见的两种分支限界法是队列式分支限界法和优先队列式分支限界法，它们分别按照队列先进先出的原则和优先队列中规定的优先级选取下一个节点为扩展节点。</p>
<h3 id="分支限界法与回溯法的区别"><a href="#分支限界法与回溯法的区别" class="headerlink" title="分支限界法与回溯法的区别"></a>分支限界法与回溯法的区别</h3><h4 id="求解目标不同"><a href="#求解目标不同" class="headerlink" title="求解目标不同"></a>求解目标不同</h4><ul>
<li><p>回溯法的求解目标是找出解空间树中满足约束条件的 <strong>所有解</strong></p>
</li>
<li><p>分支限界法的求解目标则是尽快找出满足约束条件的 <strong>一个解</strong> ，或是在满足约束条件的解中找出在某种意义下的 <strong>最优解</strong></p>
</li>
<li><p>分支限界法通常用于解决 <strong>离散值的最优化问题</strong></p>
</li>
</ul>
<h4 id="搜索方式不同"><a href="#搜索方式不同" class="headerlink" title="搜索方式不同"></a>搜索方式不同</h4><ul>
<li>回溯法以 <strong>深度优先</strong> 的方式（遍历结点）搜索解空间树 </li>
<li>分支限界法以 <strong>广度优先</strong> 或 <strong>最小耗费优先</strong> 的方式搜索解空间树 </li>
</ul>
<h4 id="对扩展结点的扩展方式不同"><a href="#对扩展结点的扩展方式不同" class="headerlink" title="对扩展结点的扩展方式不同"></a>对扩展结点的扩展方式不同</h4><ul>
<li>分支限界法中，每一个活结点只有一次机会成为扩展结点，活结点一旦成为扩展结点，就一次性产生其所有儿子结点 </li>
<li>重复上述结点扩展过程，直至到找到所需的解或活结点表为空时为止 </li>
</ul>
<h3 id="Demo——旅行商问题求解"><a href="#Demo——旅行商问题求解" class="headerlink" title="Demo——旅行商问题求解"></a>Demo——旅行商问题求解</h3><p>参考： <a href="https://blog.csdn.net/qq_32400847/article/details/51813606" target="_blank" rel="noopener"> 这里 </a></p>
<h4 id="问题描述-8"><a href="#问题描述-8" class="headerlink" title="问题描述"></a>问题描述</h4><p>给出一个城市的集合和一个定义在 <strong>每一对城市之间</strong> 的耗费函数，找出耗费最小的旅行。</p>
<h4 id="解决思路-3"><a href="#解决思路-3" class="headerlink" title="解决思路"></a>解决思路</h4><p>考虑下图所示的情况及其代价矩阵，假定起始城市为1号城市：</p>
<p><img src="https://img-blog.csdn.net/20160703014447395" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20160703014332283" alt="这里写图片描述"><br>注意代价矩阵的特点，每条满足要求的回路在代价矩阵中的每一行每一列有且只有1个元素与之对应。据此，我们可以用贪心算法计算问题的上界：<br>以起始城市作为出发城市，每次从当前出发城市发出的多条边中，选择没有遍历过的最短边连接的城市，作为下一步达到城市。在这个问题中，从城市1出发，途经1→3→5→4→2→1，路径长度1+2+3+7+3=16作为上界，即最短路径长度<br>&lt;=16。<br>对于下界，一个简单的办法是直接将矩阵中每一行的最小元素相加，在这个问题中，路径长度1+3+1+3+2=10作为下界，即最短路径长度&gt;=10。更优的计算方式是<br><strong>将矩阵中每一行最小的2个元素相加除以2并向上取整</strong><br>。因为在一条路径上，每个城市有2条邻接边：进入该城市、离开该城市。对每一步经过的城市j，从最近的上一个城市i来，再到下一个最近城市k去，即i→j→k。在这个问题中，路径长度{(1+3)+(3+6)+(1+2)+(3+4)+(2+3)}/2向上取整等于14作为下界，即最短路径长度</p>
<blockquote>
<p>=14。因此，以最短路径长度dist作为TSP问题目标函数，则dist的界为[14,16]。在问题求解过程中，如果1个部分解的目标函数dist下界超出此界限，则该部分解对应了死结点，可剪枝。对于1条正在生成的路径/部分解，设已经确定的顶点(已经经过/遍历的城市)集合为U=(r1,<br>r2, …,<br>rk)，则该部分解的目标函数的下界为(已经经过的路径的总长的2倍+从起点到最近未遍历城市的距离+从终点到最近未遍历城市的距离+进入/离开未遍历城市时各未遍历城市带来的最小路径成本)除以2并向上取整。假设正在生成的路径/部分解为1→4,U={1,4},未遍历城市={2,3,5},该部分解下界为{2*5+1+3+(3+6)+(1+2)+(2+3)}/2向上取整等于16：<br><img src="https://img-blog.csdn.net/20160703021801114" alt="这里写图片描述"></p>
</blockquote>
<h1 id="九：随机算法"><a href="#九：随机算法" class="headerlink" title="九：随机算法"></a>九：随机算法</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>随机算法是一种在接受输入的同时，为了随机选择的目的，还接受一串随机比特流并且在运行过程中使用该比特流的算法(允许算法在执行过程中随机地选择下一个计算步骤)。</p>
<p>随机算法通常有两个 <strong>优点</strong> ：</p>
<ul>
<li>较之那些我们所知的解决同一问题最好的确定性算法，随机算法所需的运行时间或空间通常小一些。 </li>
<li>随机算法比较易于理解和实现（呵，站着说话不腰疼）。 </li>
</ul>
<p>随机算法的 <strong>基本特征</strong> ：对所求解问题的同一实例用同一随机算法求解两次可能得到完全不同的效果。<br>这两次求解所需的时间、所得到的结果可能会有相当大的差别。</p>
<h2 id="随机算法的类别"><a href="#随机算法的类别" class="headerlink" title="随机算法的类别"></a>随机算法的类别</h2><p>随机（概率）算法大致分四类：</p>
<ul>
<li>数值概率算法 </li>
</ul>
<blockquote>
<p>常用于数值问题的求解。<br> 这类算法所得到的往往是近似解且近似解的精度随计算时间的增加而不断提高。<br> 在许多情况下,要计算出问题的精确解是不可能的,或者没有必要,此时,用数值概率算法可以得到相当满意的解。</p>
</blockquote>
<ul>
<li>蒙特卡洛(Monte Carlo)算法 </li>
</ul>
<blockquote>
<p>用于求问题的准确解。<br> 对于许多问题来说,近似解毫无意义。<br> 例如,一个判定问题其解为“是”或“否” ,二者必居其一,<br> 不存在任何近似解。<br> 又如,我们要求一个整数的因子,这样问题的解答必须是准<br> 确的,一个整数的近似因子没有任何意义。<br> 用蒙特卡洛算法能求得问题的一个解,但这个解未必是正确的。<br> 求得正确解的概率依赖于算法所用的时间,算法所用的时间越多,得到正确解的概率就越高。<br> 蒙特卡洛算法的主要缺点也在于此,即无法有效地判定所得到的解是否肯定正确。</p>
</blockquote>
<ul>
<li>拉斯维加斯(Las Vegas)算法 </li>
</ul>
<blockquote>
<p>拉斯维加斯算法不会得到不正确的解。<br> 一旦用拉斯维加斯算法找到一个解,这个解就一定是正确<br> 解。<br> 但有时用拉斯维加斯算法会找不到解。<br> 与蒙特卡洛算法类似,拉斯维加斯算法找到正确解的<strong>概率随着它所用的计算时间<br> 的增加而提高</strong>。<br> 对于所求解问题的任一实例,用拉斯维加斯算法反复对该实例求解足够多次,可使求解失效的概率任意小。</p>
</blockquote>
<ul>
<li>舍伍德(Sherwood)算法 </li>
</ul>
<blockquote>
<p>舍伍德算法总能求得问题的一个解,且所求得的解总是正确的。  </p>
</blockquote>
<p>当一个确定性算法在最坏情况下的计算复杂性与其在平均情况下的计算复杂性有较大差别时,可在这个确定性算法中引入随机性,将它改造成一个舍伍德算法,消除或减少问题的好坏实例间的这种差别。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>Monte Carlo算法   </li>
</ul>
<blockquote>
<p>总是给出解，但是偶尔可能会产生非正确的解。然而，可以通过多次运行原算法，并且满足每次运行时的随机选择都相互独立，使产生非正确解的概率可以减到任意小。</p>
</blockquote>
<h3 id="主元素问题（多数元素问题）"><a href="#主元素问题（多数元素问题）" class="headerlink" title="主元素问题（多数元素问题）"></a>主元素问题（多数元素问题）</h3><h4 id="问题描述-9"><a href="#问题描述-9" class="headerlink" title="问题描述"></a>问题描述</h4><p>设T[1…n]是一个长度为n的数组，当某个元素在该数组中存在的数量多于int(s/2)时称该元素为数组T的主元素（多数元素）。</p>
<h4 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h4><p>算法随机选择数组元素x,由于数组T的非主元素个数小于n/2，所以，x不为主元素的概率小于1/2。因此判定数组T的主元素存在性的算法是一个偏真1/2正确的算法。50%的错误概率是不可容忍的，利用重复调用技术将错误概率降低到任何可接受的范围内。对于任何给定的p</p>
<blockquote>
</blockquote>
<p>0，算法majorityMC重复调用(向上取整)log(1/p)次算法majority。它是一个偏真蒙特卡罗算法，且其错误概率小于p。算法majorityMC所需的计算时间显然是O(nlog(1/p))。</p>
<h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>//重复k次调用算法Majority
template&lt;class Type&gt;
bool MajorityMC(Type *T,int n,double e)
{
    int k = ceil(log(1/e)/log((float)2));
    for(int i=1; i&lt;=k; i++)
    {
        if(Majority(T,n))
        {
            return true;
        }
    }
    return false;
}


bool Majority(Type *T,int n)
{
    RandomNumber rnd;
    int i = rnd.Random(n);

    Type x = T[i];  //随机选择数组元素
    int k = 0;

    for(int j=0; j&lt;n; j++)
    {
        if(T[j] == x)
        {
            k++;
        }
    }

    return (k&gt;n/2); //k&gt;n/2时，T含有主元素
}
</code></pre><h2 id="随机化快速排序"><a href="#随机化快速排序" class="headerlink" title="随机化快速排序"></a>随机化快速排序</h2><p>（可能是最为流行的一种随机算法？）<br>首先要明确传统快速排序的流程：从待排序序列中拿出最后一个（或者第一个）作为主元，将小于它的放在它的前面，大于它的放在它的后面，这时对该主元的前一部分和后一部分再分别递归进行“划分”，最后达到有序。这种方法有一个很大的问题就是当待排序数组是一个几乎有序的序列时其复杂度会很容易达到senta(n^2)，因为如果每次都选择第一个元素或者最后一个元素作为主元进行划分，对一个几乎有序的序列，划分后的递归对象（子序列）将会一个很长一个很短，这样可能经过好多次划分后还是有一个待划分的子部分很长。解决方法是每次不选择第一个或者最后一个作为主元，而是随机产生一个从第一个到最后一个之间的随机数作为主元进行划分，这样即保留了快速排序的优越性又避免了排序几乎有序序列时的痛点。</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><pre><code>void RandomQuickSort(int low,int high){
    if(low&lt;high){

        int v=random(low,high);
        int t=A[low];
        A[low]=A[v];
        A[v]=t;

        Split(A[low...high],low);
        RandomQuickSort(low,v-1);
        RandomQuickSort(v+1,high);
    }
}
</code></pre><p>该算法在最坏情况下仍然是senta(n^2)，但这与输入形式无关。如果最坏情况发生，那是因为用随机数选取的主元不凑巧，这个事件发生的概率是非常小的。事实上，没有一种输入的排列可以引起它的最坏情况，算法的期望运行时间是senta(nlogn).</p>
<h2 id="随机化的选择算法（寻找第k小元素）"><a href="#随机化的选择算法（寻找第k小元素）" class="headerlink" title="随机化的选择算法（寻找第k小元素）"></a>随机化的选择算法（寻找第k小元素）</h2><p>什么是选择算法：</p>
<h3 id="SELECT-算法描述-1"><a href="#SELECT-算法描述-1" class="headerlink" title="SELECT 算法描述"></a>SELECT 算法描述</h3><ol>
<li>如果数组元素个数小于 44,则直接将数组排序并返回第 k小元素(采用直接的方法来解决问题,因为当总元素个数小于44*5=220的时候用直接的方法解决问题更快)。 </li>
<li>把 n 个元素以每组 5 个元素划分为 int( n/5) 组,如果 n 不是 5的倍数则抛弃剩余元素。 </li>
<li>对每组进行排序,之后取出每组的中间项(第 3 个元素)。 </li>
<li>递归调用 SELECT 算法,得到这些中间项序列中的中项元素 mm </li>
<li><p>根据 mm,将原数组 A 划分为三个子数组: </p>
<ul>
<li>A1={小于 mm 的元素}; </li>
<li>A2={等于 mm 的元素}; </li>
<li>A3={大于 mm 的元素}; </li>
</ul>
</li>
<li>根据 k 的大小,判断第 k 小元素会出现在 A1,A2,A3 中的<br>哪一个数组里,之后,或者返回第 k 小元素(mm,在 A2<br>中),或者在 A1 或 A3 上递归。</li>
</ol>
<pre><code>    1：k &lt;len(A 1) 第 k 小元素在 A1 中;
2：len(A 1) =k &lt;= A 1+ A 2 第 k 小元素在 A2 中;
3： A 1 + A 2 &lt; k &lt;= A 1 + A 2+  A 3第 k 小元素在 A3 中;
</code></pre><p>该算法的运行时间是senta(n)(T(n)&lt;=20cn,c是排序43个元素所需的时间)，具有一个很大的常数系数，所以就有了随机版的选择算法：</p>
<pre><code>    /*
 * 输入：n个元素的数组A[1...n]和整数k
 * 输出：A中的第k小元素
 * 
 */

R_Select(A,1,n,k);

void R_Select(int *A, int low, int high, int k) {
    int v = random(low, high);
    int x = A[v];
    A1 = {a | a &lt; x};
    A2 = {a | a = x};
    A3 = {a | a &gt; x};

    if (A1.len &gt;= k)return R_Select(A, 1, A1.len, k);
    else if (A.len + A2.len &gt;= k)return x;
    else if (A1.len + A2.len &lt; k)return R_Select(A, 1, A3.len, k - A1.len - A2.len);
}
</code></pre><p>该版本的随机算法与原版本的主要不用是原版本是将序列分为若干个5元素序列分别进行排序后找到那些5元素序列中值组成的新序列的中值作为主元对元素进行划分，而随机算法是产生一个序列中的随机数（就是在待找序列中随机找了一个数）作为主元，省去了那些排序5元素数组的步骤，对于大小为n的输入，算法RandomizedSekect执行的期望比较次数小于4n，他的期望运行时间是senta(n)。<br>可以发现该随机算法最坏情况下的运行时间也是senta(n)，但是其发生最坏情况不依赖于输入，仅当产生的随机数序列很不凑巧时才会发生，而这种概率是非常小的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/17/Android解决The APK file app-debug.apk does not exist on disk./">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/17/Android解决The APK file app-debug.apk does not exist on disk./" itemprop="url">Android解决The APK file app-debug.apk does not exist on disk.</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-17T09:31:58+08:00">
                2018-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Android studio run app的时候报错The APK file app-debug.apk does not exist on disk.</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="Edit-Configurations"><a href="#Edit-Configurations" class="headerlink" title="Edit Configurations"></a>Edit Configurations</h2><p><img src="https://img-
blog.csdn.net/20180517092441412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如图，点击Edit Configurations，查看你app配置中的是否有如下选项：<br><img src="https://img-
blog.csdn.net/201805170926187?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如果没有则点击+号：<br><img src="https://img-
blog.csdn.net/20180517092659139?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>然后这里置为空直接ok：<br><img src="https://img-
blog.csdn.net/20180517092741458?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>然后点击ok重新run，如果不出意外该错误已经解决。</p>
<h1 id="Gradle-build"><a href="#Gradle-build" class="headerlink" title="Gradle build"></a>Gradle build</h1><p>如果第一种方法还未解决你的问题，可以尝试：<br><img src="https://img-
blog.csdn.net/20180517092912158?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-
blog.csdn.net/20180517092941420?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-
blog.csdn.net/20180517093055534?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2OTgyMTYw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/17/随机算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/17/随机算法/" itemprop="url">随机算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-17T08:35:26+08:00">
                2018-05-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随机算法是一种在接受输入的同时，为了随机选择的目的，还接受一串随机比特流并且在运行过程中使用该比特流的算法(允许算法在执行过程中随机地选择下一个计算步骤)。</p>
<p>随机算法通常有两个 <strong>优点</strong> ：</p>
<ul>
<li>较之那些我们所知的解决同一问题最好的确定性算法，随机算法所需的运行时间或空间通常小一些。 </li>
<li>随机算法比较易于理解和实现（呵，站着说话不腰疼）。 </li>
</ul>
<p>随机算法的 <strong>基本特征</strong> ：对所求解问题的同一实例用同一随机算法求解两次可能得到完全不同的效果。<br>这两次求解所需的时间、所得到的结果可能会有相当大的差别。</p>
<h2 id="随机算法的类别"><a href="#随机算法的类别" class="headerlink" title="随机算法的类别"></a>随机算法的类别</h2><p>随机（概率）算法大致分四类：</p>
<ul>
<li>数值概率算法 </li>
</ul>
<blockquote>
<p>常用于数值问题的求解。<br> 这类算法所得到的往往是近似解且近似解的精度随计算时间的增加而不断提高。<br> 在许多情况下,要计算出问题的精确解是不可能的,或者没有必要,此时,用数值概率算法可以得到相当满意的解。</p>
</blockquote>
<ul>
<li>蒙特卡洛(Monte Carlo)算法 </li>
</ul>
<blockquote>
<p>用于求问题的准确解。<br> 对于许多问题来说,近似解毫无意义。<br> 例如,一个判定问题其解为“是”或“否” ,二者必居其一,<br> 不存在任何近似解。<br> 又如,我们要求一个整数的因子,这样问题的解答必须是准<br> 确的,一个整数的近似因子没有任何意义。<br> 用蒙特卡洛算法能求得问题的一个解,但这个解未必是正确的。<br> 求得正确解的概率依赖于算法所用的时间,算法所用的时间越多,得到正确解的概率就越高。<br> 蒙特卡洛算法的主要缺点也在于此,即无法有效地判定所得到的解是否肯定正确。</p>
</blockquote>
<ul>
<li>拉斯维加斯(Las Vegas)算法 </li>
</ul>
<blockquote>
<p>拉斯维加斯算法不会得到不正确的解。<br> 一旦用拉斯维加斯算法找到一个解,这个解就一定是正确<br> 解。<br> 但有时用拉斯维加斯算法会找不到解。<br> 与蒙特卡洛算法类似,拉斯维加斯算法找到正确解的<strong>概率随着它所用的计算时间<br> 的增加而提高</strong>。<br> 对于所求解问题的任一实例,用拉斯维加斯算法反复对该实例求解足够多次,可使求解失效的概率任意小。</p>
</blockquote>
<ul>
<li>舍伍德(Sherwood)算法 </li>
</ul>
<blockquote>
<p>舍伍德算法总能求得问题的一个解,且所求得的解总是正确的。  </p>
</blockquote>
<p>当一个确定性算法在最坏情况下的计算复杂性与其在平均情况下的计算复杂性有较大差别时,可在这个确定性算法中引入随机性,将它改造成一个舍伍德算法,消除或减少问题的好坏实例间的这种差别。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li>Monte Carlo算法   </li>
</ul>
<blockquote>
<p>总是给出解，但是偶尔可能会产生非正确的解。然而，可以通过多次运行原算法，并且满足每次运行时的随机选择都相互独立，使产生非正确解的概率可以减到任意小。</p>
</blockquote>
<h3 id="主主元素问题（多数元素问题）"><a href="#主主元素问题（多数元素问题）" class="headerlink" title="主主元素问题（多数元素问题）"></a>主主元素问题（多数元素问题）</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>设T[1…n]是一个长度为n的数组，当某个元素在该数组中存在的数量多于int(s/2)时称该元素为数组T的主元素（多数元素）。</p>
<h4 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h4><p>算法随机选择数组元素x,由于数组T的非主元素个数小于n/2，所以，x不为主元素的概率小于1/2。因此判定数组T的主元素存在性的算法是一个偏真1/2正确的算法。50%的错误概率是不可容忍的，利用重复调用技术将错误概率降低到任何可接受的范围内。对于任何给定的p</p>
<blockquote>
</blockquote>
<p>0，算法majorityMC重复调用(向上取整)log(1/p)次算法majority。它是一个偏真蒙特卡罗算法，且其错误概率小于p。算法majorityMC所需的计算时间显然是O(nlog(1/p))。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>//重复k次调用算法Majority
template&lt;class Type&gt;
bool MajorityMC(Type *T,int n,double e)
{
    int k = ceil(log(1/e)/log((float)2));
    for(int i=1; i&lt;=k; i++)
    {
        if(Majority(T,n))
        {
            return true;
        }
    }
    return false;
}


bool Majority(Type *T,int n)
{
    RandomNumber rnd;
    int i = rnd.Random(n);

    Type x = T[i];  //随机选择数组元素
    int k = 0;

    for(int j=0; j&lt;n; j++)
    {
        if(T[j] == x)
        {
            k++;
        }
    }

    return (k&gt;n/2); //k&gt;n/2时，T含有主元素
}
</code></pre><h2 id="随机化快速排序"><a href="#随机化快速排序" class="headerlink" title="随机化快速排序"></a>随机化快速排序</h2><p>（可能是最为流行的一种随机算法？）<br>首先要明确传统快速排序的流程：从待排序序列中拿出最后一个（或者第一个）作为主元，将小于它的放在它的前面，大于它的放在它的后面，这时对该主元的前一部分和后一部分再分别递归进行“划分”，最后达到有序。这种方法有一个很大的问题就是当待排序数组是一个几乎有序的序列时其复杂度会很容易达到senta(n^2)，因为如果每次都选择第一个元素或者最后一个元素作为主元进行划分，对一个几乎有序的序列，划分后的递归对象（子序列）将会一个很长一个很短，这样可能经过好多次划分后还是有一个待划分的子部分很长。解决方法是每次不选择第一个或者最后一个作为主元，而是随机产生一个从第一个到最后一个之间的随机数作为主元进行划分，这样即保留了快速排序的优越性又避免了排序几乎有序序列时的痛点。</p>
<h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><pre><code>void RandomQuickSort(int low,int high){
    if(low&lt;high){

        int v=random(low,high);
        int t=A[low];
        A[low]=A[v];
        A[v]=t;

        Split(A[low...high],low);
        RandomQuickSort(low,v-1);
        RandomQuickSort(v+1,high);
    }
}
</code></pre><p>该算法在最坏情况下仍然是senta(n^2)，但这与输入形式无关。如果最坏情况发生，那是因为用随机数选取的主元不凑巧，这个事件发生的概率是非常小的。事实上，没有一种输入的排列可以引起它的最坏情况，算法的期望运行时间是senta(nlogn).</p>
<h2 id="随机化的选择算法"><a href="#随机化的选择算法" class="headerlink" title="随机化的选择算法"></a>随机化的选择算法</h2><p>什么是选择算法：</p>
<h3 id="SELECT-算法描述"><a href="#SELECT-算法描述" class="headerlink" title="SELECT 算法描述"></a>SELECT 算法描述</h3><ol>
<li>如果数组元素个数小于 44,则直接将数组排序并返回第 k小元素(采用直接的方法来解决问题,因为当总元素个数小于44*5=220的时候用直接的方法解决问题更快)。 </li>
<li>把 n 个元素以每组 5 个元素划分为 int( n/5) 组,如果 n 不是 5的倍数则抛弃剩余元素。 </li>
<li>对每组进行排序,之后取出每组的中间项(第 3 个元素)。 </li>
<li>递归调用 SELECT 算法,得到这些中间项序列中的中项元素 mm </li>
<li><p>根据 mm,将原数组 A 划分为三个子数组: </p>
<ul>
<li>A1={小于 mm 的元素}; </li>
<li>A2={等于 mm 的元素}; </li>
<li>A3={大于 mm 的元素}; </li>
</ul>
</li>
<li>根据 k 的大小,判断第 k 小元素会出现在 A1,A2,A3 中的<br>哪一个数组里,之后,或者返回第 k 小元素(mm,在 A2<br>中),或者在 A1 或 A3 上递归。</li>
</ol>
<pre><code>    1：k &lt;len(A 1) 第 k 小元素在 A1 中;
2：len(A 1) =k &lt;= A 1+ A 2 第 k 小元素在 A2 中;
3： A 1 + A 2 &lt; k &lt;= A 1 + A 2+  A 3第 k 小元素在 A3 中;
</code></pre><p>该算法的运行时间是senta(n)(T(n)&lt;=20cn,c是排序43个元素所需的时间)，具有一个很大的常数系数，所以就有了随机版的选择算法：</p>
<pre><code>    /*
 * 输入：n个元素的数组A[1...n]和整数k
 * 输出：A中的第k小元素
 * 
 */

R_Select(A,1,n,k);

void R_Select(int *A, int low, int high, int k) {
    int v = random(low, high);
    int x = A[v];
    A1 = {a | a &lt; x};
    A2 = {a | a = x};
    A3 = {a | a &gt; x};

    if (A1.len &gt;= k)return R_Select(A, 1, A1.len, k);
    else if (A.len + A2.len &gt;= k)return x;
    else if (A1.len + A2.len &lt; k)return R_Select(A, 1, A3.len, k - A1.len - A2.len);
}
</code></pre><p>该版本的随机算法与原版本的主要不用是原版本是将序列分为若干个5元素序列分别进行排序后找到那些5元素序列中值组成的新序列的中值作为主元对元素进行划分，而随机算法是产生一个序列中的随机数（就是在待找序列中随机找了一个数）作为主元，省去了那些排序5元素数组的步骤，对于大小为n的输入，算法RandomizedSekect执行的期望比较次数小于4n，他的期望运行时间是senta(n)。<br>可以发现该随机算法最坏情况下的运行时间也是senta(n)，但是其发生最坏情况不依赖于输入，仅当产生的随机数序列很不凑巧时才会发生，而这种概率是非常小的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/14/NP完全问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/NP完全问题/" itemprop="url">NP完全问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T20:07:21+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果一个算法的最差时间效率属于 O ( p ( n )) ,其中 p (n ) 是问题输入规模 n 的一个多项式函数,我们说该算法能<br><strong>够在多项式的时间内对问题求解</strong> 。<br>我们把可以在多项式时间内求解的问题称为 <strong>易解的</strong> ,而不能在多项式时间内求解的问题则称为 <strong>难解的</strong> 。</p>
<p>非正式地说，我们可以把那些 <strong>能够在多项式时间内求解</strong> 的问题当作计算机科学家所说的 <em><em> P 集合</em></em> 。<br>正式点，只有那些 <strong>能够回答是或否</strong> 的问题（又称判定问题）才属于 P。</p>
<p>P 类问题是一类能够用 <strong>确定性算法在多项式时间内求解</strong> 的 <strong>判定问题</strong> 。<br>这种问题类型也称为 <strong>多项式类型</strong> 。</p>
<p>绝大多数判定问题的一个公共特性是:</p>
<blockquote>
<p>虽然在计算上对问题求解可能是困难的,但在计算上 <strong>判定一个待定解是否解决了该问题</strong> 却是简单的,并且,这种判定可以在多项式时间内完成。</p>
</blockquote>
<p>一个不确定算法是一个两阶段的过程,它把一个判定问题的实例 l 作为它的输入,并进行下面的操作:</p>
<ul>
<li>猜测(非确定)阶段:   </li>
</ul>
<blockquote>
<p>生成一个任意串 S,把它当作给定实例 l 的一个候选解,但 S也可能是完全不着边际的。</p>
</blockquote>
<ul>
<li>验证(确定)阶段:<br>确定算法把 l 和 S 都作为它的输入,如果 S 的确是 l 的一个解的话,就输出“是”;<br>如果 S 不是 l 的一个解,该算法要么返回“否”,要么就根本停不下来。</li>
</ul>
<p>如果一个不确定算法在验证阶段的时间效率是多项式级的,我们说它是 <strong>不确定多项式类型</strong> 的算法。 <strong>NP 类问题</strong>(Non-deterministic<br>Polynomial)是一类可以用不确定多项式算法求解的判定问题。我们把这种问题类型称为不确定多项式类。 我们说一个判定问题 D 1<br>可以多项式地化简为一个判定问题 D 2 ,条件是存在一个函数 t 能够把 D 1 的实例转化为D 2 的实例,使得:</p>
<ul>
<li>t 把 D 1 的所有真实例映射为 D 2 的真实例,把 D 1 的所有假实例映射为 D 2 的假实例。 </li>
<li>t 可以用一个多项式算法计算。 </li>
</ul>
<p>我们说一个判定问题 D 是 NP 完全问题,条件是:</p>
<ul>
<li>它属于 NP 类型。 </li>
<li>NP 中的任何问题都能够在多项式时间内化简为 D。 </li>
</ul>
<p>NP 完全问题:</p>
<blockquote>
<p>合取范式的可满足性问题<br> 哈密顿回路问题<br> 旅行商问题</p>
</blockquote>
<p>NP 完全问题的定义意味着,如果我们得到了一个 NP 完全问题的多项式确定算法,就说明所有的 NP 问题都能够用一个确定算法在多项式的时间内解出,因此,P<br>= NP.换句话说,得到了一个 NP<br>完全问题的多项式确定性算法可以表明,对于所有类型的判定问题来说,检验待定解和在多项式时间内求解在复杂性上没有本质的差别。<br>这种推论使得大多数计算机科学家相信 P ≠ NP但是,到目前为止,还没有人能从数学上证明这一猜想。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/14/算法分析基本概念/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/14/算法分析基本概念/" itemprop="url">算法分析基本概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-14T19:30:31+08:00">
                2018-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><h3 id="Linearsearch"><a href="#Linearsearch" class="headerlink" title="Linearsearch"></a>Linearsearch</h3><pre><code>/*
 * 输入：n个元素的数组A[1...n]、x
 * 输出：如果x=A[j]&amp;&amp;1&lt;=j&lt;=n，则输出j，否则输出0
 */

int Linearsearch(int *A,int x, int n){
    int j=0;
    while (j&lt;n&amp;&amp;x!=A[j]){
        j++;
    }

    if(x==A[j])return j;
    return 0;
}
</code></pre><h3 id="Binarysearch"><a href="#Binarysearch" class="headerlink" title="Binarysearch"></a>Binarysearch</h3><pre><code>/*
 * 输入：n个元素的升序数组A[1...n]、x
 * 输出：如果x=A[j]&amp;&amp;1&lt;=j&lt;=n，则输出j，否则输出0
 */

int Binarysearch(int *A, int x, int n) {
    int low = 1, high = n, j = 0;
    while (low &lt;= high &amp;&amp; j == 0) {
        int mid = (int) ((low + high) / 2);
        if (x == A[mid])j = mid;
        else if (x &lt; A[mid])high = mid - 1;
        else low = mid + 1;
    }

    return j;
}
</code></pre><p>要注意二分搜索的输入一定是一个 <strong>升序</strong><br>的数组，实质就是一个二叉搜索树（所以也把二分搜索的执行描述为决策树），对于一个大小为n的排序数组，算法Binarysearch执行比较的最大次数为int（logn）+1（如果输入数组不是递增排好序的，则可在nlogn内对其进行排序后再进行二分搜索）。</p>
<h2 id="合并两个已排序的表"><a href="#合并两个已排序的表" class="headerlink" title="合并两个已排序的表"></a>合并两个已排序的表</h2><pre><code>/*
 * 输入：数组A[1...m]和它的三个索引p，q，r，1&lt;=p&lt;=q&lt;r&lt;=m，p、q、r满足A[p...q]、A[q+1...r]分别按照升序排列
 * 输出：合并两个子数组A[p...q]和A[q+1...r]的数组A[p...r]
 */

void Merge(int *A, int p, int q, int r) {
    int B[r + 1];//B[p...r]是辅助数组
    int s = p, t = q + 1, k = p;//s指向A[p...q]子数组，t指向A[q+1...r]子数组，k指向B数组
    while (s &lt;= q &amp;&amp; t &lt;= r) {
        if (A[s] &lt;= A[t]) {
            B[k] = A[s];
            s++;
        } else {
            B[k] = A[t];
            t++;
        }

        k++;
    }

    if (s = q + 1) {//说明s指向的数组已经遍历完了
        for (int i = t; i &lt;= r; ++i) {
            B[k++] = A[i];
        }
    } else {
        for (int i = s; i &lt;= r; ++i) {
            B[k++] = A[i];
        }
    }

    for (int j = p; j &lt;= r; ++j) {
        A[j] = B[j];

    }
}
</code></pre><p>设Merge算法要合并两个大小分别为n1和n2的数组（n1</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><pre><code>/*
 * 输入：n个元素的数组A[1...n]
 * 输出：按非降序排列的数组A[1...n]
 */

void SelectionSort(int *A, int n) {

    for (int i = 0; i &lt; n; ++i) {

        for (int j = i + 1; j &lt;= n; ++j) {
            if (A[i] &gt; A[j]) {
                int t = A[i];
                A[i] = A[i];
                A[i] = t;
            }
        }
    }

}
</code></pre><p>算法SelectionSort所需的元素比较次数为n(n-1)/2（n-1+n-2+n-3+…+2+1=n(n-1)/2），因为每次交换需要3次赋值，所以元素的赋值次数介于0到3(n-1)之间。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先将第二个数与第一个数进行对比，如果第二个数比第一个数小，则将第二个数插入到第一个数之前，这样保证前两个数是有序的；<br>接下来将第三个数与前两个数对比，比较的思路是先将第三个数存下来（记为x），然后将第三个数与第二个数比较，如果第二个数比第三个数大，则直接将第二个数向后移动一位，如果第二个数不比第三个数大，则说明此时前三个数都是有序的，因为之前前两个数是有序的，比较到最后，将x放到第三个数比较的终止位置即可。以此类推，将后面的i个数分别其前面的i-1个数进行对比，并将其插入到第一个比其大的数前面，最后即可完成排序。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/*
 * 输入：n个元素的数组A[1...n]
 * 输出：按非降序排列的数组A[1...n]
 */

void InsertionSort(int *A, int n) {
    for (int i = 2; i &lt;= n; ++i) {
        int x = A[i];
        int j = i - 1;
        while (j &gt; 0 &amp;&amp; A[j] &gt; x) {
            A[j + 1] = A[j];
            j--;
        }
        A[j + 1] = x;
    }
}
</code></pre><p>执行算法SelectionSort的元素比较次数在n-1到n(n-1)/2之间，元素赋值次数等于元素比较次数加上n-1.</p>
<h2 id="自底向上合并排序"><a href="#自底向上合并排序" class="headerlink" title="自底向上合并排序"></a>自底向上合并排序</h2><pre><code>/*
 * 输入：n个元素的数组A[1...n]
 * 输出：按非降序排列的数组A[1...n]
 */


void Merge(int *A, int p, int q, int r);

void BottomUpSort(int *A, int n) {
    int t = 1;
    while (t &lt; n) {
        int s = t, t = 2 * s, i = 0;
        while (i + t &lt;= n) {
            Merge(A, i + 1, i + s, i + t);
            i = i + t;
        }
        if (i + s &lt; n) {
            Merge(A, i + 1, i + s, n);
        }
    }
}
</code></pre><p>用算法BottomUpSort对n个元素的数组进行排序，当n为2的幂时，元素比较次数在(nlogn)/2到nlogn-n+1之间。执行该算法的元素赋值次数为2nlogn。</p>
<h2 id="时间复杂性"><a href="#时间复杂性" class="headerlink" title="时间复杂性"></a>时间复杂性</h2><h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><p>前文提到算法InsertionSort执行的运算次数至多为cn^2，其中c为某个适当选择的正常数。这时我们说算法InsertionSort的运行时间是O(n^2)，说明当排序元素的个数等于或超过某个阈值n0时，对于某个常亮c，运行时间是cn^2，<br><strong>O符号描述的是一个上界但不一定是算法的实际执行时间</strong><br>，比如当排序一个已经排序好的数组时InsertionSort的运行时间就不是O(n^2)而是O(n)了。</p>
<h3 id="Ω"><a href="#Ω" class="headerlink" title="Ω"></a>Ω</h3><p>相比于O，Ω描述的是算法执行的 <strong>下界</strong><br>，比如算法InsertionSort的运算时间至少是cn，则称算法InsertionSort的运行时间是Ω（n），即无论何时，当被排序的元素个数等于或超过某一个阈值n0时，对于某个常数c，算法的运行时间至少是cn。</p>
<h3 id="Senta"><a href="#Senta" class="headerlink" title="Senta"></a>Senta</h3><p>Senta描述的是一个确切界限，如果对于任意大小等于或超过某一阈值n0的输入，如果运行时间在c1g(n)和c2g(n)之间，则称算法的运行时间是Senta(g(n))。</p>
<h3 id="复杂性类与-o-符号"><a href="#复杂性类与-o-符号" class="headerlink" title="复杂性类与 o 符号"></a>复杂性类与 o 符号</h3><h4 id="o符号"><a href="#o符号" class="headerlink" title="o符号"></a>o符号</h4><p>O 符号给出的上界可以是“紧”的,也可以是非“紧”的。<br>2<em> n^ 2 =O ( n^ 2 ) 是渐近性紧边界<br>2 </em>n = O ( n^ 2 ) 不是渐近性紧边界</p>
<p>o 符号就用来表示 <strong>不是渐近性紧边界</strong> 的上界<br>举例: 2 n = o ( n ) , 2 ^n ！= o ( n )</p>
<p>直观上来说,在小 o 符号中, f ( n ) =o ( g ( n )) ,当 n 趋向于无穷大时, f (n ) 函数相当于 g (n )<br>就变得不再重要了<br>即lim- &gt;+oof(n)/g(n)=0</p>
<h4 id="w符号"><a href="#w符号" class="headerlink" title="w符号"></a>w符号</h4><p>用类比法来讲,小 w符号相对于大 Ω符号的关系正如 o 符号相对于 O 符号的关系。<br>我们用小 w 符号来表示一个 <strong>渐近性非紧密的下界</strong> 。<br>比如：</p>
<blockquote>
<p>(n^2)/2=w(n )<br> (n^2)/2!=w(n^2)</p>
</blockquote>
<p>lim- &gt;+oof(n)/g(n)=oo</p>
<h2 id="空间复杂性"><a href="#空间复杂性" class="headerlink" title="空间复杂性"></a>空间复杂性</h2><p>我们把算法使用的空间 定义 、为:为了求解问题的实例而执行的计算步骤所需要的内存空间,它<br><strong>不包括分配用来存储输入的空间（为了区分那些在整个计算过程中占用了少于输入空间的算法）</strong> 。</p>
<p>算法的 <strong>空间复杂性不可能超过运行时间的复杂性</strong> ,因为每写入一个内存单元都至少需要一定的时间。所以,如果用 T (n ) 和 S (n )<br>分别代表算法的时间复杂性和空<br>间复杂性,有: S ( n ) = O ( T ( n )) 。</p>
<h2 id="最优算法"><a href="#最优算法" class="headerlink" title="最优算法"></a>最优算法</h2><p>如果可以证明任何一个求解问题 T的算法必定是Ω ( f ( n )) ,那么我们把在 O ( f ( n )) 时间内求解问题T的任何算法都称为问题<br>T的最优算法。</p>
<h2 id="如何估计算法的运行时间"><a href="#如何估计算法的运行时间" class="headerlink" title="如何估计算法的运行时间"></a>如何估计算法的运行时间</h2><ul>
<li>计算迭代次数 </li>
<li>计算基本运算的频度 </li>
</ul>
<blockquote>
</blockquote>
<p>一般来说,在分析一个算法运行时间时,可以找出这样一个元运算,它的频率至少和任何其他运算的频度一样大,称这样的运算为基本运算。我们还可以放宽这个定义,把那些频度和运行时间成正比的运算包括进来。</p>
<ul>
<li>使用递推关系 </li>
</ul>
<blockquote>
</blockquote>
<p>如果一个算法本身是递归算法,那么计算这个算法运行时间的函数通常也是递归的,即是指,这个函数的定义中引用了函数自身。即便一个算法本身是非递归的,我们有时也可以用递归式来计算它的运行时间。</p>
<p>lim- &gt;+oof(n)/g(n)!=oo f(n)=O(g(n))<br>lim-&gt;+oof(n)/g(n)!=0 f(n)=Ω(g(n))<br>lim-&gt;+oof(n)/g(n)==c f(n)=Senta(g(n))</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/11/软件系统介绍文档模板/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/软件系统介绍文档模板/" itemprop="url">软件系统介绍文档模板</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-11T17:06:40+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/杂烩/" itemprop="url" rel="index">
                    <span itemprop="name">杂烩</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="开发背景"><a href="#开发背景" class="headerlink" title="开发背景"></a>开发背景</h3><p>【比如为什么要开发这个系统】</p>
<h3 id="开发目标"><a href="#开发目标" class="headerlink" title="开发目标"></a>开发目标</h3><p>【该系统需要完成的基本功能，对系统的大体描述】</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>【该系统涉及的开源项目等】</p>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>【设计该系统遵守的原则，比如支持多数据库，可移植行，可拓展性等】</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="需求陈述"><a href="#需求陈述" class="headerlink" title="需求陈述"></a>需求陈述</h3><p>【用平常语言描述该系统的全部功能和细节】</p>
<h3 id="操作用例"><a href="#操作用例" class="headerlink" title="操作用例"></a>操作用例</h3><p>【描述具体的操作例子，比如登录后进行何种操作】</p>
<h3 id="功能分析划分"><a href="#功能分析划分" class="headerlink" title="功能分析划分"></a>功能分析划分</h3><p>【分析功能并划分功能块】</p>
<h4 id="系统登录"><a href="#系统登录" class="headerlink" title="系统登录"></a>系统登录</h4><p>【比如，需要实现两种登录模块，普通登录，管理员登录，并且描述可能出现的各种情况以及问题处理】</p>
<h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><p>【比如：实现用户显示，添加，删除，修改】</p>
<p>……</p>
<h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><h3 id="系统建模"><a href="#系统建模" class="headerlink" title="系统建模"></a>系统建模</h3><h4 id="层次方框图"><a href="#层次方框图" class="headerlink" title="层次方框图"></a>层次方框图</h4><p>【从顶部开始，按照层次分类进行细化】</p>
<h4 id="ER图（实体-联系图）"><a href="#ER图（实体-联系图）" class="headerlink" title="ER图（实体-联系图）"></a>ER图（实体-联系图）</h4><p>【分析各个对象之间的联系，画图ER图】</p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><h3 id="类图设计"><a href="#类图设计" class="headerlink" title="类图设计"></a>类图设计</h3><p>【使用UML画出各个类的属性、继承和方法】</p>
<h3 id="接口设计-1"><a href="#接口设计-1" class="headerlink" title="接口设计"></a>接口设计</h3><p>【各个子系统之间的接口和用户接口】</p>
<h4 id="内部接口设计"><a href="#内部接口设计" class="headerlink" title="内部接口设计"></a>内部接口设计</h4><p>【各个部件是通过何种方式进行连接，比如通过远程数据库，http等】</p>
<h4 id="登录界面设计"><a href="#登录界面设计" class="headerlink" title="登录界面设计"></a>登录界面设计</h4><h4 id="用户管理界面设计"><a href="#用户管理界面设计" class="headerlink" title="用户管理界面设计"></a>用户管理界面设计</h4><p>……</p>
<h3 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h3><p>【主要是描述】</p>
<h4 id="数据库E-R图"><a href="#数据库E-R图" class="headerlink" title="数据库E-R图"></a>数据库E-R图</h4><h4 id="数据库逻辑设计"><a href="#数据库逻辑设计" class="headerlink" title="数据库逻辑设计"></a>数据库逻辑设计</h4><h3 id="出错处理"><a href="#出错处理" class="headerlink" title="出错处理"></a>出错处理</h3><p>【描述如果出错的处理方法】</p>
<h3 id="安全保密设计"><a href="#安全保密设计" class="headerlink" title="安全保密设计"></a>安全保密设计</h3><p>【描述采用何种方法保证安全性】</p>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h3><p>【具体来说就是把经过总体设计得到的各个模块详细的加以描述。】</p>
<h3 id="伪代码编写"><a href="#伪代码编写" class="headerlink" title="伪代码编写"></a>伪代码编写</h3><p>【使用中文或者英文进行伪代码编写，以后这些伪代码将会成为代码的注释】</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="代码约定"><a href="#代码约定" class="headerlink" title="代码约定"></a>代码约定</h4><h4 id="代码编写原则"><a href="#代码编写原则" class="headerlink" title="代码编写原则"></a>代码编写原则</h4><h3 id="测试要点"><a href="#测试要点" class="headerlink" title="测试要点"></a>测试要点</h3><h4 id="登录测试要点"><a href="#登录测试要点" class="headerlink" title="登录测试要点"></a>登录测试要点</h4><p>【描述该如何测试，数据的输入，类型】</p>
<h4 id="主界面测试要点"><a href="#主界面测试要点" class="headerlink" title="主界面测试要点"></a>主界面测试要点</h4><p>……</p>
<h3 id="测试结果和总结"><a href="#测试结果和总结" class="headerlink" title="测试结果和总结"></a>测试结果和总结</h3><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="维护方法"><a href="#维护方法" class="headerlink" title="维护方法"></a>维护方法</h3><h3 id="维护文档"><a href="#维护文档" class="headerlink" title="维护文档"></a>维护文档</h3><h3 id="功能拓展方法"><a href="#功能拓展方法" class="headerlink" title="功能拓展方法"></a>功能拓展方法</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2018/05/08/贪心算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/贪心算法/" itemprop="url">贪心算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T20:25:41+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法与数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">算法与数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说， <strong>不从整体最优上加以考虑</strong> ，他所做出的仅是在某种意义上的局部最优解。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。<br>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p>
<h1 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个有向图G=(V,E),s为V中一点,以s为起点,要确定从s出发到V中每一个其他定点的距离(距离的定义是最短路径对应的长度).</p>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul>
<li><p>初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则  &lt; u,v &gt;正常有权值，若u不是v的出边邻接点，则 &lt; u,v &gt; 权值为∞ </p>
</li>
<li><p>从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度） </p>
</li>
<li><p>以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权 </p>
</li>
<li><p>重复步骤b和c直到所有顶点都包含在S中 </p>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>const int  MAXINT = 32767;
const int MAXNUM = 10;
int dist[MAXNUM];//表示距离
int prev[MAXNUM];//记录每个顶点的前驱顶点(因为最短路径的唯一性,所以每个点的前驱元素都是唯一的)

int A[MAXUNM][MAXNUM];

void Dijkstra(int v0)
{
  　　bool S[MAXNUM];                                  // 判断是否已存入该点到S集合中
      int n=MAXNUM;
  　　for(int i=1; i&lt;=n; ++i)
 　　 {
      　　dist[i] = A[v0][i];
      　　S[i] = false;                                // 初始都未用过该点
      　　if(dist[i] == MAXINT)   //如果该点与源点之间无边 
            　　prev[i] = -1;
 　　     else 
            　　prev[i] = v0;
   　　}
   　 dist[v0] = 0;
   　 S[v0] = true; 　　
 　　 for(int i=2; i&lt;=n; i++)
 　　 {
       　　int mindist = MAXINT;
       　　int u = v0; 　　                            // 找出当前未使用的点j的dist[j]最小值
      　　 for(int j=1; j&lt;=n; ++j)
      　　    if((!S[j]) &amp;&amp; dist[j]&lt;mindist)//如果j点没有被用过而且dist[j]小于mindist
      　　    {
         　　       u = j;                             // u保存当前邻接点中距离最小的点的号码 
         　 　      mindist = dist[j];
       　　   }
       　　S[u] = true; //将u置为已用
       　　for(int j=1; j&lt;=n; j++)//更新u加入已用集合后的未用顶点集合中点到已用集合中点的距离
       　　    if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT)
       　　    {
           　    　if(dist[u] + A[u][j] &lt; dist[j])     //在通过新加入的u点路径找到离v0点更短的路径  
           　    　{
                   　　dist[j] = dist[u] + A[u][j];    //更新dist 
                   　　prev[j] = u;                    //记录前驱顶点 
            　　    }
        　    　}
   　　}
}
</code></pre><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>算法的时间复杂度是senta(n^2)</p>
<h2 id="稠图的线性时间算法"><a href="#稠图的线性时间算法" class="headerlink" title="稠图的线性时间算法"></a>稠图的线性时间算法</h2><h1 id="最小耗费生成树"><a href="#最小耗费生成树" class="headerlink" title="最小耗费生成树"></a>最小耗费生成树</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>设G =<br>(V,E)是无向连通带权图，即一个网络。E中的每一条边（v,w）的权为c[v][w]。如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树上各边权的总和称为生成树的耗费。在G的所有生成树中，耗费最小的生成树称为G的最小生成树。<br>最小生成树最常见的题就是求解n个城市之间的修路问题.</p>
<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>给定无向连同带权图G = (V,E),V = {1,2,…,n}。Kruskal算法构造G的最小生成树的基本思想是：</p>
<ul>
<li><p>将G的n个顶点看成n个孤立的连通分支,将所有的边按权从小大排序。 </p>
</li>
<li><p>从第一条边开始，依边权递增的顺序检查每一条边。并按照下述方法连接两个不同的连通分支：当查看到第k条边(v,w)时，如果端点v和w分别是当前两个不同的连通分支T1和T2的端点时，就用边(v,w)将T1和T2连接成一个连通分支，然后继续查看第k+1条边；如果端点v和w在当前的同一个连通分支中，就直接再查看k+1条边。这个过程一个进行到只剩下一个连通分支时为止。 </p>
</li>
</ul>
<p>此时，已构成G的一棵最小生成树。</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
using namespace std;

#define maxn 110    //最多点个数
int n, m;   //点个数，边数
int parent[maxn];   //父亲节点，当值为-1时表示根节点
int ans;    //存放最小生成树权值
struct eage     //边的结构体，u、v为两端点，w为边权值
{
    int u, v, w;
}EG[5010];

bool cmp(eage a, eage b)    //排序调用
{
    return a.w &lt; b.w;
}

int Find(int x)     //寻找根节点，判断是否在同一棵树中的依据
{
    if(parent[x] == -1) return x;
    return Find(parent[x]);
}

void Kruskal()      //Kruskal算法，parent能够还原一棵生成树，或者森林
{
    memset(parent, -1, sizeof(parent));
    sort(EG+1, EG+m+1, cmp);    //按权值将边从小到大排序
    ans = 0;
    for(int i = 1; i &lt;= m; i++)     //按权值从小到大选择边
    {
        int t1 = Find(EG[i].u), t2 = Find(EG[i].v);
        if(t1 != t2)    //若不在同一棵树种则选择该边，合并两棵树
        {
            ans += EG[i].w;
            parent[t1] = t2;
        }
    }
}
</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>当图的边数为e时，Kruskal算法所需的时间是O(eloge).</p>
<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>设G = (V,E)是连通带权图，V = {1,2,…,n}。构造G的最小生成树,Prim算法的基本思想是：首先置S =<br>{1}，然后，只要S是V的真子集，就进行如下的贪心选择：选取满足条件i ∈S,j ∈V –<br>S,且c[i][j]最小的边，将顶点j添加到S中。这个过程一直进行到S = V时为止。在这个过程中选取到的所有边恰好构成G的一棵最小生成树。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>/* Prim算法生成最小生成树  */
void MiniSpanTree_Prim(MGraph MG)
{
    int min, i, j, k;
    int adjvex[MAXVEX];/* 保存相关顶点的父亲节点 */
    int lowcost[MAXVEX];/* 保存相关顶点间边的权值 */
    lowcost[0] = 0;/* 初始化第一个权值为0，即v0加入生成树 */
    /* lowcost的值为0，在这里就是此下标的顶点已经加入生成树 */
    adjvex[0] = 0;/* 初始化第一个顶点下标为0 */
    cout &lt;&lt; &quot;最小生成树的边为：&quot; &lt;&lt; endl;
    for (i = 1; i &lt; MG.numVertexes; i++)
    {
        lowcost[i] = MG.arc[0][i];/* 将v0顶点与之有边的权值存入数组 */
        adjvex[i] = 0;/* 初始化都为v0的下标 */
    }

    for (i = 1; i &lt; MG.numVertexes; i++)
    {
        min = INFINITY; /* 初始化最小权值为∞， */

        j = 1;
        k = 0;

        while (j &lt; MG.numVertexes)/* 循环全部顶点 */
        {
            if (lowcost[j] != 0 &amp;&amp; lowcost[j] &lt; min)/* 如果权值不为0且权值小于min */
            {
                min = lowcost[j];/* 则让当前权值成为最小值 */
                k = j;/* 将当前最小值的下标存入k */
            }

            j++;
        }

        cout &lt;&lt; &quot;(&quot; &lt;&lt; adjvex[k] &lt;&lt; &quot;, &quot; &lt;&lt; k &lt;&lt; &quot;)&quot; &lt;&lt; &quot;  &quot;; /* 打印当前顶点边中权值最小的边 */
        lowcost[k] = 0;/* 将当前顶点的权值设置为0,表示此顶点已经完成任务 */

        for (j = 1; j &lt; MG.numVertexes; j++)/* 循环所有顶点 */
        {
            /* 如果下标为k顶点各边权值小于此前这些顶点未被加入生成树权值 */
            if (lowcost[j] != 0 &amp;&amp; MG.arc[k][j] &lt; lowcost[j])
            {
                lowcost[j] = MG.arc[k][j];/* 将较小的权值存入lowcost相应位置 */
                adjvex[j] = k;/* 将k设为下标j的父亲节点 */
            }
        }
    }
    cout &lt;&lt; endl;
}
</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>此算法的时间复杂度为O(n^2)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当e = Ω(n^2)时，Kruskal算法比Prim算法差；<br>但当e = o(n^2)时，Kruskal算法比Prim算法好得多。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">118</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
