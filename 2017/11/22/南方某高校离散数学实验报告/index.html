<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="实验一：专业论文阅读论文的基本信息论文题目与来源论文的题目为“An Implementation of the Behavior Annex in the AADL-toolsetOsate2”，发表在2011年4月的Software Engineering Institute | Carnegie MellonUniversity期刊（或会议录），引用格式为：Lasnier G, Pautet">
<meta property="og:type" content="article">
<meta property="og:title" content="南方某高校离散数学实验报告">
<meta property="og:url" content="http://www.mashangxue123.com/2017/11/22/南方某高校离散数学实验报告/index.html">
<meta property="og:site_name" content="DmrfCoder的个人主页">
<meta property="og:description" content="实验一：专业论文阅读论文的基本信息论文题目与来源论文的题目为“An Implementation of the Behavior Annex in the AADL-toolsetOsate2”，发表在2011年4月的Software Engineering Institute | Carnegie MellonUniversity期刊（或会议录），引用格式为：Lasnier G, Pautet">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121202535883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121202554532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121202612093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121192940083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121193020815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121194305749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121194358373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121200933961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121201014012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121200834668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121201152310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121192940083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121193020815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121193059596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-
blog.csdn.net/20171121193121057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2018-12-05T14:40:15.845Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="南方某高校离散数学实验报告">
<meta name="twitter:description" content="实验一：专业论文阅读论文的基本信息论文题目与来源论文的题目为“An Implementation of the Behavior Annex in the AADL-toolsetOsate2”，发表在2011年4月的Software Engineering Institute | Carnegie MellonUniversity期刊（或会议录），引用格式为：Lasnier G, Pautet">
<meta name="twitter:image" content="https://img-
blog.csdn.net/20171121202535883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mashangxue123.com/2017/11/22/南方某高校离散数学实验报告/">





  <title>南方某高校离散数学实验报告 | DmrfCoder的个人主页</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DmrfCoder的个人主页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mashangxue123.com/2017/11/22/南方某高校离散数学实验报告/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DmrfCoder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DmrfCoder的个人主页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">南方某高校离散数学实验报告</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-22T22:42:48+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="实验一：专业论文阅读"><a href="#实验一：专业论文阅读" class="headerlink" title="实验一：专业论文阅读"></a>实验一：专业论文阅读</h2><h3 id="论文的基本信息"><a href="#论文的基本信息" class="headerlink" title="论文的基本信息"></a>论文的基本信息</h3><h4 id="论文题目与来源"><a href="#论文题目与来源" class="headerlink" title="论文题目与来源"></a>论文题目与来源</h4><p>论文的题目为“An Implementation of the Behavior Annex in the AADL-toolset<br>Osate2”，发表在2011年4月的Software Engineering Institute | Carnegie Mellon<br>University期刊（或会议录），引用格式为：Lasnier G, Pautet L, Hugues J, et al. An<br>Implementation of the Behavior Annex in the AADL-Toolset Osate2[C]// IEEE<br>International Conference on Engineering of Complex Computer Systems. IEEE,<br>2011:332-337.</p>
<h4 id="论文作者信息"><a href="#论文作者信息" class="headerlink" title="论文作者信息"></a>论文作者信息</h4><h5 id="论文的主要作者："><a href="#论文的主要作者：" class="headerlink" title="论文的主要作者："></a>论文的主要作者：</h5><p>Gilles Lasnier, Laurent PautetInst. TELECOM - TELECOM ParisTech – LTCI Paris,<br>F-75634 CEDEX 13, France Email: <a href="mailto:{firstname.lastname}@telecom-paristech.fr" target="_blank" rel="noopener">{firstname.lastname}@telecom-paristech.fr</a><br>Jérôme Hugues ISAE - Toulouse University Toulouse, 31056, France Email:<br><a href="mailto:jerome.hugues@isae.fr" target="_blank" rel="noopener">jerome.hugues@isae.fr</a><br>Lutz Wrage SEI - Carnegie Mellon University Pittsburgh, PA, 15213, USA Email:<br><a href="mailto:lwrage@sei.cmu.edu" target="_blank" rel="noopener">lwrage@sei.cmu.edu</a></p>
<h3 id="论文的主要内容"><a href="#论文的主要内容" class="headerlink" title="论文的主要内容"></a>论文的主要内容</h3><h4 id="论文摘要"><a href="#论文摘要" class="headerlink" title="论文摘要"></a>论文摘要</h4><h5 id="论文的研究背景："><a href="#论文的研究背景：" class="headerlink" title="论文的研究背景："></a>论文的研究背景：</h5><p>Abstract-AADL是一种用于设计和分析高分辨率分布式和实时系统的建模语言。 作为AADL的拓展分支，该建模语言扩展了AADL模型以加强其分析功能。<br>其指定了AADL应用程序模型的行为。 因此，本附件的植入允许执行行为分析。 另外，由于有几个AADL的拓展，实施通用机制来支持其中的每一个都是具有挑战性的。</p>
<h5 id="要解决的问题："><a href="#要解决的问题：" class="headerlink" title="要解决的问题："></a>要解决的问题：</h5><p>1）解析和分析几个AADL的子语言。<br>2）对不同的AST生产需要连接进行分析。<br>3）完成分析，要求确保与核心语言的一致性。</p>
<h5 id="主要采用的方法："><a href="#主要采用的方法：" class="headerlink" title="主要采用的方法："></a>主要采用的方法：</h5><p>开发了一个可扩展的开源平台AADL工具集OSATE2，它包括AADL前端，架构分析功能和扩展机制，将外部后端作为插件进行集成。</p>
<h5 id="得到的研究结果："><a href="#得到的研究结果：" class="headerlink" title="得到的研究结果："></a>得到的研究结果：</h5><p>通过重用多个OSATE2模块来驱动AADL-BA元素进而完成了对AADL模型的分析，开发出了新的编译器插件。</p>
<h3 id="论文主体内容"><a href="#论文主体内容" class="headerlink" title="论文主体内容"></a>论文主体内容</h3><h4 id="论文对问题的描述："><a href="#论文对问题的描述：" class="headerlink" title="论文对问题的描述："></a>论文对问题的描述：</h4><p>Abstract-AADL是一种用于设计和分析高分辨率分布式和实时系统的建模语言。<br>作为AADL附件出版的嵌入式子语言扩展了AADL模型以加强分析。但是，由于有几个AADL附件，实施通用机制来支持其中的每一个都是具有挑战性的。</p>
<h4 id="论文解决问题的步骤："><a href="#论文解决问题的步骤：" class="headerlink" title="论文解决问题的步骤："></a>论文解决问题的步骤：</h4><p>1：将AADLBA编译器作为集成；<br>2：实现OSATE2的ECLIPSE插件；<br>3：将AADL-BA元模型作为构建编译器的几个模块的骨干分支。</p>
<h4 id="论文结果的体现方式："><a href="#论文结果的体现方式：" class="headerlink" title="论文结果的体现方式："></a>论文结果的体现方式：</h4><p>通过展示了研究人员如何使用AADL-BA模型来开发编译器的几个模块来说明研究结果。<br>具体产品为OSATE2，这是一个提供了AADL前端和附件的插件，驱动行为附件分析（解析器+分析器）。用于定义AADL和AADL-<br>BA元模型的相同技术，可轻松跨两个元模型的导航，以及生成独特的持久XMI表示（AADL模型+行为元素），有助于将其用作外部后台的输入。<br>论文的创新点：<br>通过以一个可拓展的开源平台AADL工具集OSATE2为基础，将前后端结合起来对问题进行研究和实验，而不是局限于传统的分析方法。</p>
<h4 id="相关工作和展望"><a href="#相关工作和展望" class="headerlink" title="相关工作和展望"></a>相关工作和展望</h4><h5 id="论文的相关工作："><a href="#论文的相关工作：" class="headerlink" title="论文的相关工作："></a>论文的相关工作：</h5><p>为了研究的需要开发了一个可扩展的开源平台AADL工具集OSATE2，它包括AADL前端，架构分析功能和扩展机制，将外部后端作为插件进行集成。</p>
<h5 id="下一步工作："><a href="#下一步工作：" class="headerlink" title="下一步工作："></a>下一步工作：</h5><p>通过外部后端的集成来分析行为自动机属性，例如作为模型检查器来验证死锁和基于模型的工具，以通过改进WCET估计和阻止共享资源的时间来增强调度分析。</p>
<h2 id="实验二：构造命题逻辑合式公式的真值表"><a href="#实验二：构造命题逻辑合式公式的真值表" class="headerlink" title="实验二：构造命题逻辑合式公式的真值表"></a>实验二：构造命题逻辑合式公式的真值表</h2><h3 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>根据用户输入的命题公式以及指定的分量的真值得出对应命题公式的真假值。</p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑环境"><a href="#电脑环境" class="headerlink" title="电脑环境"></a>电脑环境</h4><p>系统：Ubuntu16.04LTS（Linux 4.10.0-37-generic x86_64）<br>处理器：Intel® Pentium(R) CPU N3700 @ 1.60GHz × 4<br>内存：7.7 GiB<br>操作系统类型：64位操作系统<br>图形：GeForce 920M/PCIe/SSE2</p>
<h4 id="编译运行环境"><a href="#编译运行环境" class="headerlink" title="编译运行环境"></a>编译运行环境</h4><p>CLion2017.2.3</p>
<h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><p>C/C++语言</p>
<h3 id="实验算法"><a href="#实验算法" class="headerlink" title="实验算法"></a>实验算法</h3><h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><p>本实验中主要使用C++中的map和string数据结构对数据进行处理，具体使用示例如下：</p>
<h5 id="对真值的存储"><a href="#对真值的存储" class="headerlink" title="对真值的存储"></a>对真值的存储</h5><p>考虑到合式公式的真值是和字符/字符串一一对应的，而真值为int（0或1），所以本实验使用map将合式公式和真值作为键值对存储到map中，事实证明这种数据处理方式取得了较为高效的数据存储效果。</p>
<h5 id="对合式公式的存储"><a href="#对合式公式的存储" class="headerlink" title="对合式公式的存储"></a>对合式公式的存储</h5><p>考虑到合式公式的不规则性以及在计算过程中需要频繁移动“指针”的位置，所以本实验使用string数据类型来存储要处理的合式公式，主要应用string的const_iterator对合式公式进行高效率的操作。<br>2）算法描述（包含输入输出说明）<br>本实验的主要算法思路是将需要判断真值的合式公式分解为小的合式公式“分而治之”，以括号为划分界限，计算出括号内”小的“合式公式的真值后再对总的合式公式进行真值判断。</p>
<h4 id="输入说明"><a href="#输入说明" class="headerlink" title="输入说明"></a>输入说明</h4><p>输入合式公式时考虑到电脑输入字符的限制性，规定用！表示 否定 ， 用&amp; 表示 合取 ， 用| 表示 析取</p>
<h4 id="输出说明"><a href="#输出说明" class="headerlink" title="输出说明"></a>输出说明</h4><p>本实验将会输出用户输入的总合式公式的真值，0代表”假“，1代表”真“。</p>
<h4 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h4><p><img src="https://img-
blog.csdn.net/20171121202535883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="运行界面"><a href="#运行界面" class="headerlink" title="运行界面"></a>运行界面</h4><p><img src="https://img-
blog.csdn.net/20171121202554532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://img-
blog.csdn.net/20171121202612093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="实验优点分析："><a href="#实验优点分析：" class="headerlink" title="实验优点分析："></a>实验优点分析：</h4><p>1：在求解较为复杂的合式公式的真值时采用”分而治之“的思想，将复杂的合式公式分解为多个简单的合式公式今进而求解，事实证明这种解决问题的思想起到了较为理想的效果。<br>2：在进行具体的计算时可以充分利用C++语言的特性，巧妙地使用了C++中的map和string数据结构，达到了事半功倍的效果。</p>
<h4 id="实验不足分析："><a href="#实验不足分析：" class="headerlink" title="实验不足分析："></a>实验不足分析：</h4><p>1：未能将完整合式公式的各个分部分的真值也列出来<br>2：未能实现图形界面从而增强用户人机交互的体验感</p>
<h4 id="实验不足的改进方案："><a href="#实验不足的改进方案：" class="headerlink" title="实验不足的改进方案："></a>实验不足的改进方案：</h4><p>1：在对总的合式公式尽情求解时另外再使用一张map存储括号内的合式公式及其真值，但是要注意的是在存储时要特别处理”！“<br>2：可以通过C++实现底层算法、java实现图形界面的方法实现本实验的图形界面，即在本实验C++代码的基础上做一个套壳封装</p>
<h3 id="实验源码"><a href="#实验源码" class="headerlink" title="实验源码"></a>实验源码</h3><p>部分核心代码如下</p>
<h4 id="扫描括号并进行计算的方法（函数）："><a href="#扫描括号并进行计算的方法（函数）：" class="headerlink" title="扫描括号并进行计算的方法（函数）："></a>扫描括号并进行计算的方法（函数）：</h4><pre><code>int run_expr(string &amp;Expr) { //扫描括号
    int sum_kh = 0;//括号数
    string::const_iterator iter;
    string::const_iterator addr_kh[50];//用于记录括号的位置
    char kind_kh[50];//用于记录括号的类型
    for (iter = Expr.begin();
         iter != Expr.end(); iter++) {
        if (*iter == &apos;(&apos; || *iter == &apos;)&apos;) {
            addr_kh[sum_kh] = iter;
            kind_kh[sum_kh] = *iter;
            sum_kh++;
        }
    }
    if (0 == sum_kh)//如果没有括号
    {
        value = run_unkh_expr(Expr);
        return value;
    } else {
        int i = 0;
        for (; i &lt;= sum_kh; i++) {
            if (kind_kh[i] == &apos;)&apos;)//找到最内级的括号并跳出循环
                break;
        } //取出最内层没有括号的字符串
        string in_str = string(addr_kh[i - 1] + 1, addr_kh[i]); //算出最内层表达式的值
       //((!p&amp;q)|(p|q))&amp;(p|v)
        value = run_unkh_expr(in_str);
        v_map[in_str] = value;


        static char var = &apos;1&apos;;
        value_map[var] = value;//将括号整体设为一个字符‘1’
        string::const_iterator ite = addr_kh[i - 1];//&quot;字符(的位置&quot; //判断（是不是表达式的开头
        string::const_iterator init_i;
        bool is_begin = false;
        if (ite == expr.begin()) { is_begin = true; }
        else { init_i = addr_kh[i - 1] - 1; }
        {
            expr.erase(ite, addr_kh[i] + 1);//删除掉最内层表达式包括括号在内
        }   //再在删除的地方插入新的字符‘1’作为标记


        if (is_begin == true) { expr = var + expr; }
        else { expr.insert(init_i + 1, var); }
        var = var + 1;
        value = run_expr(expr);
        return value;
    }
} //求主析取范式和主合取范式的函数
</code></pre><h4 id="处理具体合式关系的方法（函数）："><a href="#处理具体合式关系的方法（函数）：" class="headerlink" title="处理具体合式关系的方法（函数）："></a>处理具体合式关系的方法（函数）：</h4><pre><code>int deal_cal(int par1, char par2,
             int par3) {

    switch (par2) {
        case &apos;&amp;&apos;://合取
            return par1 &amp;&amp; par3;

        case &apos;|&apos;://析取
            return par1 || par3;

        default:
            cout &lt;&lt; &quot;有某些命题的真值错误&quot; &lt;&lt; endl;
            break;
    }
}
</code></pre><h4 id="具体项目见："><a href="#具体项目见：" class="headerlink" title="具体项目见："></a>具体项目见：</h4><p><a href="https://github.com/DMRFWIN/-DiscreteMathematicsExperiment_TruthTable.git" target="_blank" rel="noopener"> https://github.com/DMRFWIN/-DiscreteMathematicsExperiment_TruthTable.git
</a></p>
<h2 id="实验三：TSP问题求解（图形界面版）"><a href="#实验三：TSP问题求解（图形界面版）" class="headerlink" title="实验三：TSP问题求解（图形界面版）"></a>实验三：TSP问题求解（图形界面版）</h2><h3 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h3><p>TSP问题求解</p>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑环境-1"><a href="#电脑环境-1" class="headerlink" title="电脑环境"></a>电脑环境</h4><p>系统：Ubuntu16.04LTS（Linux 4.10.0-37-generic x86_64）<br>处理器：Intel® Pentium(R) CPU N3700 @ 1.60GHz × 4<br>内存：7.7 GiB<br>操作系统类型：64位操作系统<br>图形：GeForce 920M/PCIe/SSE2</p>
<h4 id="编译运行环境-1"><a href="#编译运行环境-1" class="headerlink" title="编译运行环境"></a>编译运行环境</h4><p>Intellij IDEA Community</p>
<h4 id="编程语言-1"><a href="#编程语言-1" class="headerlink" title="编程语言"></a>编程语言</h4><p>JAVA语言</p>
<h3 id="实验算法-1"><a href="#实验算法-1" class="headerlink" title="实验算法"></a>实验算法</h3><h4 id="数据结构定义-1"><a href="#数据结构定义-1" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><p>本实验中用到了java中较为经典的MAP、LIST等数据结构。</p>
<h4 id="算法1描述（包含输入输出说明）"><a href="#算法1描述（包含输入输出说明）" class="headerlink" title="算法1描述（包含输入输出说明）"></a>算法1描述（包含输入输出说明）</h4><h5 id="算法思想描述"><a href="#算法思想描述" class="headerlink" title="算法思想描述"></a>算法思想描述</h5><p>a.从某一个城市开始，每次选择一个城市，直到所有的城市被走完。<br>b.每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h5><p>输入数据可以选择手动输入，也可选择从软件运行的本机中选择数据文件导入计算。</p>
<h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为两张表，一张为输入数据组成的数据表，另一张为最短路径经过的城市的代号构成的输出表，在表的末尾会输出对应算法计算的最短路径值。</p>
<h5 id="算法1流程图"><a href="#算法1流程图" class="headerlink" title="算法1流程图"></a>算法1流程图</h5><p><img src="https://img-
blog.csdn.net/20171121192940083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="算法2描述"><a href="#算法2描述" class="headerlink" title="算法2描述"></a>算法2描述</h4><p>算法2使用的是回溯法（试探法）：</p>
<h5 id="回溯法描述"><a href="#回溯法描述" class="headerlink" title="回溯法描述"></a>回溯法描述</h5><p>从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<h5 id="用回溯算法解决问题的一般步骤为："><a href="#用回溯算法解决问题的一般步骤为：" class="headerlink" title="用回溯算法解决问题的一般步骤为："></a>用回溯算法解决问题的一般步骤为：</h5><p>1、定义一个解空间，它包含问题的解。<br>2、利用适于搜索的方法组织解空间。<br>3、利用深度优先法搜索解空间。<br>4、利用限界函数避免移动到不可能产生解的子空间。</p>
<h5 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h5><p>输入数据可以选择手动输入，也可选择从软件运行的本机中选择数据文件导入计算。</p>
<h5 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为两张表，一张为输入数据组成的数据表，另一张为最短路径经过的城市的代号构成的输出表，在表的末尾会输出对应算法计算的最短路径值。####算法2流程图<br><img src="https://img-
blog.csdn.net/20171121193020815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验结果-1"><a href="#实验结果-1" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="运行界面-1"><a href="#运行界面-1" class="headerlink" title="运行界面"></a>运行界面</h4><p>数据源选择界面：<br><img src="https://img-
blog.csdn.net/20171121194305749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>手动输入数据界面：<br><img src="https://img-
blog.csdn.net/20171121194358373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从本机选择数据文件界面：<br><img src="https://img-
blog.csdn.net/20171121200933961?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br><img src="https://img-
blog.csdn.net/20171121201014012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="运行结果截图"><a href="#运行结果截图" class="headerlink" title="运行结果截图"></a>运行结果截图</h4><p>手动输入界面测试运行结果：<br><img src="https://img-
blog.csdn.net/20171121200834668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>从本机选择文件测试结果：<br><img src="https://img-
blog.csdn.net/20171121201152310?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h3><h4 id="核心算法代码"><a href="#核心算法代码" class="headerlink" title="核心算法代码"></a>核心算法代码</h4><h5 id="回溯法："><a href="#回溯法：" class="headerlink" title="回溯法："></a>回溯法：</h5><pre><code>package Algorithm;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class Back {
    private int distance[][];
    private int x[];
    private int b[];
    private int cl = 0;
    private int k = 10000;


    private int cityNum;

    public Back() {
    }

    public Map&lt;String, String&gt; GetMinRoadByBack(Map&lt;String, Integer&gt; roadBeans, String str_num) {
        InitData(roadBeans, str_num);

        int i;

        Traveling(2);

        b[cityNum] = b[0];

        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();
        result.put(&quot;result_road&quot;, Arrays.toString(b));
        result.put(&quot;result_value&quot;, String.valueOf(k));

        return result;
    }

    private void Traveling(int t) {
        int j;
        if (t &gt; cityNum) {
            if (distance[x[cityNum]][1] != -1 &amp;&amp; (cl + distance[x[cityNum]][1] &lt; k)) {
                for (j = 1; j &lt;= cityNum; j++)
                    b[j - 1] = x[j];
                k = cl + distance[x[cityNum]][1];
            }
        } else {
            for (j = t; j &lt;= cityNum; j++) {
                if (distance[x[t - 1]][x[j]] != -1 &amp;&amp; (cl + distance[x[t - 1]][x[j]] &lt; k)) {

                    int p = x[t];
                    x[t] = x[j];
                    x[j] = p;

                    cl += distance[x[t - 1]][x[t]];
                    Traveling(t + 1);
                    cl -= distance[x[t - 1]][x[t]];

                    p = x[t];
                    x[t] = x[j];
                    x[j] = p;
                }
            }
        }
    }


    private void InitData(Map&lt;String, Integer&gt; roadBeans, String str_num) {

        cityNum = str_num.length();
        distance = new int[cityNum + 1][cityNum + 1];
        x = new int[cityNum + 1];
        b = new int[cityNum + 1];

        for (int i = 1; i &lt;= cityNum; i++) {
            x[i] = i;
            b[i] = 0;
        }


        for (Map.Entry&lt;String, Integer&gt; entry : roadBeans.entrySet()) {

            String s = entry.getKey();
            String[] split = s.split(&quot;,&quot;);
            int a = Integer.parseInt(split[0]);
            int b = Integer.parseInt(split[1]);

            int length = entry.getValue();


            distance[a][b] = length;
        }
    }
}
</code></pre><h5 id="贪心法："><a href="#贪心法：" class="headerlink" title="贪心法："></a>贪心法：</h5><pre><code>package Algorithm;

import Bean.RoadBean;


import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

public class Greedy {


    private Map&lt;RoadBean, Double&gt; roadBeanst;

    private int cityNum; // 城市数量
    private int[][] distance; // 距离矩阵
    private Double[][] distance2;

    private int[] colable;//代表列，也表示是否走过，走过置0
    private int[] row;//代表行，选过置0


    public Map&lt;String, String&gt; GetMinRoadByTx(Map&lt;String, Integer&gt; roadBeans, String str_num) {

        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();

        InitData(roadBeans, str_num);

        int[] temp = new int[cityNum];
        int[] path = new int[cityNum + 1];
        int path_num = 0;
        path[path_num++] = 1;


        int s = 0;//计算距离
        int i = 0;//当前节点
        int j = 0;//下一个节点
        //默认从0开始
        while (row[i] == 1) {
            //复制一行
            for (int k = 0; k &lt; cityNum; k++) {
                temp[k] = distance[i][k];
                //System.out.print(temp[k]+&quot; &quot;);
            }
            //System.out.println();
            //选择下一个节点，要求不是已经走过，并且与i不同
            j = selectmin(temp);
            //找出下一节点
            row[i] = 0;//行置0，表示已经选过
            colable[j] = 0;//列0，表示已经走过

            path[path_num++] = j + 1;
            //System.out.println(i + &quot;--&gt;&quot; + j);
            //System.out.println(distance[i][j]);
            if (distance[i][j] == 0) {
                s += distance[j][i];
            } else {
                s += distance[i][j];
            }

            i = j;//当前节点指向下一节点
        }

        result.put(&quot;result_road&quot;, Arrays.toString(path));
        result.put(&quot;result_value&quot;, String.valueOf(s));

        return result;
    }


    public int selectmin(int[] p) {
        int j = 0, m = p[0], k = 0;
        //寻找第一个可用节点，注意最后一次寻找，没有可用节点
        while (colable[j] == 0) {
            j++;
            //System.out.print(j+&quot; &quot;);
            if (j &gt;= cityNum) {
                //没有可用节点，说明已结束，最后一次为 *--&gt;0
                m = p[0];
                break;
                //或者直接return 0;
            } else {
                m = p[j];
            }
        }
        //从可用节点J开始往后扫描，找出距离最小节点
        for (; j &lt; cityNum; j++) {
            if (colable[j] == 1) {
                if (m &gt;= p[j]) {
                    m = p[j];
                    k = j;
                }
            }
        }
        return k;
    }


    private void InitData(Map&lt;String, Integer&gt; roadBeans, String str_num) {

        cityNum = str_num.length();

        distance = new int[cityNum][cityNum];

        colable = new int[cityNum];
        colable[0] = 0;
        for (int i = 1; i &lt; cityNum; i++) {
            colable[i] = 1;
        }

        row = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) {
            row[i] = 1;
        }

        for (Map.Entry&lt;String, Integer&gt; entry : roadBeans.entrySet()) {

            String s = entry.getKey();
            String[] split = s.split(&quot;,&quot;);
            int a = Integer.parseInt(split[0]);
            int b = Integer.parseInt(split[1]);

            int length = entry.getValue();

            a--;
            b--;

            distance[a][b] = length;
        }
    }

    public Map&lt;String, String&gt; GetMinRoadByTx(Map&lt;String, Double&gt; stringDoubleMap, int citynum) {
        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();
        this.cityNum = citynum;
        InitData(stringDoubleMap);


        Double[] temp = new Double[cityNum];

        for (int i = 0; i &lt; cityNum; i++) {
            temp[i] = 0.0;
        }
        int[] path = new int[cityNum + 1];
        int path_num = 0;
        path[path_num++] = 1;


        Double s = 0.0;//计算距离
        int i = 0;//当前节点
        int j = 0;//下一个节点
        //默认从0开始
        while (row[i] == 1) {
            //复制一行
            for (int k = 0; k &lt; cityNum; k++) {
                temp[k] = distance2[i][k];
                //System.out.print(temp[k]+&quot; &quot;);
            }
            //System.out.println();
            //选择下一个节点，要求不是已经走过，并且与i不同
            j = selectmin(temp);
            //找出下一节点
            row[i] = 0;//行置0，表示已经选过
            colable[j] = 0;//列0，表示已经走过

            path[path_num++] = j + 1;
            //System.out.println(i + &quot;--&gt;&quot; + j);
            //System.out.println(distance[i][j]);
            if (distance2[i][j] == 0) {
                s += distance2[j][i];
            } else {
                s += distance2[i][j];
            }

            i = j;//当前节点指向下一节点
        }

        result.put(&quot;result_road&quot;, Arrays.toString(path));
        result.put(&quot;result_value&quot;, String.valueOf(s));

        return result;

    }

    private int selectmin(Double[] p) {
        int j = 0, k = 0;
        Double m = p[0];
        //寻找第一个可用节点，注意最后一次寻找，没有可用节点
        while (colable[j] == 0) {
            j++;
            //System.out.print(j+&quot; &quot;);
            if (j &gt;= cityNum) {
                //没有可用节点，说明已结束，最后一次为 *--&gt;0
                m = p[0];
                break;
                //或者直接return 0;
            } else {
                m = p[j];
            }
        }
        //从可用节点J开始往后扫描，找出距离最小节点
        for (; j &lt; cityNum; j++) {
            if (colable[j] == 1) {
                if (m &gt;= p[j]) {
                    m = p[j];
                    k = j;
                }
            }
        }
        return k;
    }

    private void InitData(Map&lt;String, Double&gt; stringDoubleMap) {


        distance2 = new Double[cityNum][cityNum];

        colable = new int[cityNum];
        colable[0] = 0;
        for (int i = 1; i &lt; cityNum; i++) {
            colable[i] = 1;
        }

        row = new int[cityNum];
        for (int i = 0; i &lt; cityNum; i++) {
            row[i] = 1;
        }

        for (Map.Entry&lt;String, Double&gt; entry : stringDoubleMap.entrySet()) {

            String s = entry.getKey();
            String[] split = s.split(&quot;,&quot;);
            int a = Integer.parseInt(split[0]);
            int b = Integer.parseInt(split[1]);

            Double length = entry.getValue();
            a--;
            b--;


            distance2[a][b] = length;
        }

    }
}
</code></pre><h4 id="具体代码见："><a href="#具体代码见：" class="headerlink" title="具体代码见："></a>具体代码见：</h4><p><a href="https://github.com/DMRFWIN/DiscreteMathematicsExperiment_TSP_Javaversion" target="_blank" rel="noopener"> java图形界面版TSP问题求解源码
</a></p>
<h2 id="实验三：TSP问题求解（没有图形界面的黑框框版）"><a href="#实验三：TSP问题求解（没有图形界面的黑框框版）" class="headerlink" title="实验三：TSP问题求解（没有图形界面的黑框框版）"></a>实验三：TSP问题求解（没有图形界面的黑框框版）</h2><h3 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h3><p>TSP问题求解</p>
<h3 id="实验环境-2"><a href="#实验环境-2" class="headerlink" title="实验环境"></a>实验环境</h3><h4 id="电脑环境-2"><a href="#电脑环境-2" class="headerlink" title="电脑环境"></a>电脑环境</h4><p>系统：Ubuntu16.04LTS（Linux 4.10.0-37-generic x86_64）<br>处理器：Intel® Pentium(R) CPU N3700 @ 1.60GHz × 4<br>内存：7.7 GiB<br>操作系统类型：64位操作系统<br>图形：GeForce 920M/PCIe/SSE2</p>
<h4 id="编译运行环境-2"><a href="#编译运行环境-2" class="headerlink" title="编译运行环境"></a>编译运行环境</h4><p>CLion2017.2.3</p>
<h4 id="编程语言-2"><a href="#编程语言-2" class="headerlink" title="编程语言"></a>编程语言</h4><p>C/C++语言</p>
<h3 id="实验算法-2"><a href="#实验算法-2" class="headerlink" title="实验算法"></a>实验算法</h3><h4 id="数据结构定义-2"><a href="#数据结构定义-2" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><p>本实验考虑到所要处理的城市数量不会太多，所以使用比较简单易懂的矩阵（二维数组）来存储图，即S[a][b]=c表示城市a和城市b之间的距离为c。</p>
<h4 id="算法1描述（包含输入输出说明）-1"><a href="#算法1描述（包含输入输出说明）-1" class="headerlink" title="算法1描述（包含输入输出说明）"></a>算法1描述（包含输入输出说明）</h4><p>算法1采用的是贪心算法</p>
<h5 id="算法思想描述-1"><a href="#算法思想描述-1" class="headerlink" title="算法思想描述"></a>算法思想描述</h5><p>a.从某一个城市开始，每次选择一个城市，直到所有的城市被走完。<br>b.每次在选择下一个城市的时候，只考虑当前情况，保证迄今为止经过的路径总距离最小。</p>
<h5 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h5><p>输入时根据提示前两行输入城市数量n和道路数量m，接下来m行，每行3个数，表示m条道路的起点终点以及权重。</p>
<h5 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为2行，第一行为该算法求解的经过路径，格式为“a–&gt;b–&gt;c–&gt;d–&gt;a”，第二行为使用此种走法的最短路径值。</p>
<h5 id="算法1流程图-1"><a href="#算法1流程图-1" class="headerlink" title="算法1流程图"></a>算法1流程图</h5><p><img src="https://img-
blog.csdn.net/20171121192940083?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="算法2描述-1"><a href="#算法2描述-1" class="headerlink" title="算法2描述"></a>算法2描述</h4><p>算法2使用的是回溯法（试探法）：</p>
<h5 id="回溯法描述-1"><a href="#回溯法描述-1" class="headerlink" title="回溯法描述"></a>回溯法描述</h5><p>从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p>
<h5 id="用回溯算法解决问题的一般步骤为：-1"><a href="#用回溯算法解决问题的一般步骤为：-1" class="headerlink" title="用回溯算法解决问题的一般步骤为："></a>用回溯算法解决问题的一般步骤为：</h5><p>1、定义一个解空间，它包含问题的解。<br>2、利用适于搜索的方法组织解空间。<br>3、利用深度优先法搜索解空间。<br>4、利用限界函数避免移动到不可能产生解的子空间。</p>
<h5 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h5><p>输入时根据提示前两行输入城市数量n和道路数量m，接下来m行，每行3个数，表示m条道路的起点终点以及权重。</p>
<h5 id="输出描述-3"><a href="#输出描述-3" class="headerlink" title="输出描述"></a>输出描述</h5><p>输出为2行，第一行为该算法求解的经过路径，格式为“a–&gt;b–&gt;c–&gt;d–&gt;a”，第二行为使用此种走法的最短路径值。</p>
<h4 id="算法2流程图"><a href="#算法2流程图" class="headerlink" title="算法2流程图"></a>算法2流程图</h4><p><img src="https://img-
blog.csdn.net/20171121193020815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="实验结果-2"><a href="#实验结果-2" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="运行界面-2"><a href="#运行界面-2" class="headerlink" title="运行界面"></a>运行界面</h4><p><img src="https://img-
blog.csdn.net/20171121193059596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h4 id="运行结果截图-1"><a href="#运行结果截图-1" class="headerlink" title="运行结果截图"></a>运行结果截图</h4><p><img src="https://img-
blog.csdn.net/20171121193121057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY5ODIxNjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h3 id="项目代码-1"><a href="#项目代码-1" class="headerlink" title="项目代码"></a>项目代码</h3><h4 id="核心算法代码-1"><a href="#核心算法代码-1" class="headerlink" title="核心算法代码"></a>核心算法代码</h4><h5 id="回溯法：-1"><a href="#回溯法：-1" class="headerlink" title="回溯法："></a>回溯法：</h5><pre><code>void GetMinRoadByHs() {
    int i;
    for (i = 1; i &lt;= n; i++) {
        x[i] = i;
        b[i] = 0;
    }
    Traveling(2);
    cout &lt;&lt; &quot;城市路线：&quot; &lt;&lt; endl;
    for (i = 1; i &lt;= n; i++)
        cout &lt;&lt; b[i] &lt;&lt; &quot;--&gt;&quot;;
    cout &lt;&lt; b[1];
    cout &lt;&lt; endl;
    cout &lt;&lt; &quot;最短路线长度：&quot; &lt;&lt; endl;
    cout &lt;&lt; k &lt;&lt; endl;
}

void Traveling(int t) {
    int j;
    if (t &gt; n) {
        if (g[x[n]][1] != -1 &amp;&amp; (cl + g[x[n]][1] &lt; k)) {
            for (j = 1; j &lt;= n; j++)
                b[j] = x[j];
            k = cl + g[x[n]][1];
        }
    } else {
        for (j = t; j &lt;= n; j++) {
            if (g[x[t - 1]][x[j]] != -1 &amp;&amp; (cl + g[x[t - 1]][x[j]] &lt; k)) {
                swap(x[t], x[j]);
                cl += g[x[t - 1]][x[t]];
                Traveling(t + 1);
                cl -= g[x[t - 1]][x[t]];
                swap(x[t], x[j]);
            }
        }
    }
}
</code></pre><h5 id="贪心法：-1"><a href="#贪心法：-1" class="headerlink" title="贪心法："></a>贪心法：</h5><pre><code>void GetMinRoadByTx() {

    /**
     * S[n]用于存储已经访问过的城市
     * D[a][b]用于存储a和b之间的距离
     * flag 访问过为1，没访问过为0
     * i至今已经访问过的城市
     */
    int j, k, l;
    int i;
    i = 1;
    int beng = i;
    int sum = 0;
    int Dtemp;
    int flag;
    do {
        k = 1;
        Dtemp = 10000;
        do {
            l = 0;
            flag = 0;
            do {
                if (S[l] == k) {//判断该城市是否已被访问过，若被访问过，
                    flag = 1;//则flag为1
                    break;//跳出循环，不参与距离的比较
                } else
                    l++;
            } while (l &lt; i);
            if (flag == 0 &amp;&amp; D[k][S[i - 1]] &lt; Dtemp) {/*D[k][S[i - 1]]表示当前未被访问的城市k与上一个已访问过的城市i-1之间的距离*/
                j = k;//j用于存储已访问过的城市k
                Dtemp = D[k][S[i - 1]];//Dtemp用于暂时存储当前最小路径的值
            }
            k++;
        } while (k &lt; n);
        S[i] = j;//将已访问过的城市j存入到S[i]中
        i++;
        sum += Dtemp;//求出各城市之间的最短距离，注意：在结束循环时，该旅行商尚未回到原出发的城市
    } while (i &lt; n);
    sum += D[0][j];//D[0][j]为旅行商所在的最后一个城市与原出发的城市之间的距离
    for (j = 0; j &lt; n; j++) { //输出经过的城市的路径
        cout &lt;&lt; S[j] + 1 &lt;&lt; &quot;--&gt;&quot;;
    }
    cout &lt;&lt; beng;
    cout &lt;&lt; &quot;\n&quot; &lt;&lt; sum;
}
</code></pre><h4 id="具体代码见：-1"><a href="#具体代码见：-1" class="headerlink" title="具体代码见："></a>具体代码见：</h4><p><a href="https://github.com/DMRFWIN/DiscreteMathematicsExperiment_TSP" target="_blank" rel="noopener"> https://github.com/DMRFWIN/DiscreteMathematicsExperiment_TSP
</a></p>
<h3 id="实验分析-1"><a href="#实验分析-1" class="headerlink" title="实验分析"></a>实验分析</h3><h4 id="2个算法的对比"><a href="#2个算法的对比" class="headerlink" title="2个算法的对比"></a>2个算法的对比</h4><p>从实验结果很明显可以看出由于贪心法的“只关心局部最小”<br>原则，导致最终求得的结果并不一定是最小的，相比之下回溯法求得的结果明显是最小的，但是回溯法的算法思想和代码复杂度明显高于贪心法，所以得出结论，当并不需要准确的最小值时我们可以用贪心法当对结果的准确性要求较高时我们应该使用回溯法。</p>
<h2 id="实验总结和体会"><a href="#实验总结和体会" class="headerlink" title="实验总结和体会"></a>实验总结和体会</h2><h3 id="通过本次实验我有以下收获和感受："><a href="#通过本次实验我有以下收获和感受：" class="headerlink" title="通过本次实验我有以下收获和感受："></a>通过本次实验我有以下收获和感受：</h3><p>如何把课堂上学到的离散数学的理论知识应用到实际的编程中，懂得了离散数学是如何提高变成效率的。<br>懂得了如何高效地阅读英文论文、从中提取精华部分，对以后阅读英文文档/论文有很大的帮助。<br>对TSP问题有更加清晰的认识，知道如何编程实现不同的算法解决TSP问题。<br>对合式公式的概念认识更加清楚，巩固了合式公式的计算方法。</p>
<h3 id="对实验的建议："><a href="#对实验的建议：" class="headerlink" title="对实验的建议："></a>对实验的建议：</h3><p>实验可以采用多人（3人以下）组队的方式合作完成，方便提高同学们的团队协作能力。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/11/20/两种不同方式解决八皇后问题/" rel="next" title="两种不同方式解决八皇后问题">
                <i class="fa fa-chevron-left"></i> 两种不同方式解决八皇后问题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/11/22/数据结构之二叉树的遍历算法合集/" rel="prev" title="数据结构之二叉树的遍历算法合集">
                数据结构之二叉树的遍历算法合集 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">DmrfCoder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">128</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">94</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#实验一：专业论文阅读"><span class="nav-number">1.</span> <span class="nav-text">实验一：专业论文阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#论文的基本信息"><span class="nav-number">1.1.</span> <span class="nav-text">论文的基本信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#论文题目与来源"><span class="nav-number">1.1.1.</span> <span class="nav-text">论文题目与来源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#论文作者信息"><span class="nav-number">1.1.2.</span> <span class="nav-text">论文作者信息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#论文的主要作者："><span class="nav-number">1.1.2.1.</span> <span class="nav-text">论文的主要作者：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#论文的主要内容"><span class="nav-number">1.2.</span> <span class="nav-text">论文的主要内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#论文摘要"><span class="nav-number">1.2.1.</span> <span class="nav-text">论文摘要</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#论文的研究背景："><span class="nav-number">1.2.1.1.</span> <span class="nav-text">论文的研究背景：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#要解决的问题："><span class="nav-number">1.2.1.2.</span> <span class="nav-text">要解决的问题：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#主要采用的方法："><span class="nav-number">1.2.1.3.</span> <span class="nav-text">主要采用的方法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#得到的研究结果："><span class="nav-number">1.2.1.4.</span> <span class="nav-text">得到的研究结果：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#论文主体内容"><span class="nav-number">1.3.</span> <span class="nav-text">论文主体内容</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#论文对问题的描述："><span class="nav-number">1.3.1.</span> <span class="nav-text">论文对问题的描述：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#论文解决问题的步骤："><span class="nav-number">1.3.2.</span> <span class="nav-text">论文解决问题的步骤：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#论文结果的体现方式："><span class="nav-number">1.3.3.</span> <span class="nav-text">论文结果的体现方式：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关工作和展望"><span class="nav-number">1.3.4.</span> <span class="nav-text">相关工作和展望</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#论文的相关工作："><span class="nav-number">1.3.4.1.</span> <span class="nav-text">论文的相关工作：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#下一步工作："><span class="nav-number">1.3.4.2.</span> <span class="nav-text">下一步工作：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验二：构造命题逻辑合式公式的真值表"><span class="nav-number">2.</span> <span class="nav-text">实验二：构造命题逻辑合式公式的真值表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实验内容"><span class="nav-number">2.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验环境"><span class="nav-number">2.2.</span> <span class="nav-text">实验环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#电脑环境"><span class="nav-number">2.2.1.</span> <span class="nav-text">电脑环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译运行环境"><span class="nav-number">2.2.2.</span> <span class="nav-text">编译运行环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编程语言"><span class="nav-number">2.2.3.</span> <span class="nav-text">编程语言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验算法"><span class="nav-number">2.3.</span> <span class="nav-text">实验算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构定义"><span class="nav-number">2.3.1.</span> <span class="nav-text">数据结构定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对真值的存储"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">对真值的存储</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#对合式公式的存储"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">对合式公式的存储</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输入说明"><span class="nav-number">2.3.2.</span> <span class="nav-text">输入说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#输出说明"><span class="nav-number">2.3.3.</span> <span class="nav-text">输出说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法流程图"><span class="nav-number">2.3.4.</span> <span class="nav-text">算法流程图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验结果"><span class="nav-number">2.4.</span> <span class="nav-text">实验结果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行界面"><span class="nav-number">2.4.1.</span> <span class="nav-text">运行界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行结果"><span class="nav-number">2.4.2.</span> <span class="nav-text">运行结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验分析"><span class="nav-number">2.5.</span> <span class="nav-text">实验分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实验优点分析："><span class="nav-number">2.5.1.</span> <span class="nav-text">实验优点分析：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验不足分析："><span class="nav-number">2.5.2.</span> <span class="nav-text">实验不足分析：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实验不足的改进方案："><span class="nav-number">2.5.3.</span> <span class="nav-text">实验不足的改进方案：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验源码"><span class="nav-number">2.6.</span> <span class="nav-text">实验源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#扫描括号并进行计算的方法（函数）："><span class="nav-number">2.6.1.</span> <span class="nav-text">扫描括号并进行计算的方法（函数）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理具体合式关系的方法（函数）："><span class="nav-number">2.6.2.</span> <span class="nav-text">处理具体合式关系的方法（函数）：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体项目见："><span class="nav-number">2.6.3.</span> <span class="nav-text">具体项目见：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验三：TSP问题求解（图形界面版）"><span class="nav-number">3.</span> <span class="nav-text">实验三：TSP问题求解（图形界面版）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实验内容-1"><span class="nav-number">3.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验环境-1"><span class="nav-number">3.2.</span> <span class="nav-text">实验环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#电脑环境-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">电脑环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译运行环境-1"><span class="nav-number">3.2.2.</span> <span class="nav-text">编译运行环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编程语言-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">编程语言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验算法-1"><span class="nav-number">3.3.</span> <span class="nav-text">实验算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构定义-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">数据结构定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法1描述（包含输入输出说明）"><span class="nav-number">3.3.2.</span> <span class="nav-text">算法1描述（包含输入输出说明）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法思想描述"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">算法思想描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输入描述"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">输入描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输出描述"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">输出描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法1流程图"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">算法1流程图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法2描述"><span class="nav-number">3.3.3.</span> <span class="nav-text">算法2描述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#回溯法描述"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">回溯法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用回溯算法解决问题的一般步骤为："><span class="nav-number">3.3.3.2.</span> <span class="nav-text">用回溯算法解决问题的一般步骤为：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输入描述-1"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">输入描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输出描述-1"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">输出描述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验结果-1"><span class="nav-number">3.4.</span> <span class="nav-text">实验结果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行界面-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">运行界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行结果截图"><span class="nav-number">3.4.2.</span> <span class="nav-text">运行结果截图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目代码"><span class="nav-number">3.5.</span> <span class="nav-text">项目代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#核心算法代码"><span class="nav-number">3.5.1.</span> <span class="nav-text">核心算法代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#回溯法："><span class="nav-number">3.5.1.1.</span> <span class="nav-text">回溯法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#贪心法："><span class="nav-number">3.5.1.2.</span> <span class="nav-text">贪心法：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体代码见："><span class="nav-number">3.5.2.</span> <span class="nav-text">具体代码见：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验三：TSP问题求解（没有图形界面的黑框框版）"><span class="nav-number">4.</span> <span class="nav-text">实验三：TSP问题求解（没有图形界面的黑框框版）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实验内容-2"><span class="nav-number">4.1.</span> <span class="nav-text">实验内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验环境-2"><span class="nav-number">4.2.</span> <span class="nav-text">实验环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#电脑环境-2"><span class="nav-number">4.2.1.</span> <span class="nav-text">电脑环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译运行环境-2"><span class="nav-number">4.2.2.</span> <span class="nav-text">编译运行环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编程语言-2"><span class="nav-number">4.2.3.</span> <span class="nav-text">编程语言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验算法-2"><span class="nav-number">4.3.</span> <span class="nav-text">实验算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构定义-2"><span class="nav-number">4.3.1.</span> <span class="nav-text">数据结构定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法1描述（包含输入输出说明）-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">算法1描述（包含输入输出说明）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算法思想描述-1"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">算法思想描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输入描述-2"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">输入描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输出描述-2"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">输出描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#算法1流程图-1"><span class="nav-number">4.3.2.4.</span> <span class="nav-text">算法1流程图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法2描述-1"><span class="nav-number">4.3.3.</span> <span class="nav-text">算法2描述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#回溯法描述-1"><span class="nav-number">4.3.3.1.</span> <span class="nav-text">回溯法描述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#用回溯算法解决问题的一般步骤为：-1"><span class="nav-number">4.3.3.2.</span> <span class="nav-text">用回溯算法解决问题的一般步骤为：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输入描述："><span class="nav-number">4.3.3.3.</span> <span class="nav-text">输入描述：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#输出描述-3"><span class="nav-number">4.3.3.4.</span> <span class="nav-text">输出描述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算法2流程图"><span class="nav-number">4.3.4.</span> <span class="nav-text">算法2流程图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验结果-2"><span class="nav-number">4.4.</span> <span class="nav-text">实验结果</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行界面-2"><span class="nav-number">4.4.1.</span> <span class="nav-text">运行界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行结果截图-1"><span class="nav-number">4.4.2.</span> <span class="nav-text">运行结果截图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#项目代码-1"><span class="nav-number">4.5.</span> <span class="nav-text">项目代码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#核心算法代码-1"><span class="nav-number">4.5.1.</span> <span class="nav-text">核心算法代码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#回溯法：-1"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">回溯法：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#贪心法：-1"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">贪心法：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体代码见：-1"><span class="nav-number">4.5.2.</span> <span class="nav-text">具体代码见：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实验分析-1"><span class="nav-number">4.6.</span> <span class="nav-text">实验分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2个算法的对比"><span class="nav-number">4.6.1.</span> <span class="nav-text">2个算法的对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实验总结和体会"><span class="nav-number">5.</span> <span class="nav-text">实验总结和体会</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过本次实验我有以下收获和感受："><span class="nav-number">5.1.</span> <span class="nav-text">通过本次实验我有以下收获和感受：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对实验的建议："><span class="nav-number">5.2.</span> <span class="nav-text">对实验的建议：</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DmrfCoder</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  

</body>
</html>
